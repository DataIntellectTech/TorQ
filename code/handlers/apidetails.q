// Add to the api functions

\d .api

if[not`add in key `.api;add:{[name;public;descrip;params;return]}]

// Message handlers
add[`.usage.usage;1b;"log of messages through the message handlers";"";""]
add[`.usage.logtodisk;1b;"whether to log to disk";"";""]
add[`.usage.logtomemory;1b;"whether to log to .usage.usage";"";""]
add[`.usage.ignore;1b;"whether to check the ignore list for functions to ignore";"";""]
add[`.usage.ignorelist;1b;"the list of functions to ignore";"";""]
add[`.usage.logroll;1b;"whether to automatically roll the log file";"";""]
add[`.usage.rolllogauto;1b;"Roll the .usage txt files";"[]";"null"]
add[`.usage.readlog;1b;"Read and return a usage log file as a table";"[string: name of log file]";"null"]
add[`.access.USERS;1b;"Table of users and their types";"";""]
add[`.access.HOSTPATTERNS;1b;"List of host patterns allowed to access this process";"";""]
add[`.access.POWERUSERTOKENS;1b;"List of tokens allowed by power users";"";""]
add[`.access.USERTOKENS;1b;"List of tokens allowed by default users";"";""]
add[`.access.BESPOKETOKENS;1b;"Dictionary of tokens on a per-user basis (outside of their standard allowance)";"";""]
add[`.access.addsuperuser;1b;"Add a super user";"[symbol: user]";"null"]
add[`.access.addpoweruser;1b;"Add a power user";"[symbol: user]";"null"]
add[`.access.adddefaultuser;1b;"Add a default user";"[symbol: user]";"null"]
add[`.access.readpermissions;1b;"Read the permissions from a directory";"[string: directory containing the permissions files]";"null"]
add[`.clients.clients;1b;"table containing client handles and session values";"";""]
add[`.servers.SERVERS;1b;"table containing server handles and session values";"";""]
add[`.servers.opencon;1b;"open a connection to a process using the default timeout. If no user:pass supplied, the default one will be added if set";"[symbol: the host:port[:user:pass]]";"int: the process handle, null if the connection failed"]
add[`.servers.addh;1b;"open a connection to a server, store the connection details";"[symbol: the host:port:user:pass connection symbol]";"int: the server handle"]
add[`.servers.addw;1b;"add the connection details of a process behind the handle";"[int: server handle]";"null"]
add[`.servers.addnthawc;1b;"add the details of a connection to the table";"[symbol: process name; symbol: process type; hpup: host:port:user:pass connection symbol; dict: attributes of the process; int: handle to the process;boolean: whether to check the handle is valid on insert";"int: the handle of the process"]
add[`.servers.getservers;1b;"get a table of servers which match the given criteria";"[symbol: pick the server based on the name value or the type value.  Can be either `procname`proctype; symbol(list): lookup values. ` for any; dict: requirements dictionary; boolean: whether to automatically open dead connections for the specified lookup values; boolean: if only one of each of the specified lookup values is required (means dead connections aren't opened if there is one available)]";"table: processes details and requirements matches"]
add[`.servers.gethandlebytype;1b;"get a server handle for the supplied type";"[symbol: process type; symbol: selection criteria. One of `roundrobin`any`last]";"int: handle of server"]
add[`.servers.gethpbytype;1b;"get a server hpup connection symbol for the supplied type";"[symbol: process type; symbol: selection criteria. One of `roundrobin`any`last]";"symbol: h:p:u:p connection symbol of server"]
add[`.servers.startup;1b;"initialise all the connections.  Must processes should call this during initialisation";"[]";"null"]
add[`.servers.refreshattributes;1b;"refresh the attributes registered with the discovery service.  Should be called whenever they change e.g. end of day for an HDB";"[]";"null"]
add[`.pm.adduser; 1b; "Adds a user to be permissioned as well as setting their password and the method used to hash it."; "[symbol: the username; symbol: method used to authenticate; symbol: method used to hash the password; string: password, hashed using the proper method]"; "null"]
add[`.pm.addgroup; 1b; "Add a group which will have access to certain tables and variables"; "[symbol: the name of the group; string: a description of the group]"; "null"]
add[`.pm.addrole; 1b; "Add a role which will have access to certain functions"; "[symbol: the name of the role; string: a description of the role]"; "null"]
add[`.pm.addtogroup; 1b; "Add a user to a group, giving them access to all of its variables"; "[symbol: the name of the user to add; symbol: group the user is to be added to]"; "null"]
add[`.pm.assignrole; 1b; "Assign a user a role, giving them access to all of its functions"; "[symbol: the name of the user to add; symbol: role the user is to be assigned to]"; "null"]
add[`.pm.grantaccess; 1b; "Give a group access to a variable"; "[symbol: the name of the variable the group should get access to; symbol: group that is to be given this access; symbol: the type of access that should be given, eg. read, write]"; "null"]
add[`.pm.grantfunction; 1b; "Give a role access to a function"; "symbol: name of the function to be added; symbol: role that is to be given this access; TO CLARIFY"; "null"]
add[`.pm.createvirtualtable; 1b; "Create a virtual table that a group might be able to access instead of the full table"; "[symbol: new name of the table; symbol: name of the actual table t add; TO CLARIFY]"; "null"]
add[`.pm.cloneuser; 1b; "Add a new user that is identical to another user"; "[symbol: name of the new user; symbol: name of the user to be cloned; string: password of the new user]"; "null"]
