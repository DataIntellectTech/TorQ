action,ms,bytes,lang,code,repeat,minver,comment
before,0,0,q,.servers.startup[],1,,"Get connection management set up"
before,0,0,q,system "sleep 1",1,,"Wait a sec"
before,0,0,q,rdbHandles:rdbNames!gethandle each rdbNames:exec procname from (.proc`readprocs).proc`file where proctype=`rdb,1,,"Open handle to RDBs"
true,0,0,q,numseg~sum `rdb=.servers.SERVERS`proctype,1,,"Check the number of running rdbs is the same as that of process.csv"
before,0,0,q,stpHandle:gethandle[`stp1],1,,"Open handle to STP"
before,0,0,q,stpHandle(`.stplg.init;testlogdb),1,,"Create test stplog test directory"
before,0,0,q,currlog:stpHandle"currlog",1,,"Get STP log table"
before,0,0,q,met:stpHandle".stpm.metatable",1,,"Get STP meta table"
before,0,0,q,value[rdbHandles] @\: "trade:0#trade;quote:0#quote",1,,"Clear rdbs tables"
before,0,0,q,"t1:(value[rdbHandles] @\: ""count trade"")",1,,"Get initial trade table counts"
before,0,0,q,"q1:(value[rdbHandles] @\: ""count quote"")",1,,"Get initial quote table counts"
before,0,0,q,![-11;] each exec logname from currlog where tbl in `trade`quote,1,,"Replay logs locally"
before,0,0,q,t2:count trade,1,,"Get local trade table count"
before,0,0,q,q2:count quote,1,,"Get local quote table count"
before,0,0,q,{delete from x} each `trade`quote,1,,"Clear local tables"
before,0,0,q,.ds.numseg:stpHandle".ds.numseg",1,,"Get number of segments from STP"
before,0,0,q,.ds.stripe[syms;0],1,,"Initialize subscription request for all syms to test striping function in STP"
run,0,0,q,row:100000,1,,"Rows to publish"
run,0,0,q,"stpHandle @/: `.u.upd ,/: ((`trade;t row);(`quote;q row);(`heartbeat;`error))",1,,"Publish table updates"
run,0,0,q,system "sleep 1",1,,"Wait for update to publish"
run,0,0,q,![-11;] each exec logname from currlog where tbl in `trade`quote`segmentederrorlogfile,1,,"Replay logs locally"
true,0,0,q,"all not raze value exec null logname,null handle from currlog",1,,"Check lognames and handles generated"
true,0,0,q,currlog[`trade;`logname]~exec last logname from met where `trade in/: tbls,1,,"Check lognames the same in log and meta"
true,0,0,q,currlog[`quote;`logname]~exec last logname from met where `quote in/: tbls,1,,"Check lognames the same in log and meta"
true,0,0,q,(0#trade)~(exec first schema from met where `trade in/: tbls)`trade,1,,"Check trade schema saved to meta table"
true,0,0,q,(0#quote)~(exec first schema from met where `quote in/: tbls)`quote,1,,"Check quote schema saved to meta table"
true,0,0,q,"(row+sum[t1],sum q1)~sum(value rdbHandles) @\: ""count[trade],count quote""",1,,"Check trade and quote updates were correctly published"
true,0,0,q,"(row+q2,t2)~count each (trade;quote)",1,,"Check updates were correctly saved to disk"
true,0,0,q,"delta:0.05;rng:row*splits*/:1+delta*-1 1;all raze(rng[0]<cnt)&(cnt:(value rdbHandles) @\: ""count[trade],count quote"")<rng 1",1,,"Check trade and quote updates were evenly distributed"
run,0,0,q,rdbDown:`rdb1`rdb3,1,,"RDB(s) process to stop"
run,0,0,q,"startorstopproc[""stop"";"" ""sv string[(),rdbDown];getenv[`testpath],""/process.csv""]",1,,"Stop RDB(s) process"
run,0,0,q,"stpHandle @/: `.u.upd ,/: ((`trade;t row);(`quote;q row);(`heartbeat;`error))",1,,"Publish table updates while RDB(s) process is down"
run,0,0,q,system "sleep 1",1,,"Wait for update to publish"
run,0,0,q,"startorstopproc[""start"";"" ""sv string[(),rdbDown];getenv[`testpath],""/process.csv""]",1,,"Restart RDB(s) process"
run,0,0,q,rdbHandles:rdbNames!gethandle each rdbNames:exec procname from (.proc`readprocs).proc`file where proctype=`rdb,1,,"Reopen handle to RDBs"
run,0,0,q,system "sleep 1",1,,"Wait for RDBs handles to open"
run,0,0,q,"{(rdbHandles rdbDown) @\: x}each""-11!`"",/:string exec logname from currlog where tbl in `trade`quote",1,,"Replay logfiles for the restarted RDB(s) process"
run,0,0,q,"(rdbHandles rdbDown) @\: "".rdb.applyfilters[;.rdb.subscribesyms]each .rdb.subtables""",1,,"Apply filters to the restarted RDB(s) process"
true,0,0,q,"((2*row)+sum[t1],sum q1)~sum(value rdbHandles) @\: ""count[trade],count quote""",1,,"Check trade and quote data were replayed and filtered correctly"
true,0,0,q,"all{correct:not any raze[where .ds.subreq in skey where not skey in uniqKey:x""-1+value .rdb.procnum""]in uniqSym:x""distinct(exec sym from trade),exec sym from quote"";notwrong:all uniqSym in where .ds.subreq=uniqKey;correct&notwrong}each value rdbHandles",1,,"Check updates were striped (correctly) AND (NOT striped WRONGLY) based on hash function"
true,0,0,q,"all{t1:(value rdbHandles)@\:""count trade"";q1:(value rdbHandles)@\:""count quote"";stpHandle@/:`.u.upd,/:((`trade;t x);(`quote;q x);(`heartbeat;`error));system""sleep 1""; cntChk:(x+sum[t1],sum q1)~sum(value rdbHandles)@\:""count[trade],count quote"";cntChk&all{correct:not any raze[where .ds.subreq in skey where not skey in uniqKey:x""-1+value .rdb.procnum""]in uniqSym:x""distinct(exec sym from trade),exec sym from quote"";notwrong:all uniqSym in where .ds.subreq=uniqKey;correct&notwrong}each value rdbHandles}'[{x*10}\[4;10]]",1,,"Iterate 10 100 1000 10000 100000 rows update - Check tables update count and data striped accurately"
true,0,0,q,`error~.tst.err,1,,"Check errors were logged to disk"
true,0,0,q,stpHandle"enlist[(`.ds.stripe;`sym)]~exec distinct{-1_(raze/)x}each filts from .stpps.subrequestfiltered",1,,"Check hash function filts is applied correctly"
true,0,0,q,all{?[stpHandle".stpps.subrequestfiltered";enlist(=;x;(`filts;::;0;0;2));();(~;enlist`trade`quote;`tbl)]}'[til count rdbNames],1,,"Check filts is applied correctly to each respective rdb and subscribed to `trade`quote tables"
run,0,0,q,stpHandle".z.pc'[exec distinct handle from .stpps.subrequestfiltered]",1,,"Disconnect handles"
true,0,0,q,0=count stpHandle".stpps.subrequestfiltered",1,,"Check filtered subs table is cleared"
after,0,0,q,"system ""rm -rf "",1_string stpHandle(`.stplg.dldir)",1,,"Delete logs folder"