{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The TorQ framework created by Data Intellect forms the basis of a production kdb+ system by implementing some core functionality and utilities on top of kdb+, allowing developers to concentrate on the application business logic. It incorporates as many best practices as possible, with particular focus on performance, process management, diagnostic information, maintainability and extensibility. Wherever possible, we have tried to avoid re-inventing the wheel and instead have used contributed code from code.kx.com (either directly or modified). This framework will be suitable for those looking to create a new kdb+ system from scratch or those looking to add additional functionality to their existing kdb+ systems.</p> <p>The easiest way to get a production capture started is to download and install one of the Starter Packs. We also have a Google Group for questions/discussions.</p> <p>For recent updates to TorQ please check out our thoughts.</p> <p>We've highlighted some key TorQ features on our blog posts page.</p> <p>For email support contact torqsupport@dataintellect.com</p> <p></p>"},{"location":"InstallGuide/","title":"Install Guide","text":""},{"location":"InstallGuide/#usage-instruction-for-a-fresh-torq-install","title":"Usage instruction for a fresh TorQ Install","text":"<p>In your Linux terminal run the following line:</p> <pre><code>wget https://raw.githubusercontent.com/DataIntellectTech/TorQ/master/installtorqapp.sh\n</code></pre> <p>For the two lines of code below, replace the &lt;...&gt; sections with the name of the latest TorQ/TorQ Finance Starter Pack versions, respectfully. These can be found here:</p> <p>https://github.com/DataIntellectTech/TorQ/releases/latest</p> <p>https://github.com/DataIntellectTech/TorQ-Finance-Starter-Pack/releases/latest</p> <pre><code>wget --content-disposition https://github.com/DataIntellectTech/TorQ/archive/&lt;TorQ latest version&gt;.tar.gz\n\nwget --content-disposition https://github.com/DataIntellectTech/TorQ-Finance-Starter-Pack/archive/&lt;TorQ Finance Starter Pack latest version&gt;.tar.gz\n</code></pre> <p>Following the substitution, your specified .tar.gz file names should match the .tar.gz file names found through each respectful link above.</p> <p>Once you have substituted in the names of the latest release files, run each line of code in your Linux terminal, one by one.</p> <p>Then to launch the script, substitute in the respective file names for the &lt;...&gt; sections, as above, and run:</p> <pre><code>bash installtorqapp.sh --torq &lt;TorQ latest version&gt;.tar.gz --releasedir deploy --data datatemp --installfile &lt;TorQ Finance Starter Pack latest version&gt;.tar.gz --env\n</code></pre> <p>Where data parameter and env parameter are optional parameters. Full usage of the parameters available in the table below.</p> <p>The folder structure after installation will look like this:</p> <p>(TorQ-3.7.0 used as an example throughout, your TorQ version number should match the latest release)</p> <p></p> <p>Then to run the TorQ stack:</p> <pre><code>./deploy/bin/torq.sh start all\n</code></pre> <p>Check if the stack is up </p> <pre><code> ./deploy/bin/torq.sh summary\n</code></pre>"},{"location":"InstallGuide/#parameters-used","title":"Parameters used","text":"Command line parameter Explanation and Usage torq Is a mandatory parameter that is the full path or relative path to the TorQ installation. It can either be a TorQ Directory where the version is already unzipped, that can be used when multiple TorQ Applications are used on the server for example and all point to a single TorQ main code. This will create a softlink to the relevant TorQ code. Or it can be a .tar.gz file of the TorQ installation for a fresh install. Example usage in the script: --torq /home/user/TorQ/TorQ-3.7.0Where TorQ-3.7.0 is unzipped directory from the latest release .tar.gz file. Or --torq /home/user/TorQ/TorQ-3.7.0.tar.gz Which is the .tar.gz file from GitHub using: wget --content-disposition https://github.com/DataIntellectTech/TorQ/archive/3.7.0.tar.gz releasedir Is a mandatory parameter that is the full path or relative path to the deployment directory that will populate the TorQ and TorQApp. If the directory doesn't exist then script creates one. It can be anything, if following the previously released instructions the folder name would be deploy. The releasedir parameter can be used as follows: --releasedir /home/user/deploy installfile Is a mandatory parameter with the full path or relative path to the TorQApp installation file (ACCEPTS ONLY .tar.gz FILE). Can be used as follows: --installfile /home/user/TorQ-FSP/TorQ-Finance-Starter-Pack-master.tar.gz data An optional parameter. That is if you want to have your data directory as defined by TORQDATAHOME live in a different part of the system rather than the place where the code lives. Can be used as follows:--data /home/data/torq_data If the directory doesn't exist the script will make one. Also accepts a relative path if necessary. env Env is the environment-specific optional installation parameters. That is a separate .sh script that can be configured for different environments like DEV/UAT/PROD. In the script, there are SED replacements for necessary variables. If this parameter is left empty or isn't included nothing happens. If you want to include it you have to insert the parameters as follows (also accepts relative path): --env /home/user/env_spec_dev.sh--env /env_spec_dev.shBelow is a user guide on how to set up the .sh script to have necessary replacements by the env parameter. For env parameter the env_spec script should look like this: echo $1find $1 -type f -name \"*.sh\"find $1 -type f -name \"*.sh\" -exec sed -i \"s/export KDBBASEPORT=.*/export KDBBASEPORT=7373/g\" {} \\;Create an sh script env_spec_dev.sh and then add the parameter to the install script start line.--env /home/user/env_spec_dev.sh This will change the KDBBASEPORT to a new value. Similar actions can be done with other variables, and required user basic knowledge of sed commands. The script will scan through the code in the TorQApp directory and the bin directory from the deploy folder. If DEV and UAT run on different data sources then using env variable the install script can replace them with the correct server address. This is essentially the environment-specific config file."},{"location":"InstallGuide/#version-control","title":"Version control","text":"<p>The installtion script currently works with:</p> <ul> <li> <p>TorQ v3.7.0 or higher</p> </li> <li> <p>TorQ-FSP v1.9.0 and higher</p> </li> <li> <p>TorQ-Crypto v1.0.0 and higher</p> </li> <li> <p>TorQ-TAQ v1.0.0 and higher</p> </li> </ul>"},{"location":"Overview/","title":"Overview","text":""},{"location":"Overview/#what-is-kdb","title":"What is kdb+?","text":"<p>kdb+ is the market leading timeseries database from Kx Systems. kdb+ is used predominently in the Financial Services sector to capture, process and analyse billions of records on a daily basis, with Kx counting almost all of the top tier investment banks as customers. kdb+ incorporates a programming language, q, which is known for its performance and expressive power. Given the unsurpassed data management and analytical capabilities of kdb+, the applicability of kdb+ technology extends beyond the financial domain into any sector where rapid pre-built or adhoc analysis of large datasets is required. Other sectors which have good use cases for kdb+ include utilities, pharmaceuticals, telecoms, manufacturing, retail and any sector utilising telemetry or sensor data.</p> <p></p>"},{"location":"Overview/#what-is-data-intellect-torq","title":"What is Data Intellect TorQ?","text":"<p>Data Intellect TorQ is a framework which forms the basis of a production kdb+ system by implementing some core functionality and utilities on top of kdb+, allowing developers to concentrate on the application business logic. We have incorporated as many best practices as possible, with particular focus on performance, process management, diagnostic information, maintainability and extensibility. We have kept the code as readable as possible using descriptive comments, error messages, function names and variable names. Wherever possible, we have tried to avoid re-inventing the wheel and instead have used contributed code from code.kx.com (either directly or modified). All code sections taken from code.kx.com are referenced in this document.</p> <p>Data Intellect TorQ can be extended or modified as required. We have chosen some default behaviour, but it can all be overridden. The features of Data Intellect TorQ are:</p> <ul> <li> <p>Process Management: Each process is given a type and name, and can     optionally be given a parent type. By default these are used to     determine the code base it loads, the configuration loaded, log      file naming and how it reports itself to discovery services.     Whenever possible we have tried to ensure that all default     behaviour can be overridden at the process type level, and further     at the process name level.</p> </li> <li> <p>Code Management: Processes can optionally load common or process     type/name specific code bases. All code loading is error trapped.</p> </li> <li> <p>Configuration Management: Configuration scripts can be loaded as     standard and with specific process type/name configuration     overriding default values. Configuration scripts are loaded in a     specific order; default, then parent process type specific     (optional), process type specific, then process name specific.     Values loaded last will override values loaded previously.</p> </li> <li> <p>Usage Logging: All process usage is logged to a single text log file     and periodically rolled. Logging includes opening/closing of     connections, synchronous and asynchronous queries and functions     executed on the timer. Logged values include the request, the     details of where it came from, the time it was received, the time it     took, memory usage before and after, the size of the result set, the     status and any error message.</p> </li> <li> <p>Incoming and Outgoing Connection Management: Incoming (client) and     outgoing (server) connections are stored and their usage monitored     through query counts and total data size counts. Connections are     stored and retrieved and can be set to automatically be re-opened as     required. The password used for outgoing connections can be     overridden at default, parent process type (optional), process type     and process name level.</p> </li> <li> <p>Access Controls: Basic access controls are provided, and could be     extended. These apply restrictions on the IP addresses of remote     connections, the users who can access the process, and the functions     that each user can execute. A similar hierarchical approach is used     for access control management as for configuration management.</p> </li> <li> <p>Timer Extensions: Mechanism to allow multiple functions to be added     to the timer either on a repeating or one-off basis. Multiple     re-scheduling algorithms supplied for repeating timers.</p> </li> <li> <p>Standard Out/Error Logging: Functions to print formatted messages to     standard out and error. Hooks are provided to extend these as     required, e.g. publication to centralised logging database. Standard     out and error are redirected to appropriately named, timestamped and     aliased log files, which are periodically rolled.</p> </li> <li> <p>Error Handling: Different failure options are supplied in case code     fails to load; either exit upon failure, stop at the point of     failure or trap and continue.</p> </li> <li> <p>Visualisation: Utilities to ease GUI development using websockets     and HTML5.</p> </li> <li> <p>Documentation and Development Tools: Functionality to document the     system is built into Data Intellect TorQ, and can be accessed directly from     every q session. Developers can extend the documentation as they add     new functions. Functionality for searching for functions and     variables by name and definition is provided, and for ordering     variables by memory usage. The standard help.q from code.kx is also     included.</p> </li> <li> <p>Utilities: We intend to build out and add utilities as we find them     to be suitably useful and generic. So far we have:</p> <ol> <li> <p>Caching: allows a result set cache to be declared and result     sets to be stored and retrieved from the cache. Suitable for     functions which may be run multiple times with the same     parameters, with the underlying data not changing in a short     time frame;</p> </li> <li> <p>Timezone Handling: derived from code.kx, allows conversion     between timestamps in different timezones;</p> </li> <li> <p>Email: an library to send emails;</p> </li> <li> <p>Async Messaging: allows easy use of advanced async messaging     methods such as deferred synchronous communication and async     communication using postback functions;</p> </li> <li> <p>Heartbeating: each process can be set to publish heartbeats, and     subscribe to and manage heartbeats from other processes in the     environment;</p> </li> <li> <p>Data Loading: utility wrapper around .Q.fsn to read a data file     from disk, manipulate it and write it out in chunks;</p> </li> <li> <p>Subscriptions: allow processes to dynamically detect and     subscribe to datasources;</p> </li> <li> <p>Tickerplant Log File Recovery: recover as many messages as     possible from corrupt log files;</p> </li> <li> <p>Database Writing: utility functions for writing to, sorting and     parting on disk databases;</p> </li> <li> <p>Compression: allows compression of a database. This can be     performed using a set of parameters for the entire database, but     also gives the flexibilty of compressing user-specified tables     and/or columns of those tables with different parameters if     required, and also offers decompression.</p> </li> <li> <p>Data Access API: A streamlined method to retrieve data      across a variety of vanilla and exotic processes.</p> </li> </ol> </li> </ul> <p>Data Intellect TorQ will wrap easily around kdb+tick and therefore around any tickerplant, RDB, HDB or real time processing application. We currently have several customised processes of our own:</p> <ul> <li> <p>Discovery Service: Every process has a type, name and set of     available attributes, which are used by other processes to connect     to it. The Discovery Service is a central point that can be used to     find other available processes. Client processes can subscribe to     updates from the discovery service as new processes become     available- the discovery service will notify its subscribers, which     can then use the supplied hook to implement required behavior e.g.     connect to the newly available process;</p> </li> <li> <p>Gateway: A fully synchronous and asynchronous gateway is provided.</p> <p>The gateway will connect to a defined list of process types (can be homogenous or heterogeneous processes) and will route queries across them according to the priority of received requests. The routing algorithms can be easily modified e.g. give priority to user X, or only route queries to processes which exist in the same data centre or geographical region to avoid the WAN (this would entail using the process attributes). The gateway can either return the result to the client back down the same handle, or it can wrap it in a callback function to be invoked on the client;</p> </li> <li> <p>Real Time Database (RDB): A customized version of the kdb+tick RDB,     to allow dynamic tickerplant subscriptions, reloading of multiple     HDBs using authenticated connections, and customized end-of-day save     downs. The RDB, WDB and tickerplant log replay share a common code     base to ensure that a save-down modification to a table is applied     across each of these processes.</p> </li> <li> <p>Write Database (WDB): The job of a WDB is to write data to disk     rather than to serve client queries. WDBs usually write data out     periodically throughout the day, and are useful when there is too     much data to fit into memory and/or the end of day save operation     needs to be speeded up. The concept is based on     w.q</p> </li> <li> <p>Tickerplant Log Replay: A process for replaying tickerplant log     files to create on-disk data sets. Extended features are provided     for only replaying subsets of log files (by message number and/or     table name), replaying in chunks, invoking bespoke final behaviour     etc.;</p> </li> <li> <p>Reporter: The Reporter Process runs defined reports (q queries or     parameterized functions) against specific database or gateways on a     schedule. The results are retrieved and processed. Processing can be     user defined, or can be a standard operation such as writing the     data to disk, or emailing the results to a list of recipients. This     can be useful for running system checks or generating management     reports.</p> </li> <li> <p>Housekeeping: A process to undertake housekeeping tasks     periodically, such as compressing and removing files that are no     longer used. Housekeeping looks up a file of instructions and     performs maintenance tasks on directories accordingly. Features     allow selective file deletion and zipping according to file age,     including a search string parameter and the ability to exclude items     from the search. The process can be scheduled, or run immediately     from the command line and can be extended as required to incorporate     more tasks.</p> </li> <li> <p>File Alerter: A process to periodically scan a set of directories     and execute a function based on the availability of a file. This is     useful where files may arrive to the system during the day and must     be acted upon (e.g. files are uploaded to a shared directory by     users/clients). The functions to execute are defined by the user and     the whole process is driven by a csv file detailing the file to     search for, the function to execute and, optionally, a directory to     move the file to after it has been processed.</p> </li> <li> <p>Monitor: A basic monitoring process which uses the Discovery Service     to locate the other processes within the system, listens for     heartbeats, and subscribes for log messages. This should be extended     as required but provides a basic central point for system health     checks;</p> </li> <li> <p>Kill: A process used to kill other processes, optionally using the     Discovery Service to locate them.</p> </li> </ul> <p></p>"},{"location":"Overview/#a-large-scale-data-processing-platform","title":"A Large Scale Data Processing Platform","text":"<p>One of the key drivers behind TorQ development has been to ensure all the tools necessary to build a large scale data processing platform are available. kdb+tick provides the basic building blocks, and a standard set-up usually looks something like this:</p> <p></p> <p>However, in reality it is usually more complicated. A larger scale architecture serving large numbers of client queries and receiving data from multiple sources may look like this:</p> <p></p> <p>A common practice is to use a gateway (section gateway) to manage client queries across back-end processes. The gateway can load balance across processes and make failures transparent to the client. If the clients access the gateway with asynchronous calls, then the gateway can serve many requests at once and additionally implement client queuing algorithms.</p> <p>Other common production features include:</p> <ul> <li> <p>A modified version of the RDB (section sec:rdb) which does     different operations at end-of-day, reloads multiple HDB processes     etc.</p> </li> <li> <p>A Write Database (section [sec:wdb]) which receives data from the     tickerplant and periodically writes it to disk. WDBs are used when     there is too much data in a day to fit into memory and/or to speed     up the end-of-day rollover job</p> </li> <li> <p>Processes that load data from other sources either into the HDB     directly or to the RDB potentially via the tickerplant (section     [sec:dataloader]). The data may be dropped in specific locations     which have to be monitored (section [sec:filealerter])</p> </li> <li> <p>A Reporting Engine (section [sec:reporter]) to run periodic     reports and do something with the result (e.g. generate an xls file     from the database and email it to senior management). Reporting     engines can also be used to run periodic checks of the system</p> </li> <li> <p>A Discovery Service (section [sec:discovery]) to allow processes     to locate each other, and to allow processes to dynamically register     availability and push notifications around the system.</p> </li> <li> <p>Basic Monitoring (section [sec:monitor]) of process availability</p> </li> <li> <p>Housekeeping (section [sec:housekeeping]) to ensure log files are     tidied up, tickerplant log files are compressed/moved in a timely     fashion etc.</p> </li> </ul> <p></p>"},{"location":"Overview/#do-i-really-have-to-read-this-whole-document","title":"Do I Really Have to Read This Whole Document?","text":"<p>Hopefully not. The core of Data Intellect TorQ is a script called torq.q and we have tried to make it as descriptive as possible, so perhaps that will suffice. The first place to look will be in the config files, the main one being \\$KDBCONFIG/settings/default.q. This should contain a lot of information on what can be modified. There is also a cheatsheet contained within the documentation. In addition:</p> <ul> <li> <p>We have added a load of usage information:</p> <pre><code>aquaq$ q torq.q -usage\nKDB+ 3.1 2013.10.08 Copyright (C) 1993-2013 Kx Systems\n\nGeneral:\n This script should form the basis of a production kdb+ environment.\n It can be sourced from other files if required, or used as a launch script before loading other files/directories using either -load or -loaddir flags \n... etc ...\n</code></pre> <p>If sourcing from another script there are hooks to modify and extend the usage information as required.</p> </li> <li> <p>We have some pretty extensive logging:</p> <pre><code>aquaq$ q torq.q -p 9999 -debug\nKDB+ 3.1 2013.10.08 Copyright (C) 1993-2013 Kx Systems\n\n2013.11.05D12:22:42.597500000|aquaq|torq.q_3139_9999|INF|init|trap mode (initialisation errors will be caught and thrown, rather than causing an exit) is set to 0\n2013.11.05D12:22:42.597545000|aquaq|torq.q_3139_9999|INF|init|stop mode (initialisation errors cause the process loading to stop) is set to 0\n2013.11.05D12:22:42.597810000|aquaq|torq.q_3139_9999|INF|init|attempting to read required process parameters proctype,procname from file /torqhome/config/process.csv\n2013.11.05D12:22:42.598081000|aquaq|torq.q_3139_9999|INF|init|read in process parameters of proctype=hdb; procname=hdb1\n2013.11.05D12:22:42.598950000|aquaq|hdb1|INF|fileload|config file /torqhome/config/default.q found\n... etc ...\n</code></pre> </li> <li> <p>We have added functionality to find functions or variables defined     in the session, and also to search function definitions.</p> <pre><code>q).api.f`max                                                                                                                                                                                   \nname                | vartype   namespace public descrip              ..\n--------------------| ------------------------------------------------..\nmaxs                | function  .q        1      \"\"                   ..\nmmax                | function  .q        1      \"\"                   ..\n.clients.MAXIDLE    | variable  .clients  0      \"\"                   ..\n.access.MAXSIZE     | variable  .access   0      \"\"                   ..\n.cache.maxsize      | variable  .cache    1      \"The maximum size in ..\n.cache.maxindividual| variable  .cache    1      \"The maximum size in ..\nmax                 | primitive           1      \"\"                   ..\n\nq)first 0!.api.p`.api                                                                                                                                                                          \nname     | `.api.f\nvartype  | `function\nnamespace| `.api\npublic   | 1b\ndescrip  | \"Find a function/variable/table/view in the current process\"\nparams   | \"[string:search string]\"\nreturn   | \"table of matching elements\"\n\nq).api.p`.api                                                                                                                                                                                  \nname        | vartype  namespace public descrip                       ..\n------------| --------------------------------------------------------..\n.api.f      | function .api      1      \"Find a function/variable/tabl..\n.api.p      | function .api      1      \"Find a public function/variab..\n.api.u      | function .api      1      \"Find a non-standard q public ..\n.api.s      | function .api      1      \"Search all function definitio..\n.api.find   | function .api      1      \"Generic method for finding fu..\n.api.search | function .api      1      \"Generic method for searching ..\n.api.add    | function .api      1      \"Add a function to the api des..\n.api.fullapi| function .api      1      \"Return the full function api ..\n</code></pre> </li> <li> <p>We have incorporated help.q.</p> <pre><code>q)help`                                                                                                                                                                                        \nadverb    | adverbs/operators\nattributes| data attributes\ncmdline   | command line parameters\ndata      | data types\ndefine    | assign, define, control and debug\ndotz      | .z locale contents\nerrors    | error messages\nsave      | save/load tables\nsyscmd    | system commands\ntemporal  | temporal - date &amp; time casts\nverbs     | verbs/functions\n</code></pre> </li> <li> <p>We have separated and commented all of our config:</p> <pre><code>aquaq$ head config/default.q \n/- Default configuration - loaded by all processes\n\n/- Process initialisation\n\\d .proc\nloadcommoncode:1b   /- whether to load the common code defined at\n                        /- ${KDBCODE}/common\nloadprocesscode:0b  /- whether to load the process specific code defined at \n                        /- ${KDBCODE}/{process type} \nloadnamecode:0b     /- whether to load the name specific code defined at \n                    /- ${KDBCODE}/{name of process}\nloadhandlers:1b     /- whether to load the message handler code defined at \n                        /- ${KDBCODE}/handlers\nlogroll:1b      /- whether to roll the std out/err logs daily\n... etc ...\n</code></pre> </li> </ul> <p></p>"},{"location":"Overview/#operating-system-and-kdb-version","title":"Operating System and kdb+ Version","text":"<p>Data Intellect TorQ has been built and tested on the linux and OSX operating systems though as far as we are aware there is nothing that would make this incompatible with Solaris or Windows. It has also been tested with kdb+ 3.1 and 2.8. Please report any incompatibilities with other kdb+ versions or operating systems.</p> <p></p>"},{"location":"Overview/#license","title":"License","text":"<p>This code is released under the MIT license.</p>"},{"location":"Processes/","title":"Processes","text":""},{"location":"Processes/#processes","title":"Processes","text":"<p>A set of processes is included. These processes build upon Data Intellect TorQ, providing specific functionality. All the process scripts are contained in $KDBCODE/processes. All processes should have an entry in $KDBCONFIG/process.csv. All processes can have any type and name, except for discovery services which must have a process type of \u201cdiscovery\u201d. An example process.csv is:</p> <pre><code>aquaq$ cat config/process.csv\nhost,port,proctype,procname\naquaq,9998,rdb,rdb_europe_1\naquaq,9997,hdb,rdb_europe_1aquaq,9999,hdb,hdb1\naquaq,9996,discovery,discovery1\naquaq,9995,discovery,discovery2\naquaq,8000,gateway,gateway1\naquaq,5010,tickerplant,tickerplant1\naquaq,5011,rdb,rdb1\naquaq,5012,hdb,hdb1\naquaq,5013,hdb,hdb2\naquaq,9990,tickerlogreplay,tpreplay1\naquaq,20000,kill,killhdbs\naquaq,20001,monitor,monitor1\naquaq,20002,housekeeping,hk1\n</code></pre> <p></p>"},{"location":"Processes/#discovery-service","title":"Discovery Service","text":""},{"location":"Processes/#overview","title":"Overview","text":"<p>Processes use the discovery service to register their own availability, find other processes (by process type) and subscribe to receive updates for new process availability (by process type). The discovery service does not manage connections- it simply returns tables of registered processes, irrespective of their current availability. It is up to each individual process to manage its own connections.</p> <p>The discovery service uses the process.csv file to make connections to processes on start up. After start up it is up to each individual process to attempt connections and register with the discovery service. This is done automatically, depending on the configuration parameters. Multiple discovery services can be run in which case each process will try to register and retrieve process details from each discovery process it finds in its process.csv file. Discovery services do not replicate between themselves. A discovery process must have its process type listed as discovery.</p> <p>To run the discovery service, use a start line such as:</p> <pre><code>aquaq $ q torq.q -load code/processes/discovery.q -p 9995 -proctype discovery -procname discovery1\n</code></pre> <p>Modify the configuration as required.</p>"},{"location":"Processes/#operation","title":"Operation","text":"<ol> <li> <p>Processes register with the discovery service.</p> <p></p> </li> <li> <p>Processes use the discovery service to locate other processes.</p> <p></p> </li> <li> <p>When new services register, any processes which have registered an      interest in that process type are notified.</p> <p></p> </li> </ol>"},{"location":"Processes/#available-processes","title":"Available Processes","text":"<p>The list of available processes can be found in the .servers.SERVERS table.</p> <pre><code>q).servers.SERVERS                                                                                                                                                                                                                                                            \nprocname     proctype        hpup            w  hits startp                        lastp                         endp attributes                                                                   \n-------------------------------------------------------------------------------------\ndiscovery1   discovery       :aquaq:9995     0                                  2014.01.22D17:00:40.947470000      ()!()                                                                        \ndiscovery2   discovery       :aquaq:9996     0                                  2014.01.22D17:00:40.947517000      ()!()                                                                        \nhdb2         hdb             :aquaq:5013     0                                  2014.01.22D17:00:40.947602000      ()!()                                                                        \nkilltick     kill            :aquaq:20000    0                                  2014.01.22D17:00:40.947602000      ()!()                                                                        \ntpreplay1    tickerlogreplay :aquaq:20002    0                                  2014.01.22D17:00:40.947602000      ()!()                                                                        \ntickerplant1 tickerplant     :aquaq:5010  6  0    2014.01.22D17:00:40.967699000 2014.01.22D17:00:40.967698000      ()!()                                                                        \nmonitor1     monitor         :aquaq:20001 9  0    2014.01.22D17:00:40.971344000 2014.01.22D17:00:40.971344000      ()!()                                                                        \nrdb1         rdb             :aquaq:5011  7  0    2014.01.22D17:06:13.032883000 2014.01.22D17:06:13.032883000      `date`tables!(,2014.01.22;`fxquotes`heartbeat`logmsg`quotes`trades)          \nhdb3         hdb             :aquaq:5012  8  0    2014.01.22D17:06:18.647349000 2014.01.22D17:06:18.647349000      `date`tables!(2014.01.13 2014.01.14;`fxquotes`heartbeat`logmsg`quotes`trades)\ngateway1     gateway         :aquaq:5020  10 0    2014.01.22D17:06:32.152836000 2014.01.22D17:06:32.152836000      ()!()\n</code></pre> <p></p>"},{"location":"Processes/#gateway","title":"Gateway","text":"<p>A synchronous and asynchronous gateway is provided. The gateway can be used for load balancing and/or to join the results of queries across heterogeneous servers (e.g. an RDB and HDB). Ideally the gateway should only be used with asynchronous calls. Prior to KDB v3.6, synchronous calls caused the gateway to block which limits the gateway to serving one query at a  time (although if querying across multiple backend servers the backend queries will be run in parallel). For v3.6+, deferred synchronous requests to the gateway are supported. This allows the gateway to process multiple synchronous requests at once, therefore removing the requirement for the gateway to allow only one type of request. When using asynchronous calls, the client can either block and wait for the result (deferred synchronous) or post a call back function which the gateway will call back to the client with.  The backend servers to be queried against with  asynchronous and synchronous  queries are selected using process type. The gateway API can be seen by querying .api.p\u201c.gw.*\u201d within a gateway process.</p> <p></p>"},{"location":"Processes/#asynchronous-behaviour","title":"Asynchronous Behaviour","text":"<p>Asynchronous queries allow much greater flexibility. They allow multiple queries to be serviced at once, prioritisation, and queries to be timed out. When an asynchronous query is received the following happens:</p> <ul> <li> <p>the query is placed in a queue;</p> </li> <li> <p>the list of available servers is retrieved;</p> </li> <li> <p>the queue is prioritised, so those queries with higher priority are       serviced first;</p> </li> <li> <p>queries are sent to back end servers as they become available. Once       the backend server returns its result, it is given another query;</p> </li> <li> <p>when all the partial results from the query are returned the results       are aggregated and returned to the client. They are either returned       directly, or wrapped in a callback and posted back asynchronously to       the client.</p> </li> </ul> <p>The two main customisable features of the gateway are the selection of available servers (.gw.availableservers) and the queue prioritisation (.gw.getnextqueryid). With default configuration, the available servers are those servers which are not currently servicing a query from the gateway, and the queue priority is a simple FIFO queue. The available servers could be extended to handle process attributes, such as the available datasets or the location of the process, and the queue prioritisation could be modified to anything required e.g. based on the query itself, the username, host of the client etc.</p> <p>An asynchronous query can be timed out using a timeout defined by the client. The gateway will periodically check if any client queries have not completed in the allotted time, and return a timeout error to the client. If the query is already running on any backend servers then they cannot be timed out other than by using the standard -T flag.</p>"},{"location":"Processes/#synchronous-behaviour","title":"Synchronous Behaviour","text":"<p>Prior to KDB v3.6, when using synchronous queries the gateway could only handle one query at a time and cannot timeout queries other than with the standard -T flag. The variable <code>.gw.synccallsallowed</code> is by default set to 0b prior to KDB v3.6.  To send synchronous calls, edit the gateway.q file so that .gw.synccallsallowed  is set to true. (The exception being with TorQ-FSP, in which case it is set to 1b by default.) For v3.6+, deferred synchronous calls are supported, allowing the gateway to process multiple requests at a time. All synchronous queries will be immediately dispatched to the back end processes. They will be dispatched using an asynchronous call, allowing them to run in parallel rather than serially. When the results are received they are aggregated and returned to the client.</p>"},{"location":"Processes/#process-discovery","title":"Process Discovery","text":"<p>The gateway uses the discovery service to locate processes to query across. The discovery service will notify the gateway when new processes become available and the gateway will automatically connect and start using them. The gateway can also use the static information in process.csv, but this limits the gateway to a predefined list of processes rather than allowing new services to come online as demand requires.</p>"},{"location":"Processes/#error-handling","title":"Error Handling","text":"<p>All errors and results can now be formatted with the formatresult function. Each response to the client is passed through this function with inputs status (1b=result,0b=error), sync (1b=sync,0b=async) and result (result/error) to allow different errors/results to be handled appropriately. As default, when synchronous calls are used, q errors are returned to clients as they are encountered. When using asynchronous calls, appropriately prefixed strings are used. It is up to the client to check the type of the received result and if it is a string then whether it contains the error prefix. The error prefix can be changed, but the default is \u201cerror: \u201d. Alternatively, the formatresult function can be altered as necessary. Errors will be returned when:</p> <ul> <li> <p>the client requests a query against a server type which the gateway     does not currently have any active instances of (this error is     returned immediately);</p> </li> <li> <p>the client requests a query with the wrong servertype types;</p> </li> <li> <p>the client requests a query with null servers;</p> </li> <li> <p>the query is timed out;</p> </li> <li> <p>a back end server returns an error;</p> </li> <li> <p>a back end server fails;</p> </li> <li> <p>the join function fails.</p> </li> </ul> <p>If postback functions are used, the error string will be posted back within the postback function (i.e. it will be packed the same way as a valid result).</p>"},{"location":"Processes/#client-calls","title":"Client Calls","text":"<p>There are four main client calls. The .gw.sync* methods should only be invoked synchronously, and the .gw.async* methods should only be invoked asynchronously. Each of these are documented more extensively in the gateway api. Use .api.p\u201c.gw.*\u201d for more details.</p> Function Description .gw.syncexec[query; servertypes] Execute the specified query synchronously against the required list of servers. If more than one server, the results will be razed. .gw.syncexecj[query; servertypes; joinfunction] Execute the specified query against the required list of servers. Use the specified join function to aggregate the results. .gw.asyncexec[query; servertypes] Execute the specified query against the required list of servers. If more than one server, the results will be razed. The client must block and wait for the results. .gw.asyncexecjpt[query; servertypes; joinfunction; postback; timeout] Execute the specified query against the required list of servers. Use the specified join function to aggregate the results. If the postback function is not set, the client must block and wait for the results. If it is set, the result will be wrapped in the specified postback function and returned asynchronously to the client. The query will be timed out if the timeout value is exceeded."},{"location":"Processes/#client-call-examples","title":"Client Call Examples","text":"<p>Here are some examples for using client calls via a handle to the gateway process.   To reiterate, v3.6+ users can use synchronous calls, whilst asynchronous calls are only relevant for users on &lt; v3.6. </p>"},{"location":"Processes/#calls-to-the-rdb-only","title":"Calls to the RDB only","text":"<p>For synchronous calls</p> <pre><code>// To return the avg price per sym for the day so far\nq) h(`.gw.syncexec;\"select avp:avg price by sym from trade where time.date=.z.d\";`rdb)\n\n// hloc function in RDB process\nq) h(`.gw.syncexec;`hloc;`rdb)\n{[startdate;enddate;bucket]\n $[.z.d within (startdate;enddate);\n select high:max price, low:min price, open:first price,close:last price,totalsize:sum `long$size, vwap:size wavg price\n by sym, bucket xbar time\n from trade;\n ([sym:`symbol$();time:`timestamp$()] high:`float$();low:`float$();open:`float$();close:`float$();totalsize:`long$();vwap:`float$())]}\n\n\n// Using the hloc function - change query for appropriate date\nq) h(`.gw.syncexec;(`hloc;2020.01.08;2020.01.08;10);`rdb)\n\n// Returns following table\nsym  time                         | high   low    open   close  totalsize vwap\n----------------------------------| ----------------------------------------------\nAAPL 2020.01.08D00:00:00.836801000| 103.62 103.62 103.62 103.62 88        103.62\nAAPL 2020.01.08D00:00:01.804684000| 103.64 103.64 103.64 103.64 86        103.64\nAAPL 2020.01.08D00:00:02.405682000| 103.86 103.86 103.86 103.86 90        103.86\nAAPL 2020.01.08D00:00:03.005465000| 104.06 104.06 104.06 104.06 78        104.06\nAAPL 2020.01.08D00:00:03.404383000| 103.9  103.9  103.9  103.9  49        103.9\n..\n</code></pre> <p>For asynchronous calls</p> <pre><code>// To return the sum size per sym for the day so far\nq) neg[h](`.gw.asyncexec;\"select sum size by sym from trade\";`rdb);h[]\n</code></pre>"},{"location":"Processes/#calls-to-the-hdb-only","title":"Calls to the HDB only","text":"<p>For synchronous calls</p> <pre><code>// For the high, low, open and close prices of the day before\nq) h(`.gw.syncexec;\"select h:max price, l:min price, o:first price, c:last price by sym from trade where date=.z.d-1\";`hdb)\n</code></pre> <p>For asynchronous calls</p> <pre><code>q) neg[h](`.gw.asyncexec;\"`$last .z.x\";`hdb);h[]\n</code></pre>"},{"location":"Processes/#calls-to-the-hdb-and-rdb","title":"Calls to the HDB and RDB","text":"<p>For synchronous calls</p> <pre><code>q) h(`.gw.syncexec;\"$[.proc.proctype=`hdb; select from trade where date within (.z.d-2;.z.d-1); select from trade]\";`rdb`hdb)\n</code></pre> <p>For asynchronous calls</p> <pre><code>q) neg[h](`.gw.asyncexec;\"$[.proc.proctype=`hdb; select from trade where date within (.z.d-2;.z.d-1); select from trade]\";`rdb`hdb);h[]\n</code></pre>"},{"location":"Processes/#demonstrating-aggregation-of-data","title":"Demonstrating Aggregation of data","text":"<p>For the purposes of demonstration, assume that the following queries must be run across a single RDB and a single HDB process, and the gateway has one RDB and two HDB processes available to it.</p> <pre><code>q).gw.servers                                                                                                                                                                                                                                                                 \nhandle| servertype inuse active querycount lastquery                     usage                attributes                   \n------| --------------------------------------------------------------------\n7     | rdb        0     1      17         2014.01.07D17:05:03.113927000 0D00:00:52.149069000 `datacentre`country!`essex`uk\n8     | hdb        0     1      17         2014.01.07D17:05:03.113927000 0D00:01:26.143564000 `datacentre`country!`essex`uk\n9     | hdb        0     1      2          2014.01.07D16:47:33.615538000 0D00:00:08.019862000 `datacentre`country!`essex`uk\n12    | rdb        0     1      2          2014.01.07D16:47:33.615538000 0D00:00:04.018349000 `datacentre`country!`essex`uk\n</code></pre> <p>Both the RDB and HDB processes have a function f and table t defined. f will run for 2 seconds longer on the HDB processes then it will the RDB.</p> <pre><code>q)f                                                                                                                                                                                                                                                                           \n{system\"sleep \",string x+$[`hdb=.proc.proctype;2;0]; t}  //if process type is HDB, sleep for x+2 seconds and then return table t. If not, sleep for x seconds and return table t\nq)t:([]a:(5013;5014;5015;5016;5017))                                                                                            \nq)t                                                                                                                                                                 \na   \n----\n5013\n5014\n5015\n5016\n5017\n</code></pre> <p>Run the gateway. The main parameter which should be set is the .servers.CONNECTIONS parameter, which dictates the process types the gateway queries across. Also, we need to explicitly allow sync calls. We can do this from the config or from the command line using the following line:</p> <pre><code>q torq.q -load code/processes/gateway.q -p 8000 -.gw.synccallsallowed 1 -.servers.CONNECTIONS hdb rdb -proctype gateway -procname gateway1\n</code></pre> <p>Start a client and connect to the gateway. Start with a sync query. The HDB query should take 4 seconds and the RDB query should take 2 seconds. If the queries run in parallel, the total query time should be 4 seconds.</p> <pre><code>q)h:hopen 8000                                                                                                                                                                                                                                                                \nq)h(`.gw.syncexec;(`f;2);`hdb`rdb)                                                                                                                                                                                                                                            \na   \n----\n5014\n5015\n5016\n5017\n5018\n5012\n5013\n5014\n5015\n5016\nq)\\t h(`.gw.syncexec;(`f;2);`hdb`rdb)                                                                                                                                                                                                                                         \n4009\n</code></pre> <p>If a query is done for a server type which is not registered, an error is returned:</p> <pre><code>q)\\t h(`.gw.syncexec;(`f;2);`hdb`rdb`other)                                                                                                                                                                                                                                   \n`not all of the requested server types are available; missing other\n</code></pre> <p>Custom join functions can be specified:</p> <pre><code>q)h(`.gw.syncexecj;(`f;2);`hdb`rdb;{sum{select count i by a from x} each x})        //[query;servertype;joinfunction(lambda)]                                                                                                                                                                                          \na   | x\n----| -\n5014| 2\n5015| 2\n5016| 2\n5017| 1\n5018| 1\n5012| 1\n5013| 1\n</code></pre> <p>Custom joins can fail with appropriate errors:</p> <pre><code>q)h(`.gw.syncexecj;(`f;2);`hdb`rdb;{sum{select count i by b from x} each x})                                                                                                                                                                                                  \n`failed to apply supplied join function to results: b\n</code></pre> <p>Asynchronous queries must be sent in async and blocked:</p> <pre><code>q)(neg h)(`.gw.asyncexec;(`f;2);`hdb`rdb); r:h(::)                                                                                                                                                                                                                          \n    /- This white space is from pressing return\n    /- the client is blocked and unresponsive\n\nq)q)q)                                                                                                                                                                                                                                                                        \nq)                                                                                                                                                                                                                                                                            \nq)r                                                                                                                                                                                                                                                                           \na   \n----\n5014\n5015\n5016\n5017\n5018\n5012\n5013\n5014\n5015\n5016\nq)\n</code></pre> <p>We can send multiple async queries at once. Given the gateway has two RDBs and two HDBs avaialble to it, it should be possible to service two of these queries at the same time.</p> <pre><code>q)h:hopen each 8000 8000                                                                                                                                                                                                                                                      \nq)\\t (neg h)@\\:(`.gw.asyncexec;(`f;2);`hdb`rdb); (neg h)@\\:(::); r:h@\\:(::)\n4012\nq)r                                                                                                                                                                                                                                                                           \n+(,`a)!,5014 5015 5016 5017 5018 5012 5013 5014 5015 5016\n+(,`a)!,5013 5014 5015 5016 5017 9999 10000 10001 10002 10003\n</code></pre> <p>Alternatively async queries can specify a postback so the client does not have to block and wait for the result. The postback function must take two parameters- the first is the function that was sent up, the second is the results. The postback can either be a lambda, or the name of a function eg. handleresults.</p> <pre><code>q)h:hopen 8000                                                                                                                                                                                                                                                                \nq)handleresults:{-1(string .z.z),\" got results\"; -3!x; show y}             //postback with timestamp, got results and an output of the results                                                                                                                                                                                                   \nq)(neg h)(`.gw.asyncexecjpt;(`f;2);`hdb`rdb;raze;{-1(string .z.z),\" got results\"; -3!x; show y};0Wn)     //[.gw.asyncexecjpt[query;servertypes(list of symbols);joinfunction(lambda);postbackfunction(lambda or symbol);timeout(timespan)]                                                                                                                                                                                                      \nq)\nq)  /- These q prompts are from pressing enter\nq)  /- The q client is not blocked, unlike the previous example\nq)\nq)2014.01.07T16:53:42.481 got results\na   \n----\n5014\n5015\n5016\n5017\n5018\n5012\n5013\n5014\n5015\n5016\n\n/- Can also use a named function rather than a lambda\nq)(neg h)(`.gw.asyncexecjpt;(`f;2);`hdb`rdb;raze;`handleresults;0Wn)\nq)\nq)              \nq)2014.01.07T16:55:12.235 got results\na   \n----\n5014\n5015\n5016\n5017\n5018\n5012\n5013\n5014\n5015\n5016\n</code></pre> <p>Asynchronous queries can also be timed out. This query will run for 22 seconds, but should be timed out after 5 seconds. There is a tolerance of +5 seconds on the timeout value, as that is how often the query list is checked. This can be reduced as required.</p> <pre><code>q)(neg h)(`.gw.asyncexecjpt;(`f;20);`hdb`rdb;raze;();0D00:00:05); r:h(::)\n\nq)q)q)r                                                                                                                                                                                                                                                                       \n\"error: query has exceeded specified timeout value\"\nq)\\t (neg h)(`.gw.asyncexecjpt;(`f;20);`hdb`rdb;raze;();0D00:00:05); r:h(::)                                                                                                                                                                                                  \n6550\n</code></pre>"},{"location":"Processes/#non-kdb-clients","title":"Non kdb+ Clients","text":"<p>All the examples in the previous section are from clients written in q. However it should be possible to do most of the above from non kdb+ clients. The officially supported APIs for Java, C# and C allow the asynchronous methods above. For example, we can modify the try block in the main function of the Java Grid Viewer:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JFrame;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.table.AbstractTableModel;\nimport kx.c;\n\npublic class Main {\n    public static class KxTableModel extends AbstractTableModel {\n        private c.Flip flip;\n        public void setFlip(c.Flip data) {\n            this.flip = data;\n        }\n\n        public int getRowCount() {\n            return Array.getLength(flip.y[0]);\n        }\n\n        public int getColumnCount() {\n            return flip.y.length;\n        }\n\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            return c.at(flip.y[columnIndex], rowIndex);\n        }\n\n        public String getColumnName(int columnIndex) {\n            return flip.x[columnIndex];\n        }\n    };\n\n    public static void main(String[] args) {\n        KxTableModel model = new KxTableModel();\n        c c = null;\n        try {\n            c = new c(\"localhost\", 8000,\"username:password\");\n            // Create the query to send\n        String query=\".gw.asyncexec[(`f;2);`hdb`rdb]\";\n            // Send the query \n        c.ks(query);\n            // Block on the socket and wait for the result\n        model.setFlip((c.Flip) c.k());\n        } catch (Exception ex) {\n            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);\n        } finally {\n            if (c != null) {try{c.close();} catch (IOException ex) {}\n          }\n        }\n        JTable table = new JTable(model);\n        table.setGridColor(Color.BLACK);\n        String title = \"kdb+ Example - \"+model.getRowCount()+\" Rows\";\n        JFrame frame = new JFrame(title);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.getContentPane().add(new JScrollPane(table), BorderLayout.CENTER);\n        frame.setSize(300, 300);\n        frame.setVisible(true);\n    }\n}\n</code></pre> <p>Some of the unofficially supported APIs may only allow synchronous calls to be made.</p> <p></p>"},{"location":"Processes/#tickerplant","title":"Tickerplant","text":"<p>The tickerplant is a modified version of the standard kdb+tick tickerplant. The modifications from the standard tick.q include:</p> <ul> <li> <p>Applies timestamps as timestamp rather than timespan;</p> </li> <li> <p>Tracks per table record counts in .u.icounts dictionary for faster recovery     of real time subscribers;</p> </li> <li> <p>Allows configuration of timezones for timestamping data and performing     end of day rollover (see eodtime.q);</p> </li> </ul> <p>The tickerplant log file will be written to hdb/database.</p> <p></p>"},{"location":"Processes/#segmented-tickerplant","title":"Segmented Tickerplant","text":"<p>The idea behind the STP was to create a process which retained all the functionality of the Tickerplant while adding flexibility in terms of logging, publishing and subscriptions. The functionality of the STP is almost fully backwardly compatible with a few minor (and we believe seldom utilised) exceptions. We have introduced:</p> <ul> <li>ability to create more granular log files</li> <li>a new batch publication mode</li> <li>ability to easily introduce custom table modifications upon message receipt</li> <li>more flexible subscriptions</li> <li>error handling for easier debugging when developing data feeds</li> <li>performance improvements for several use cases</li> <li>faster restart</li> </ul> <p>All the TorQ based subscriber processes (e.g. RDB and WDB), and any subscribers that use the TorQ subscription library, can switch between the TP and STP. For the minor modifications that must be made to data consumers, please see the Subscriptions section.</p>"},{"location":"Processes/#logging-modes","title":"Logging Modes","text":"<p>The default TP logging behaviour is to write all updates to disk in a single log file which is rolled on a daily basis. The log file may become large. A consumer of the data must replay all the data from the log file, even if only a subset is required. Additionally, when the TP restarts, it must count through the log file in full to ensure that it has the correct message number. </p> <p>To add more flexibility, the following logging modes have been added which are set with the <code>.stplg.multilog</code> variable. Additionally a table of meta data is stored to describe the log files, including the full schema of all the tables contained within it. The <code>.stpm.metatable</code> table is saved as a q object to the STPLOG folder along with any error logs generated by the error mode. ```</p> <ul> <li>singular:</li> </ul> <p>This mode is essentially the default TP behaviour, where all ticks across all tables for a given day are stored in a single file, eg. <code>database20201026154808</code>. This is the simplest form of logging as everything is in one place.</p> <p>Note that in this mode, and all other logging modes, a new log file will be created on STP restart, and the stpmeta table updated accordingly. Note also that in all modes the timestamp on the end of the log file (YYYYMMDDHHMMSS) will come from the system clock when the log file is created, and will not be rounded to any particular value.</p> <p><code>stplogs       \u251c\u2500\u2500stp1_2020.11.05/       \u2502  \u251c\u2500\u2500 err20201105000000       \u2502  \u251c\u2500\u2500 stpmeta       \u2502  \u2514\u2500\u2500 stp1_20201105000000       \u2514\u2500\u2500stp1_2020.11.06          \u251c\u2500\u2500 err20201106000000          \u251c\u2500\u2500 stpmeta          \u2514\u2500\u2500 stp1_20201106000000</code></p> <ul> <li>periodic:</li> </ul> <p>In this mode all the updates are stored in a the same file but the logs are rolled according to a custom period, set with <code>.stplg.multilogperiod</code>. For example, if the period is set to an hour a new log file will be created every hour and stored in a daily partitioned directory. As a result, this mode potentially allows for easier management by breaking the log files into smaller sizes, all while maintaining message arrival order during replays. Note that if the memory batch publish mode is used then the order of updates across different tables is no longer guaranteed (the order for a single table is guaranteed).</p> <p><code>stplogs       \u251c\u2500\u2500stp1_2020.11.05/       \u2502  \u251c\u2500\u2500 err20201105000000       \u2502  \u251c\u2500\u2500 periodic20201105000000       \u2502  \u251c\u2500\u2500 periodic20201105010000       \u2502  \u251c\u2500\u2500 periodic20201105020000       \u2502  \u2514\u2500\u2500 stpmeta       \u2514\u2500\u2500stp1_2020.11.06          \u251c\u2500\u2500 err20201106000000          \u251c\u2500\u2500 periodic20201106000000          \u251c\u2500\u2500 periodic20201106010000          \u251c\u2500\u2500 periodic20201106020000          \u2514\u2500\u2500 stpmeta</code></p> <ul> <li>tabular:</li> </ul> <p>This mode is similar to the default behaviour except that each table has its own log file which is rolled daily in the form <code>tradeYYYYMMDDHHMMSS</code>. This allows for more granular log file management, and prioritisation of data recovery.</p> <p><code>stplogs/       \u251c\u2500\u2500 stp1_2020.11.05       \u2502   \u251c\u2500\u2500 err20201105000000       \u2502   \u251c\u2500\u2500 logmsg_20201105000000       \u2502   \u251c\u2500\u2500 packets_20201105000000       \u2502   \u251c\u2500\u2500 quote_20201105000000       \u2502   \u251c\u2500\u2500 quote_iex_20201105000000       \u2502   \u251c\u2500\u2500 stpmeta       \u2502   \u251c\u2500\u2500 trade_20201105000000       \u2502   \u2514\u2500\u2500 trade_iex_20201105000000       \u2514\u2500\u2500 stp1_2020.11.06           \u251c\u2500\u2500 err20201106000000           \u251c\u2500\u2500 logmsg_20201106000000           \u251c\u2500\u2500 packets_20201106000000           \u251c\u2500\u2500 quote_20201106000000           \u251c\u2500\u2500 quote_iex_20201106000000           \u251c\u2500\u2500 stpmeta           \u251c\u2500\u2500 trade_20201106000000           \u2514\u2500\u2500 trade_iex_20201106000000</code></p> <ul> <li>tabperiod:</li> </ul> <p>As the name suggests this mode combines the behaviour of the tabular and periodic logging modes, whereby each table has its own log file, each of which are rolled periodically as defined in the process. This adds the flexibility of both those modes when it comes to replays.</p> <p><code>stplogs/       \u251c\u2500\u2500 stp1_2020.11.05       \u2502   \u251c\u2500\u2500 err20201105000000       \u2502   \u251c\u2500\u2500 err20201105010000       \u2502   \u251c\u2500\u2500 logmsg_20201105000000       \u2502   \u251c\u2500\u2500 logmsg_20201105010000       \u2502   \u251c\u2500\u2500 packets_20201105000000       \u2502   \u251c\u2500\u2500 packets_20201105010000       \u2502   \u251c\u2500\u2500 quote_20201105000000       \u2502   \u251c\u2500\u2500 quote_20201105010000       \u2502   \u251c\u2500\u2500 quote_iex_20201105000000       \u2502   \u251c\u2500\u2500 quote_iex_20201105010000       \u2502   \u251c\u2500\u2500 stpmeta       \u2502   \u251c\u2500\u2500 trade_20201105000000       \u2502   \u251c\u2500\u2500 trade_20201105010000       \u2502   \u251c\u2500\u2500 trade_iex_20201105000000       \u2502   \u2514\u2500\u2500 trade_iex_20201105010000       \u2514\u2500\u2500 stp1_2020.11.06           \u251c\u2500\u2500 err20201106000000           \u251c\u2500\u2500 err20201106010000           \u251c\u2500\u2500 logmsg_20201106000000           \u251c\u2500\u2500 logmsg_20201106010000           \u251c\u2500\u2500 packets_20201106000000           \u251c\u2500\u2500 packets_20201106010000           \u251c\u2500\u2500 quote_20201106000000           \u251c\u2500\u2500 quote_20201106010000           \u251c\u2500\u2500 quote_iex_20201106000000           \u251c\u2500\u2500 quote_iex_20201106010000           \u251c\u2500\u2500 stpmeta           \u251c\u2500\u2500 trade_20201106000000           \u251c\u2500\u2500 trade_20201106010000           \u251c\u2500\u2500 trade_iex_20201106000000           \u2514\u2500\u2500 trade_iex_20201106010000</code></p> <ul> <li>custom</li> </ul> <p>This mode allows the user to have more granular control over how each table is logged. The variable <code>.stplg.customcsv</code> points to a CSV file containing two columns, table and mode, and this allows the user to decide which logging mode to use for each table. An example CSV is below:</p> <p><code>table,mode   trade,periodic   trade_iex,periodic   quote,tabular   quote_iex,tabluar   heartbeat,tabperiod</code></p> <p>Here we have the trade and trade_iex tables both being saved to the same periodic log file, the quote and quote_iex tables both having their own daily log file and the heartbeat table having a periodic log file all to itself. This mode may be advantageous in the case where some tables receive far more updates than others, so they can have more rigorously partitioned logs, and the sparser tables can be pooled together. There is some complexity associated with this mode, as there can be different log files rolling at different times.</p> <p>As part of these new changes it is important to note that if the STP process is restarted, the stp will open new log files in the existing log directory and will not immediately replay the previous log files.</p> <p>Note that each of the new logging modes includes a q object saved in the directory called stpmeta, this is a table that contains information on the stp logs present in the directory. The table stpmeta contains multiple columns including:</p> <ul> <li>seq, the order of the logfiles, for periodic data all files for the same time period have the same seq number</li> <li>logname, pathway to the logfile</li> <li>start, the time and date that the logfile was created</li> <li>end, the time and date that the logfile was closed</li> <li>tbls, the tables present in each logfile</li> <li>msgcount, the count of the messages in each logfile</li> <li>schema, schemas for each of the tables in the tbls column</li> <li>additional, any additional information about the logfile</li> </ul> <p>Note that both end and msgcount are informative and not guaranteed, and the STP doesn't have any dependency on them. If the STP is killed or dies in an unclean manner, then they will not be populated.</p>"},{"location":"Processes/#batching-modes","title":"Batching Modes","text":"<p>There are named modes which are set with the <code>.stplg.batchmode</code> variable and these allow the user to be flexible with process latency and throughput by altering the <code>.u.upd</code> and <code>.z.ts</code> functions:</p> <ul> <li>defaultbatch:</li> </ul> <p>This is effectively the standard TP batching mode where, upon receiving a tick, the STP immediately logs it to disk and batches the update which is published to subscribers whenever the timer function is next called. This mode represents a good balance of latency and overall throughput.</p> <ul> <li>immediate:</li> </ul> <p>In this mode no batching occurs, and the update is logged and published immediately upon entering the STP. This is less efficient in terms of overall throughput but allows for lower latency.</p> <ul> <li>memorybatch:</li> </ul> <p>In this mode, neither logging nor publishing happens immediately but everything is held in memory until the timer function is called, at which point the update is logged and published. High overall message throughput is possible with this mode, but there is a risk that some messages aren't logged in the case of STP failure. Also note that the the ordering of messages from different tables in the log file will not align with arrival order.</p>"},{"location":"Processes/#starting-a-segmented-tickerplant-process","title":"Starting a Segmented Tickerplant process","text":"<p>Starting an STP process is similar to starting a tickerplant, we need to have an updated process.csv that contains a line for the STP process like the one below. Optional flags such as <code>-.stplg.batchmode</code> and <code>-.stplg.errmode</code> can be added to change settings for the process.</p> <pre><code>localhost,${KDBBASEPORT}+103,segmentedtickerplant,stp1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/segmentedtickerplant.q,1,-schemafile ${TORQAPPHOME}/database.q -.stplg.batchmode immediate -.stplg.errmode 0 -t 1,q\n</code></pre> <p>The process can either be started using:</p> <pre><code>bash torq.sh start stp1\n</code></pre> <p>or:</p> <pre><code>q ${TORQHOME}/torq.q -proctype segmentedtickerplant -procname stp1 -load ${KDBCODE}/processes/segmentedtickerplant.q\n</code></pre>"},{"location":"Processes/#subscriptions","title":"Subscriptions","text":"<p>It is easy for a subscriber to subscribe to a STP process. It follows the same process as subscribing to a TP through <code>.u.sub</code> however some changes have been made. Each subscriber connecting to the STP needs to be updated to search for the STP instead of the original tickerplant. This is done using <code>.servers.CONNECTIONS</code> in the settings config file for that process, for example:</p> <pre><code>.servers.CONNECTIONS:enlist `segmentedtickerplant\n</code></pre> <p>The STP requires these functions to be defined in subscriber processes (the definitions will be unique to the requirements of each subscriber): - upd[t;x]   Called for updates from the STP. Arguments are t (the table the data is for), x (the data to be inserted) - endofperiod[currentpd;nextpd;data]   Called at the end of a period for periodic STP modes. Takes 3 arguments currentpd (the current period), nextpd (the next period) and data (a dictionary containing some basic information on the stp process and the current time on the stp) - endofday[date;data]   Called at the end of day for all modes. Takes 2 arguments date (current date) and data (a dictionary containing some basic information on the stp process and the current time on the stp)</p> <p>The data dictionary contains the STP name and type, list of subscribable tables in STP and the time at which the message is sent from the STP. In order to add further information to data, simply add additional elements in the endofdaydata function defined in code/segmentedtickerplant/stplg.q script.</p> <p>For more information on subscriptions, see the documentation on the pubsub.q utility script.</p>"},{"location":"Processes/#error-trapping","title":"Error Trapping","text":"<p>If the <code>.stplg.errmode</code> Boolean variable is set to true, an error log is opened on start up and the <code>.u.upd</code> function is wrapped in an error trap. If an error is thrown by the STP when it receives and update from the feed, then the update is written to the error log. This should allow easier debugging during onboarding of new data feeds. Unless the feed is very unstable, this should not be necessary in production usage as it incurs a small overhead on each update.</p> <p>This mode is really designed for development/testing purposes, it shouldn't be necessary for a stable production feed and will add a small overhead to each update.</p>"},{"location":"Processes/#time-zone-behaviour","title":"Time Zone Behaviour","text":"<p>A key tickerplant function is to timestamp the incoming data before it gets published to the rest of the system. Similar to the existing TP, the STP allows definition of </p> <ul> <li>the timezone that data is timestamped at upon arrival</li> <li>the timezone that the STP executes it's end-of-day roll in </li> <li>the offset from midnight that the STP executes its end-of-day roll in</li> </ul> <p>This allows for more complex configurations, such as an Foreign Exchange data capture system which timestamps data in UTC but rolls at 5 PM EST. </p> <p>The key variable used is <code>.eodtime.dailyadj</code> but more information on setting up a TorQ process in a different time zone can be found here.</p>"},{"location":"Processes/#per-table-customisation","title":"Per Table Customisation","text":"<p>Each table has its own upd function, meaning that some additional processing, such as adding a sequence number or a time-zone offset, can be done in the STP itself rather than needing to be done in a separate process. This is done by altering the <code>.stplg.updtab</code> dictionary in the segmentedtickerplant settings config file. The default behaviour is for every update to automatically have the current timestamp applied to it.</p> <pre><code>// In file $TORQHOME/appconfig/settings/segmentedtickerplant.q\n// Apply a sequence number to 'tabname'\n.stplg.updtab[`tabname]:{((count first x)#'(y;.stplg.seqnum),x}\n\n// In the STP process\nq) .stplg.updtab\nquote   | {(enlist(count first x)#y),x}\ntrade   | {(enlist(count first x)#y),x}\ntabname | {((count first x)#'(y;.stplg.seqnum),x}\n...\n</code></pre>"},{"location":"Processes/#custom-batching-modes","title":"Custom Batching Modes","text":"<p>The batching behaviour depends on two functions: <code>.u.upd</code> and <code>.z.ts</code>. The former is called every time an update arrives in the STP and the latter whenever the timer function is called (e.g. if the process is started with <code>-t 1000</code>, this will be called every second). In the default batching mode, <code>.u.upd</code> inserts the update into a local table and writes it to the log file, and <code>.z.ts</code> publishes the contents of the local table before clearing it. To customise these functions, the <code>.stplg.upd</code> and <code>.stplg.zts</code> dictionaries will need to be customised. For example, the default batching code looks like the following:</p> <pre><code>\\d .stplg\n\n// Standard batch mode - write to disk immediately, publish in batches\nupd[`defaultbatch]:{[t;x;now]\n  t insert x:.stplg.updtab[t] . (x;now);\n  `..loghandles[t] enlist(`upd;t;x);\n  // track tmp counts, and add these after publish\n  @[`.stplg.tmpmsgcount;t;+;1];\n  @[`.stplg.tmprowcount;t;+;count first x];\n };\n\nzts[`defaultbatch]:{\n  // publish and clear all tables, increment counts\n  .stpps.pubclear[.stpps.t];\n  // after data has been published, updated the counts\n  .stplg.msgcount+:.stplg.tmpmsgcount;\n  .stplg.rowcount+:.stplg.tmprowcount;\n  // reset temp counts\n  .stplg.tmpmsgcount:.stplg.tmprowcount:()!();\n };\n\n\\d .\n</code></pre>"},{"location":"Processes/#multiple-updates-from-publishers","title":"Multiple Updates From Publishers","text":"<p>The STP handles single messages which contain multiple updates. The standard interface for publishers is the <code>.u.upd</code> interface supported by the original tickerplant (two arguments, the table to be updated followed by the data). The arguments for this can now but lists, i.e. a list of table names followed by a list of associated data. These updates can all be stamped with the same sequence number, and is useful where upstream publishers receive a single update which is split across downstream tables. Once this is done, simply update <code>.stplg.batchmode</code> with the name of the new mode and start the process.</p>"},{"location":"Processes/#performance-comparison","title":"Performance Comparison","text":"<p>A custom performance stack was set up comprising a feed, a consumer, an STP, a vanilla TP (normal TorQ tickerplant) and a kdb+ tick process along with an observer process which was responsible for coordinating the tests and processing the results. When the tests begin, the feed pushes single row updates to the selected TP process in a loop for one minute before pushing updates in batches of 100 rows for one minute. The observer then collects the results from the consumer which is subscribed to the TP and clears the table before resetting things so that the feed is pointing at either the same process in a different batching mode or a new process. In this way all the process modes are tested, including the immediate and batched modes for the TP and tick processes.</p> <p>These tests were run on a shared host with dual Intel Xeon Gold 6128 CPUs with a total of 12 cores and 24 threads with 128GB of memory. Each tickerplant will only have been using a single core. The results below show the average number of messages per second (mps) received by the subscriber. The results for single updates can be seen below. It should be noted that the message rates achieved will be dependent on hardware configuration. The purpose of the testing below is to demonstrate the relative performance between the different implementations and batching modes.</p> Process Batch Mode Average mps STP Default batch 103k STP Immediate 89k STP Memory batch 174k TorQ TP Immediate 75k TorQ TP Batch 98k Tick Immediate 87k Tick Batch 103k <p>And the following are for batched updates (note that each message contains 100 ticks):</p> Process Batching Mode Average mps STP Default batch 19k STP Immediate 18k STP Memory batch 21k TorQ TP Immediate 18k TorQ TP Batch 18k Tick Immediate 17k Tick Batch 19k <p>The first obvious thing to be noticed is that batching the updates results in greater performance as there are fewer IPC operations and disk writes, and while some insight can be gleaned from these figures the single update results provide a better comparison of the actual process code performance. The memory batching mode is the clear leader in terms of raw performance as it does not write to disk on every update. The three 'default' batching modes are roughly equivalent in terms of performance and all have similar functionality. The three Immediate modes bring up the rear in terms of raw throughput, though the STP version is the performance leader here as it stores table column names in a dictionary which can be easily accessed rather than having to read the columns of a table in the root namespace.</p> <p>In this set up each message contained either one or 100 ticks, each of which had 11 fields, and there was one feed pushing to one TP which had one simple subscriber and varying these figures will impact performance. Here the size of a single tick is 141 bytes and the 100-tick update is 6137 bytes. Increasing the fields in each tick or the number of ticks in a message will results in more costly IPC and IO operations which will decrease performance. Having more subscribers and increasing the complexity of subscriptions, ie. having complex where clause conditions on the subscription, will also reduce performance. These are all things worth bearing in mind as one builds an application.</p> <p>When writing the code for these STP modes some compromise was taken between performance and maintenance. All the UPD functions are written in a standard way and have certain common elements abstracted away in namespaces, which does technically reduce performance. We will see later on how custom modes can be defined which can be more tailored to a given application.</p>"},{"location":"Processes/#chained-stp","title":"Chained STP","text":"<p>A chained tickerplant (CTP) is a TP that is subscribed to another TP. This is useful for the following:</p> <ul> <li>protecting the main TP by offloading publication load. Examples would be distributing data to multiple consumers, or executing complex subscription filtering logic.</li> <li>distributing a system across multiple hosts where data is pushed once across a host boundary and then further distributed within that host. The CTP can also be used to create a local version of the TP log files within that host.</li> </ul> <p>The CTP inherits functionality from the STP- essentially, the code can be run in \"chained\" mode. In this case it subscribes to an STP, and forwards data. Timings (e.g. end-of-day, end-of-period) are driven from the STP. A chained STP can be in a different batching mode from the STP. The main choice is around what type of logging, if any, the CTP is required to do:</p> <ul> <li>none: Chained STP does not create or access any log files.</li> <li>create: Chained STP creates its own log files independent of the STP logs. Subscribers then access the chained STP log files during replays</li> <li>parent: STP logs are passed to subscribers during replays. Chained STP does not create any logs itself </li> </ul> <p>The 'parent' logging mode is useful when all of the Torq processes have access to the same disk. In this case, the subscriber can access the logs of the STP and the data is replayed through the Chained STP. This prevents the SCTP from needing to create duplicate logs and so saves on storage. This replay would look like the following:</p> <p></p> <p>The 'create' logging mode should be used when the chained STP is running on a separate host to the STP, as illustrated in the diagram below. Here RDB1 may access the STP logs as they are running on the same host. However, RDB2 does not have access to the STP logs and so they cannot be replayed through the SCTP. Therefore, the chained STP needs to create its own logs for RDB2 to access.</p> <p></p>"},{"location":"Processes/#backward-compatibility","title":"Backward Compatibility","text":"<p>Not everything about the STP is exactly the same as the TP, a couple of things have been changed:</p> <ul> <li>All updates must be lists of lists, meaning that single updates must be enlisted.</li> <li>Consumers must have endofday[currentdate;DATA], endofperiod[currentperiod;nextperiod;DATA] and upd[newdata;table] defined in order to successfully subscribe to the STP (.u.end is no longer used). Here DATA is a dictionary of metadata about the STP containing the STP name and type, subscribable tables and the time at which the message was sent from the STP.</li> <li>First two columns in tables do not have to be time and sym </li> <li>By default, every update entering the STP will be timestamped as the first column. However, this behaviour can easily be modified by altering the dictionary of updtab functions. To read more on this, visit the Per Table Customisation subsection of the STP documentation in this file.</li> </ul> <p></p>"},{"location":"Processes/#real-time-database-rdb","title":"Real Time Database (RDB)","text":"<p>The Real Time Database is a modified version of r.q found in kdb+tick. The modifications from the standard r.q include:</p> <ul> <li> <p>Tickerplant (data source) and HDB location derived from processes     defined by the discovery service or from config file;</p> </li> <li> <p>Automatic re-connection and resubscription to tickerplant;</p> </li> <li> <p>List of tables to subscribe to supplied as configuration setting;</p> </li> <li> <p>More pre-built flexibility in end-of-day;</p> </li> <li> <p>More verbose end-of-day logging;</p> </li> <li> <p>Reload multiple authenticated HDBs after end-of-day;</p> </li> <li> <p>End-of-day save down manipulation code is shared between RDB, WDB       and tickerplant log replay</p> </li> </ul> <p>See the top of the file for more information.</p> <p></p>"},{"location":"Processes/#write-database-wdb","title":"Write Database (WDB)","text":"<p>The Write Database or WDB is based on w.q. This process features a number of modifications and enhancements over w.q:</p> <ol> <li> <p>Provides the option to write down to a custom partition scheme,     defined by parted columns in sort.csv, which removes the need for     end of day sorting;</p> </li> <li> <p>Greater configuration options; max rows on a per table basis, list      subscription tables, upd function etc. See the top of the process      file for the options;</p> </li> <li> <p>Use of common code with the RDB and Tickerplant Log Replay process      to manipulate tables before save, sort and apply attributes;</p> </li> <li> <p>Checks whether to persist data to disk on a timer rather than on      each tick;</p> </li> <li> <p>Informs other RDB, HDB and GW processes that end of day save and      sort has completed;</p> </li> <li> <p>More log information supplied;</p> </li> <li> <p>End of day timezone can be configured (see eodtime.q).</p> </li> </ol> <p>The WDB process can broken down into two main functions:</p> <ol> <li> <p>Periodically saving data to disk and</p> </li> <li> <p>Sorting data at end of day</p> </li> </ol> <p>The WDB process provides flexibility so it can be set-up as a stand-alone process that will both save and sort data or two separate processes (one that saves the data and another that will sort the data on disk). This allows greater flexibility around the end of day event as sorting data can be time consuming. It is also helps when implementing seemless rollovers (i.e. no outage window at end-of-day).</p> <p>The behaviour of the WDB process is controlled by the <code>.wdb.mode</code> parameter. This should be set to one of following three values:</p> <ul> <li> <p>saveandsort - the process will subscribe for data, periodically     write data to disk and at EOD it will flush remaining data to disk     before sorting it and informing GWs, RDBs and HDBs etc.</p> </li> <li> <p>save - the process will subscribe for data, periodically write data       to disk and at EOD it will flush remaining data to disk. It will       then inform its respective sort mode process to sort the data</p> </li> <li> <p>sort - the process will wait to get a trigger from its respective       save mode process. When this is triggered it will sort the data on       disk, apply attributes and the trigger a reload on the RDB, HDB and       GW processes</p> </li> </ul> <p>When running a system with separate save and sort process, the sort process should be configured in the processes.csv file with a proctype of sort. The save process will check for processes with a proctype of sort when it attempts to trigger the end of day sort of the data.</p> <p>The wdb process provides three methods for persisting data to disk and sorting at the end of the day.</p> <ul> <li> <p>default - Data is persisted into a partition defined by the     [partitiontype] variable, similar to the hdb partition scheme. The     general scheme is of the form     [wdbdir]/[partitiontype]/[table]/. And a typical partition     directory would be similar to wdb/database/2015.11.26/trades/. At     the end of the day, before being moved to the hdb, the data is     sorted according to parameters defined in sort.csv. For each table,     sort.csv will specify the columns to sort (using xasc) and apply     attributes to.</p> </li> <li> <p>partbyattr - Data is persisted to a custom partition scheme, derived       from parameters in the sort.csv file. The write down scheme is taken       from sort.csv, to reflect the effect of using xasc at the end of       day. For each table, the columns defined in sort.csv, with the       parted attribute, are used to create custom partitions in the wdb.       Multiple columns can be defined with the parted attribute and       distinct combinations of each are generated for custom partitions.       The general partition scheme is of the form       [wdbdir]/[partitiontype]/[table]/[parted column(s)]/. And a       typical partition directory would be similar to       wdb/database/2015.11.26/trade/MSFT_N. In the above example, the       data is parted by sym and source, and so a unique partition       directory MSFT_N is created in the wdb directory.</p> <p>At the end of the day, data is upserted into the hdb without the   need for sorting. The number of rows that are joined at once is   limited by the mergenumrows and mergenumtab parameters.</p> </li> <li> <p>partbyenum - Data is persisted to a partition scheme where the partition       is derived from parameters in the sort.csv file. In this mode partition       only can be done by one column which has parted attribute applied on it       and it also has to be of a symbol type. The partitioning on disk will       be the enumerated symbol entries of the parted symbol column. The       enumeration is done against the HDB sym file.       The general partition scheme is of the form       [wdbdir]/[partitiontype]/[parted enumerated symbol column]/[table(s)]/.       A typical partition directory would be similar to(for ex sym: MSFT_N)       wdb/database/2015.11.26/456/trade/       In the above example, the data is parted by sym, and number 456 is       the order of MSFT_N symbol entry in the HDB sym file.</p> <p>The advantage of partbyenum over partbyattr could be that the   directory structure it uses represents a HDB that is ready to be loaded   intraday. At the end of the day the data gets upserted to the HDB the   same way it would be when using partbyattr.</p> </li> </ul> <p>The optional partbyattr/partbyenum methods may provide a significant saving in time at the end of day, allowing the hdb to be accessed sooner. For large data sets with a low cardinality (ie. small number of distinct elements) the optional method may provide a significant time saving, upwards of 50%. The optional method should also reduce the memory usage at the end of day event, as joining data is generally less memory intensive than sorting.</p> <p></p>"},{"location":"Processes/#intraday-database-idb","title":"Intraday Database (IDB)","text":"<p>The Intraday Database or IDB is a simple process that allows access to data written down intraday. This assumes that there is an existing WDB process creating a DB on disk that can be loaded with a simple load command. As of now default and partbyenum WDB writedown modes are supported. The responsibility of an IDB is therefore:</p> <ol> <li> <p>Serving queries. Since partbyenum writedown mode is done by enumerated     symbol columns a helper function maptoint is implemented to support     symbol lookup in sym file:     select from trade where int=maptoint[`MSFT_N]</p> </li> <li> <p>Can be triggered for a reload. This is usually done by the WDB process     periodically.</p> </li> </ol> <p></p> <p></p>"},{"location":"Processes/#tickerplant-log-replay","title":"Tickerplant Log Replay","text":"<p>The Tickerplant Log Replay script is for replaying tickerplant logs. This is useful for:</p> <ol> <li> <p>handling end of day save down failures;</p> </li> <li> <p>handling large volumes of data (larger than can fit into RAM).</p> </li> </ol> <p>The process takes as the main input either an individual log file to replay, or a directory containing a set of log files. Amongst other functionality, the process can:</p> <ul> <li> <p>replay specific message ranges;</p> </li> <li> <p>replay in manageable message chunks;</p> </li> <li> <p>recover as many messages as possible from a log file rather than       just stopping at the first bad message;</p> </li> <li> <p>ignore specific tables;</p> </li> <li> <p>modify the tables before or after they are saved;</p> </li> <li> <p>apply sorting and parting after all the data is written out.</p> </li> </ul> <p>The process must have some variables set (the tickerplant log file or directory, the schema file, and the on-disk database directory to write to) or it will fail on startup. These can either be set in the config file, or overridden from the command line in the usual way. An example start line would be:</p> <pre><code>q torq.q -debug -load code/processes/tickerlogreplay.q -p 9990 -.replay.tplogfile ../test/tplogs/marketdata2013.12.17 -.replay.schemafile ../test/marketdata.q -.replay.hdbdir ../test/hdb1 -proctype tickerlogreplay -procname tplogreplay1\n</code></pre> <p>In order to replay log files from a segmented tickerplant, the directory containing those log files can be passed in and the variable <code>.replay.segmentedmode</code> must be true. It should be noted that a directory must be passed in and the directory must contain the STP meta table for that day. Only one log directory can be replayed at a time.</p> <p>The tickerplant log replay script has extended usage information which can be accessed with -.replay.usage.</p> <pre><code>q torq.q -debug -load code/processes/tickerlogreplay.q -p 9990 -.replay.usage -proctype tickerlogreplay -procname tplogreplay1\n</code></pre> <p></p>"},{"location":"Processes/#housekeeping","title":"Housekeeping","text":"<p>The housekeeping process is used to undertake periodic system housekeeping and maintenance, such as compressing or removing files which are no longer required. The process will run the housekeeping jobs periodically on a timer. Amongst other functionality the process:</p> <ul> <li> <p>Allows for removing and zipping of directory files;</p> </li> <li> <p>Provides an inbuilt search utility and selectively searches using a       \u2018find\u2019 and \u2018exclude\u2019 string, and an \u2018older than\u2019 parameter;</p> </li> <li> <p>Reads all tasks from a single CSV;</p> </li> <li> <p>Runs on a user defined timer;</p> </li> <li> <p>Can be run immediately from command line or within the process;</p> </li> <li> <p>Can be easily extended to include new user defined housekeeping       tasks.</p> </li> </ul> <p>The process has two main parameters that should be set prior to use; runtimes and inputcsv.\u2018Runtimes\u2019 sets the timer to run housekeeping at the set time(s), and \u2018Inputcsv\u2019 provides the location of the housekeeping csv file. These can either be set in the config file, or overridden via the command line. If these are not set, then default parameters are used; 12.00 and \u2018KDBCONFIG/housekeeping.csv\u2019 respectively. The process is designed to run from a single csv file with seven headings:</p> <ul> <li> <p>Function details the action that you wish to be carried out on the       files or directories. Initially, this can be rm (remove) and zip        (zipping) for files, and tardir (zipping) for directories;</p> </li> <li> <p>Path specifies the directory that the files/directories are in;</p> </li> <li> <p>Match provides the search string to the find function, files/directories       returned will have names that match this string;</p> </li> <li> <p>Exclude provides a second string to the find function, and these       files/directories are excluded from the match list;</p> </li> <li> <p>Age is the \u2018older than\u2019 parameter, and the function will only be       carried out on files/directories older than the age given (in days);</p> </li> <li> <p>Agemin switches the age measurement from days to minutes;</p> </li> <li> <p>Checkfordirectory specifies whether to search for directories,        instead of files.</p> </li> </ul> <p>An example csv file would be:</p> <pre><code>function,path,match,exclude,age,agemin,checkfordirectory\nzip,./logs/,*.log,*tick*,2,,\nrm,./logs/,*.log*,*tick*,4,,\nzip,./logs/,*tick*,,1,,\nrm,./logs/,*tick*,,3,,\ntardir,./stplogs/,database*,,1,,1\n\nfunction path         match       exclude  age agemin checkfordirectory\n-----------------------------------------------------------------------\nzip      \"./logs/\"    \"*.log\"     \"*tick*\" 2   0      0\nrm       \"./logs/\"    \"*.log*\"    \"*tick*\" 4   0      0\nzip      \"./logs/\"    \"*tick*\"    \"\"       1   0      0\nrm       \"./logs/\"    \"*tick*\"    \"\"       3   0      0\ntardir   \"./stplogs/\" \"database*\" \"\"       1   0      1\n</code></pre> <p>The process reads in the csv file, and passes it line by line to a \u2018find\u2019 function; providing a dictionary of values that can be used to locate the files/directories required. The find function takes advantage of system commands to search for matches according to the specifications in the dictionary. A search is performed for both the match string and the exclude string, and cross referenced to produce a list of files/directories that match the parameters given. The matches are then each passed to a further set of system commands to perform the task of either zipping or removing. Note that an incomplete csv or non-existant path will throw an error.</p> <p>The remove and zipping functions form only basic implementations of the housekeeping process; it is designed to be exended to include more actions than those provided. Any user function defined in the housekeeping code can be employed in the same fashion by providing the name of the function,search string and age of files to the csv.</p> <p>As well as being scheduled on a timer, the process can also be run immediately. Adding \u2018-hk.runnow 1\u2019 to the command line when starting the process will force immediate running of the actions in the housekeeping csv. Likewise, setting runnow to 1b in the config file will immediately run the cleaning process. Both methods will cause the process to exit upon completion. Calling hkrun[] from within the q process will also run the csv instructions immediately. This will not affect any timer scheduling and the process will remain open upon completion.</p> <p>Housekeeping works both on windows and unix based systems. Since the process utilizes inbuilt system commands to perform maintenances, a unix/windows switch detects the operating system of the host and applies either unix or widows functions appropriately. Extensions need only be made in the namespace of the hosting operating system (i.e. if you are using a unix system, and wish to add a new function, you do not need to add the function to the windows namespace to). Usage information can be accessed using the \u2018-hkusage\u2019 flag:</p> <pre><code>q torq.q -load code/processes/housekeeping.q -p 9999 -proctype housekeeping -procname hk1 -debug -hkusage\n</code></pre> <p></p>"},{"location":"Processes/#file-alerter","title":"File Alerter","text":"<p>The file alerter process is a long-running process which periodically scans a set of directories for user-specified files. If a matching file is found it will then carry out a user-defined function on it. The files to search for and the functions to run are read in from a csv file. Additionally, the file alerter process can:</p> <ul> <li> <p>run more than one function on the specified file.</p> </li> <li> <p>optionally move the file to a new directory after running the       function.</p> </li> <li> <p>store a table of files that have already been processed.</p> </li> <li> <p>run the function only on new files or run it every time the file is       modified.</p> </li> <li> <p>ignore any matching files already on the system when the process       starts and only run a function if a new file is added or a file is       modified.</p> </li> </ul> <p>The file alerter process has four parameters which should be set prior to use. These parameters can either be set in the config file or overridden on the command-line. If they are not set, the default parameters will be used. The parameters are as follows.</p> <p>inputcsv - The name and location of the csv file which defines the behaviour of the process. The default is KDBCONFIG/filealerter.csv.</p> <p>polltime - How often the process will scan for matching files. The default is 0D:00:01, i.e., every minute.</p> <p>alreadyprocessed - The name and location of the already-processed table. The default is KDBCONFIG/filealerterprocessed. This table will be created automatically the first time the process is ran.</p> <p>skipallonstart - If this is set to 1, it will ignore all files already on the system; if it is set to 0, it will not. The default value is 0.</p> <p>The files to find and the functions to run are read in from a csv file created by the user. This file has five columns, which are detailed below.</p> <p>path - This is the path to the directory that will be scanned for the file.</p> <p>match - This is a search string matching the name of the file to be found. Wildcards can be used in this search, for example, \u201cfile*\u201d will find all files starting with \u201cfil\u201d.</p> <p>function - This is the name of the function to be run on the file. This function must be defined in the script KDBCODE/processes/filealerter.q. If the function is not defined or fails to run, the process will throw an error and ignore that file from then on.</p> <p>newonly - This is a boolean value. If it is set to 1, it will only run the function on the file if it has been newly created. If it is set to 0, then it will run the function every time the file is modified.</p> <p>movetodirectory - This is the path of the directory you would like to move the file to after it has been processed. If this value is left blank, the file will not be moved.</p> <p>It is possible to run two separate functions on the same file by adding them as separate lines in the csv file. If the file is to be moved after it is processed, the file alerter will run both functions on the file and then attempt to move it. A typical csv file to configure the file alerter would look like:</p> <pre><code>path,match,function,newonly,movetodirectory\n/path/to/dirA,fileA.*,copy,0,/path/to/newDir\n/path/to/dirB,fileB.txt,email,1,\n/path/to/dirA,fileA.*,delete,0,/path/to/newDir\n\npath        match      function  newonly    movetodirectory\n---------------------------------------------------\n\"/path/to/dirA\" \"fileA.*\"   copy    0   \"/path/to/newDir\"\n\"/path/to/dirB\" \"fileB.txt\" email   1   \"\"\n\"/path/to/dirA\" \"fileA.*\"   delete  0   \"/path/to/newDir\"\n</code></pre> <p>The file alerter process reads in each line of the csv file and searches files matching the search string specified in that line. Note that there may be more than one file found if a wildcard is used in the search string. If it finds any files, it will check that they are not in the already processed table. If newonly is set to 1, it only checks if the filename is already in the table. If newonly is set to 0, it checks against the filename, filesize and a md5 hash of the file. The md5 hash and the filesize are used to determine if the file has been modified since it was processed last. If the found files have not been processed already, it then attempts to run the specified function to these files.</p> <p>After the process has run through each line of the csv, it generates a table of all files that were processed on that run. These files are appended to the already processed table which is then saved to disk. The file alerter will attempt to move the files to the \u2018movetodirectory\u2019, if specified. If the file has already been moved during the process (for example, if the function to run on it was \u2018delete\u2019), the file alerter will not attempt to move it.</p> <p>The file alerter is designed to be extended by the user. Customised functions should be defined within the filealerter.q script. They should be diadic functions, i.e., they take two parameters: the path and the filename. As an example, a simple function to make a copy of a file in another directory could be:</p> <pre><code>copy:{[path;file] system \"cp \", path,\"/\", file, \" /path/to/newDir\"}\n</code></pre> <p>Although the process is designed to run at regular intervals throughout the day, it can be called manually by invoking the FArun[] command from within the q session. Similarly, if new lines are added to the csv file, then it can be re-loaded by calling the loadcsv[] command from the q session.</p> <p>Each stage of the process, along with any errors which may occur, are appropriately logged in the usual manner.</p> <p>The file alerter process is designed to work on both Windows and Unix based systems. Since many of the functions defined will use inbuilt system command they will be need to written to suit the operating system in use. It should also be noted that Windows does not have an inbuilt md5 hashing function so the file alerter will only detect different versions of files if the filename or filesize changes.</p> <p></p>"},{"location":"Processes/#reporter","title":"Reporter","text":""},{"location":"Processes/#overview_1","title":"Overview","text":"<p>The reporter process is used to run periodic reports on specific processes. A report is the result of a query that is run on a process at a specific time. The result of the query is then handled by one of the inbuilt result handlers, with the ability to add custom result handlers.</p> <p></p> <p>Features:</p> <ul> <li> <p>Easily create a report for information that you want;</p> </li> <li> <p>Fully customizable scheduling such as start time, end time and days       of the week;</p> </li> <li> <p>Run reports repeatedly with a custom period between them;</p> </li> <li> <p>Asynchronous querying with custom timeout intervals;</p> </li> <li> <p>Inbuilt result handlers allow reports to be written to file or       published;</p> </li> <li> <p>Custom result handlers can be defined;</p> </li> <li> <p>Logs each step of the report process;</p> </li> <li> <p>Fully integrated with the TorQ gateway to allow reports to be run       across backend processes.</p> </li> </ul> <p>The reporter process has three parameters that are read in on initialisation from the reporter.q file found in the $KDBCONFIG/settings directory. These settings are the string filepath of the input csv file, a boolean to output log messages and timestamp for flushing the query log table.</p> <p>To run the reporter process:</p> <pre><code>q torq.q -load code/processes/reporter.q -p 20004 -proctype reporter -procname reporter1\n</code></pre> <p>Once the reporter process has been initiated, the reports will be scheduled and no further input is required from the user.</p>"},{"location":"Processes/#report-configuration","title":"Report Configuration","text":"<p>By default, the process takes its inputs from a file called reporter.csv which is found in the $KDBCONFIG directory. This allows the user complete control over the configuration of the reports. As the queries are evaluated on the target process, local variables can be referenced or foreign functions can be run. Table [table:reportertable] shows the meaning of the csv schema.</p> Column Header Description and Example name Report name e.g. Usage query Query to be evaluated on that process. It can be a string query or function resulthandler Result handlers are run on the returned result. Custom result handlers can be added. The result handler must be a monadic function with the result data being passed in e.g. writetofile[\u201c./output\u201d;\u201cusage\u201d] gateway If non null the reporter will query processes route the query to the proctype specified in this field. The values in the proctype field will be the process types on which the gateway runs the backend query. e.g. `gateway joinfunction Used to join the results when a gateway query is being used. The choice of joinfunction must take into account the result that will be received. The function must be monadic and the parameter will be the list of results returned from the backend processes e.g. raze proctype The type of process that the report will be run on. If the gateway field is not empty this may be a list of process types, otherwise the reporter will throw an error on startup. e.g. `rdb procname The name of a specific process to run the report on. If left null, the reporter process will select a random process with the specified proctype. If the gateway field is not null, this field specifies the specific gateway process name to run the query against e.g. `hdb1 start Time on that day to start at e.g. 12:00 end Time on that day that the report will stop at e.g. 23:00 period The period between each report query e.g. 00:00:10 timeoutinterval The amount of time the reporter waits before timing out a report e.g. 00:00:30 daysofweek Numeric value required for the day of the week. Where 0 is Saturday and 2 is Monday <p>When running a report on a gateway, the gateway field must be set to the proctype of the gateway that will be queried. It will then run the report on the processes which are listed in the proctype field and join the results by using the function specified in the joinfunction field. If there is no join function then the reporter process will not start. Multiple entries in the proctype field must be separated by a space and are only allowed when the gateway field is not empty. If gateway field is empty and there are multiple entries in the proctype field then the reporter process will not load.</p> <p>Listing [code:csvschema] shows an example of the schema needed in the input csv file.</p> <pre><code>name|query|resulthandler|gateway|joinfunction|proctype|procname|start|end|period|timeoutinterval|daysofweek\nusage|10#.usage.usage|writetofiletype[\"./output/\";\"usage\";\"csv\"]|||rdb||00:01|23:50|00:01|00:00:01|0 1 2 3 4 5 6\nmemory|.Q.w[]|writetofile[\"./output/\";\"memory.csv\"]|||rdb|rdb1|00:05|18:00|00:01|00:00:08|0 1 2 3 4 5 6\nusage_gateway|10#.usage.usage||gateway|raze|rdb hdb||00:02|22:00|00:01|00:00:10|0 1 2 3 4 5 6\n</code></pre>"},{"location":"Processes/#result-handlers","title":"Result Handlers","text":"<p>There are several default result handlers which are listed below. Custom result handlers can be defined as required. The result handler will be invoked with a single parameter (the result of the query).</p> <p>writetofiletype - Accepts 3 parameters: path, filename, filetype and data. When writing to file it uses a date time suffix so the resultant filename will be <code>usage_rdb_2014_01_02_15_00_12.txt</code> e.g.</p> <pre><code>writetofiletype[\"./output/\";\"usage\";\"csv\"]\n</code></pre> <p>splaytable - This accepts 3 parameters: path, file and data. This splays the result to a directory. The result must be a table in order to use this function e.g.</p> <pre><code>splaytable[\"./output/\";\"usage\"]\n</code></pre> <p>emailalert - This accepts 3 parameters: period, recipient list and data. The period dictates the throttle i.e. emails will be sent at most every period. The result of the report must be a table with a single column called messages which contains the character list of the email message. This is used with the monitoring checks to raise alerts, but can be used with other functions.</p> <pre><code>emailalert[0D00:30;(\"test@aquaq.co.uk\";\"test1@aquaq.co.uk\")]\n</code></pre> <p>emailreport - This accepts 3 parameters: temporary path, recipient list, file name, file type and data. The data is written out as the file type (e.g. csv, xml, txt, xls, json) with the given file name to the temporary path. It is then emailed to the recipient list, and the temporary file removed.</p> <pre><code>emailreport[\"./tempdir/\"; (\"test@aquaq.co.uk\";\"test1@aquaq.co.uk\"); \"EndOfDayReport\"; \"csv\"]\n</code></pre> <p>publishresult - Accepts 1 parameter and that is the data. This is discussed later in the subsection\u00a0subresults. Custom result handlers can be added to $KDBCODE/processes/reporter.q . It is important to note that the result handler is referencing local functions as it is executed in the reporter process and not the target process. When the query has been successful the result handler will be passed a dictionary with the following keys: queryid, time, name, procname, proctype and result.</p>"},{"location":"Processes/#report-process-tracking","title":"Report Process Tracking","text":"<p>Each step of the query is logged by the reporter process. Each query is given a unique id and regular system messages are given the id 0. The stage column specifies what stage the query is in and these are shown in table [table:stagetable]. An appropriate log message is also shown so any problems can easily be diagnosed. The in memory table is flushed every interval depending on the value of the flushqueryloginterval variable in the reporter.q file found in the $KDBCONFIG/settings directory. </p> Stage symbol Explanation R The query is currently running E An error has occurred during the query C The query has been completed with no errors T The query has exceeded the timeout interval S System message e.g. \u201cReporter Process Initialised\u201d <pre><code>time                         | queryid stage message\n-----------------------------| ------------------------------------------------------------------------\n2014.10.20D22:20:06.597035000| 37 R \"Received result\"\n2014.10.20D22:20:06.600692000| 37 R \"Running resulthandler\"\n2014.10.20D22:20:06.604455000| 37 C \"Finished report\"\n2014.10.20D22:30:00.984572000| 38 R \"Running report: rdbtablecount against proctype: rdb on handle: 7i\"\n2014.10.20D22:30:00.991862000| 38 R \"Received result\"\n2014.10.20D22:30:00.995527000| 38 R \"Running resulthandler\"\n2014.10.20D22:30:00.999236000| 38 C \"Finished report\"\n2014.10.20D22:30:06.784419000| 39 R \"Running report: rdbtablecount against proctype: rdb on handle: 7i\"\n2014.10.20D22:30:06.796431000| 39 R \"Received result\"\n</code></pre>"},{"location":"Processes/#subscribing-for-results","title":"Subscribing for Results","text":"<p>To publish the results of the report, the reporter process uses the pub sub functionality of TorQ. This is done by using the using the inbuilt result handler called publishresult. In order to subscribe to this feed, connect to the reporter process and send the function shown below over the handle. To subscribe to all reports use a backtick as the second parameter and to subscribe to a specific reports results include the reporter name as a symbol.</p> <pre><code>/- define a upd function\nupd:insert\n\n/- handle to reporter process\nh: hopen 20004\n\n/- Subscribe to all results that use the publishresult handler\nh(`.ps.subscribe;`reporterprocessresults;`)\n\n/- Subscribe to a specific report called testreport\nh(`.ps.subscribe;`reporterprocessresults;`testreport)\n</code></pre>"},{"location":"Processes/#example-reports","title":"Example reports","text":"<p>The following are examples of reports that could be used in the reporter process. The rdbtablecount report will run hourly and return the count of all the tables in a rdb process. The memoryusage report will run every 10 minutes against the gateway for multiple processes and will return the <code>.Q.w[]</code> information. Both of these reports run between 9:30am to 4:00pm during the weekdays. The report onetimequery is an example of a query that is run one time, in order to run a query once, the period must be the same as the difference between the start and end time.</p> <pre><code>name|query|resulthandler|gateway|joinfunction|proctype|procname|start|end|period|timeoutinterval|daysofweek\nrdbtablecount|ts!count each value each ts:tables[]|{show x`result}|||rdb|rdb1|09:30|16:00|01:00|00:00:10|2 3 4 5 6\nmemoryusage|.Q.w[]|writetofile[\"./output/\";\"memory.csv\"]|gateway1|{enlist raze x}|rdb hdb||09:30|16:00|00:10|00:00:10|2 3 4 5 6\nonetimequery|10#.usage.usage|writetofile[\"./output/\";\"onetime.csv\"]|||rdb||10:00|10:01|00:01|00:00:10|2 3 4 5 6\n</code></pre> <p></p>"},{"location":"Processes/#monitor","title":"Monitor","text":"<p>The Monitor process is a simple process to monitor the health of the other processes in the system. It connects to each process that it finds (by default using the discovery service, though can use the static file as well) and subscribes to both heartbeats and log messages. It maintains a keyed table of heartbeats, and a table of all log messages received.</p> <p>Run it with:</p> <pre><code>aquaq $ q torq.q -load code/processes/monitor.q -p 20001 -proctype monitor -procname monitor1\n</code></pre> <p>It is probably advisable to run the monitor process with the -trap flag, as there may be some start up errors if the processes it is connecting to do not have the necessary heartbeating or publish/subscribe code loaded.</p> <pre><code>aquaq $ q torq.q -load code/processes/monitor.q -p 20001 -trap -proctype monitor -procname monitor1\n</code></pre> <p>The current heartbeat statuses are tracked in .hb.hb, and the log messages in logmsg</p> <pre><code>q)show .hb.hb                                                                                                                                                                                                                                                                 \nsym       procname    | time                          counter warning error\n----------------------| ---------------------------------------------------\ndiscovery discovery2  | 2014.01.07D13:24:31.848257000 893     0       0    \nhdb       hdb1        | 2014.01.07D13:24:31.866459000 955     0       0    \nrdb       rdb_europe_1| 2014.01.07D13:23:31.507203000 901     1       0    \nrdb       rdb1        | 2014.01.07D13:24:31.848259000 34      0       0\n\nq)show select from logmsg where loglevel=`ERR                                                                                                              \ntime                          sym  host  loglevel id      message                               \n-------------------------------------------------------------------------------------\n2014.01.07D12:25:17.457535000 hdb1 aquaq ERR      reload  \"failed to reload database\"           \n2014.01.07D13:29:28.784333000 rdb1 aquaq ERR      eodsave \"failed to save tables : trade, quote\"\n</code></pre>"},{"location":"Processes/#checkmonitor","title":"Checkmonitor","text":"<p>The <code>checkmonitor.q</code> script extends the functionality of the monitor process. The script takes a set of user defined configuration settings for a set of process  specific checks. These can initially be provided in the form of a CSV,  a sample of which is shown here:</p> <pre><code>family|metric|process|query|resultchecker|params|period|runtime\ndatacount|tradecount|rdb1|{count trade}|checkcount|`varname`count`cond!(`trade;10;`morethan)|0D00:01|0D00:00:01\n</code></pre> <p>Upon start up, the CSV file is loaded and inserted into the in-memory table,  <code>checkconfig</code>. During this insertion, each check will also be assigned  a unique checkid number. </p> <pre><code>q)checkconfig\ncheckid| family    metric     process query           resultchecker params                                    period               runtime              active\n-------| -----------------------------------------------------------------------------------------------------------------------------------------------------\n1      | datacount tradecount rdb1    \"{count trade}\" \"checkcount\"  `varname`count`cond!(`trade;10;`morethan) 0D00:01:00.000000000 0D00:00:01.000000000 1\n</code></pre> <p>For each check, the query will be sent via asynchronous requests to the  specified processes and waits for postback of the results. Once the monitoring  process receives the result of the query, it will then be checked by the resultchecker  function to identify whether it will pass or fail. </p> <p>Result checker functions must only take two parameters: p- a parameter dictionary,  and r- the result row. The status in r will be modified based on whether the r result value passes the conditions specified by the resultchecker function. </p> <pre><code>q)checkcount\n{[p;r]\nif[`morethan=p`cond;\n  if[p[`count]&lt;r`result; :`status`result!(1h;\"\")];\n   :`status`result!(0h;\"variable \",(string p`varname),\" has count of \",(string r`result),\" but requires \",string p`count)];\nif[`lessthan=p`cond;\n  if[p[`count]&gt;r`result; :`status`result!(1h;\"\")];\n  :`status`result!(0h;\"variable \",(string p`varname),\" has count of \",(string r`result),\" but should be less than \",string p`count)];\n}\n\n\nq)p\nvarname| `trade\ncount  | 10\ncond   | `morethan\n\nq)r\nstatus| 1h\nresult| \"\"\n</code></pre> <p>This example checks whether the trade table within the rdb is larger than 10. As this is true, the status has been set to 1h and no error message has been returned. This information is inserted into the <code>checkstatus</code> table,  which is the primary table where all results are stored. </p> <pre><code>q)checkstatus\ncheckid| family    metric     process lastrun                       nextrun                       status executiontime        totaltime            timerstatus running result\n-------| --------------------------------------------------------------------------------------------------------------------------------------------------------------------\n1      | datacount tradecount rdb1    2019.02.18D10:58:45.908919000 2019.02.18D10:59:45.911635000 1      0D00:00:00.000017000 0D00:00:00.002677000 1           0       \"\"\n</code></pre> <p>In addition to tracking the status of the specified queries, a number of metrics  are also returned in the <code>checkstatus</code> table. </p> Column Header Value Type Description lastrun Timestamp Last time check was run nextrun Timestamp Next time check is scheduled to run status Boolean Indicates whether query result has passed resultchecker function executiontime Timespan Time taken for last query to be executed totaltime Timespan Total time taken for check to be run, including sending times and execution timerstatus Boolean Indicates whether last totaltime was executed under threshold value running Boolean Indicates whether check is currently running results String Will display any errors or additional information regarding running checks <p>The function checkruntime uses the running column to identify functions  that are running extremely slow, and set their status and timerstatus to 0h. </p> <p>When the process is exited, the .z.exit has been modified to save the checkconfig table as a flat binary file. This will then be preferentially loaded next time the process is started up again. The process of saving down the in-memory functions makes altering configuration parameters easier.  Four functions are available to do so: <code>addcheck</code>, <code>updateconfig</code>, <code>updateconfigfammet</code> and <code>forceconfig</code>. </p> Function Name Description <code>addcheck[dictionary]</code> addcheck allows a new check to be added, and accepts a dictionary as its argument. The keys must be a match to the current checkconfig table, and the values must be of the correct type. <code>updateconfig[checkid;paramkey;newval]</code> updateconfig changes the parameter key of an existing check, using the checkid to specify which check to alter. The type of the new parameter value must match the current value type. <code>forceconfig[checkid;newconfig]</code> forceconfig changes the parameter keys of an existing check and will not check for types. <code>updateconfigfammet[family;metric;paramkey;newval]</code> updateconfig changes the parameter key of an existing check, using the family and metric combination to specify which check to alter. If this combination does not exist, the function will return an error. The type of the new parameter value must match the current value type. <p>There are other additional functions that are useful for using the check monitor. </p> Function Name Value Type <code>currentstatus</code> Will return only status, timerstatus, result and running from the checktracker table. It accepts a list of checkids, or will return all checks if passed a null. <code>timecheck</code> Will check the median time for current checks to be run against a user-defined timespan. It returns a table displaying the median time and a boolean value. <code>statusbyfam</code> Function will return a table of all checks from specified families, ordered firstly by status, and then by timestatus. If a null is provided, ordered checks from all families will be returned. <p>All checks can be tracked using the table <code>checktracker</code>. Here, each run is assigned a  unique runid- thus individual runs for each check can be tracked. For each run, it tracks the time tkane for target process to recieve the query, as well as  the execution time. The result value will also be displayed.</p>"},{"location":"Processes/#html5-front-end","title":"HTML5 front end","text":"<p>A HTML5 front end has been built to display important process information that is sent from the monitor process. It uses HTML5, WebSockets and JavaScript on the front end and interacts with the monitor process in the kdb+ side. The features of the front end include:</p> <ul> <li> <p>Heartbeat table with processes that have warnings highlighted in     orange and errors in red</p> </li> <li> <p>Log message table displaying the last 30 errors</p> </li> <li> <p>Log message error chart that is by default displayed in 5 minute       bins</p> </li> <li> <p>Chart\u2019s bin value can be changed on the fly</p> </li> <li> <p>Responsive design so works on all main devices i.e. phones, tablets       and desktop</p> </li> </ul> <p>It is accessible by going to the url <code>http://HOST:PORT/.non?monitorui</code></p> <p></p> <p></p>"},{"location":"Processes/#compression","title":"Compression","text":"<p>The compression process is a thin wrapper around the compression utility library. It allows periodic compression of whole or parts of databases (e.g. data is written out uncompressed and then compressed after a certain period of time). It uses four variables defined in KDBCONFIG/settings/compression.q which specify</p> <ul> <li> <p>the compression configuration file to use</p> </li> <li> <p>the database directory to compress</p> </li> <li> <p>the maximum age of data to attempt to compress</p> </li> <li> <p>whether the process should exit upon completion</p> </li> </ul> <p>The process is run like other TorQ processes:</p> <pre><code>q torq.q -load code/processes/compression.q -p 20005 -proctype compression -procname compression1\n</code></pre> <p>Modify the settings file or override variables from the command line as appropriate.</p> <p></p>"},{"location":"Processes/#kill","title":"Kill","text":"<p>The kill process is used to connect to and terminate currently running processes. It kills the process by sending the exit command therefore the kill process must have appropriate permissions to send the command, and it must be able to create a connection (i.e. it will not be able to kill a blocked process in the same way that the unix command kill -9 would). By default, the kill process will connect to the discovery service(s), and kill the processes of the specified types. The kill process can be modified to not use the discovery service and instead use the process.csv file via the configuration in the standard way.</p> <p>If run without any command line parameters, kill.q will try to kill each process it finds with type defined by its .servers.CONNECTIONS variable.</p> <pre><code>q torq.q -load code/processes/kill.q -p 20000 -proctype kill -procname killtick\n</code></pre> <p>.servers.CONNECTIONS can optionally be overridden from the command line (as can any other process variable):</p> <pre><code>q torq.q -load code/processes/kill.q -p 20000 -.servers.CONNECTIONS rdb tickerplant -proctype kill -procname killtick\n</code></pre> <p>The kill process can also be used to kill only specific named processes within the process types:</p> <pre><code>q torq.q -load code/processes/kill.q -p 20000 -killnames hdb1 hdb2 -proctype kill -procname killtick\n</code></pre> <p></p>"},{"location":"Processes/#chained-tickerplant","title":"Chained Tickerplant","text":"<p>In tick+ architecture the main tickerplant is the most important component, as it is relied upon by all the real time subscribers. When the tickerplant goes down data will be lost, compare this to an rdb which can be recovered after it fails. The chained tickerplant process is an additional tickerplant that is a real time subscriber to the main tickerplant but replicates its behaviour. It will have its own real time subscribers and can be recovered when it fails. This is the recommended approach when users want to perform their own custom real time analysis.</p> <p>The chained tickerplant can:</p> <ul> <li> <p>subscribe to specific tables and syms</p> </li> <li> <p>batch publish at an interval or publish tick by tick</p> </li> <li> <p>create a tickerplant log that its real time subscribers can replay</p> </li> <li> <p>replay the source tickerplant log</p> </li> </ul> <p>To launch the chained tickerplant</p> <pre><code>q torq.q -load code/processes/chainedtp.q -p 12009 -proctype chainedtp -procname chainedtp1\n</code></pre> <p>Chained tickerplant settings are found in <code>config/settings/chainedtp.q</code> and are under the <code>.ctp</code> namespace.</p> Setting Explanation Default tickerplantname list of tickerplant names to try and make a connection to <code>`tickerplant1</code> pubinterval publish batch updates at this interval. If the value is 0D00:00:00 then it will publish tick by tick <code>0D00:00:00</code> tpconnsleep number of seconds between attempts to connect to the source tickerplant <code>10</code> createlogfile create a log file <code>0b</code> logdir directory containing chained tickerplant logs <code>`:hdb</code> subscribeto subscribe to these tables only (null for all) <code>`</code> subscribesyms subscribe to these syms only (null for all) <code>`</code> replay replay the tickerplant log file <code>0b</code> schema retrieve schema from tickerplant <code>1b</code> clearlogonsubscription clear log on subscription, only called if createlogfile is also enabled <code>0b</code>"},{"location":"Processes/#torq-data-quality-system-architecture","title":"TorQ Data Quality System Architecture","text":"<p>Whilst the Monitor process checks the health of other processes in the  system, it does not check the quality of the data captured. An RDB process  could be running, but capturing and populating its tables with null values,  or not running at all. These errors would not be caught by the Monitor process,  so the Data Quality System has been developed with the purpose of capturing such errors. The system periodically runs a set of user-specified checks on selected processes to ensure data quality.</p> <p>For example, you can place checks on a table to periodically check that the percentage of nulls it contains in a certain column is below a given threshold, or check that the values of a column stay within a specified range that changes throughout the day.</p> <p>The system behaves based on Data Quality Config files. The metrics from the config files and the results of the checks performed on databases in the data capturing system are saved to Data Quality Databases. The results can then be used for monitoring tools to alert users.</p> <p>The Data Quality System consists of four processes: the Data Quality Checker(DQC) and the Data Quality Engine(DQE), as well as a Database process for each (DQCDB and DQEDB).  These processes are explained in detail below.</p>"},{"location":"Processes/#data-quality-checker-dqc","title":"Data Quality Checker (DQC)","text":"<p>The Data Quality Checker process runs checks on other TorQ processes to check the quality of data in the system. The specific parameters of  the checks that are being run can be configured in <code>config/dqcconfig.csv</code>. Configuration from <code>dqcconfig.csv</code> is then  loaded to <code>configtable</code> in the <code>dqe</code> namespace, and the checks are then run based on the parameters. The results of the checks are saved to the results table in the <code>dqe</code> namespace. The  results table that contains all check results will periodically be saved to the DQCDB intraday. The configuration of the checks will also be periodically saved to the DQCDB throughout the day.</p> <p>Example of <code>configtable</code> is shown below:</p> <pre><code>    action         params                                                                                                   proc           mode   starttime                     endtime                       period               checkid\n    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    tableticking   \"`comp`vars!(0b;(`quote;5;`minute))\"                                                                     \"`rdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:05:00.000000000 0\n    chkslowsub     \"`comp`vars!(0b;1000000)\"                                                                                \"`tickerplant\" repeat 2020.03.20D09:00:00.000000000 2020.03.20D19:00:00.000000000 0D00:10:00.000000000 1\n    tableticking   \"`comp`vars!(0b;(`quote;5;`minute))\"                                                                     \"`rdb1\"        single 2020.03.20D12:00:00.000000000                                                    2\n    constructcheck \"`comp`vars!(0b;(`quote;`table))\"                                                                        \"`rdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:02:00.000000000 3\n    constructcheck \"`comp`compallow`compproc`vars!(1b;0;`hdb1;(`date;`variable))\"                                           \"`hdb2\"        repeat 2020.03.20D09:00:00.000000000                               0D00:02:00.000000000 4\n    attrcheck      \"`comp`vars!(0b;(`quote;`s`g;`time`sym))\"                                                                \"`rdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:02:00.000000000 5\n    schemacheck    \"`comp`vars!(0b;(`quote;`time`sym`bid`ask`bsize`asize`mode`ex`src;\\\"psffjjccs\\\";`````````;`s`g```````))\" \"`rdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:15:00.000000000 6\n    freeform       \"`comp`vars!(0b;\\\"select from trade where date=2020.01.02\\\")\"                                            \"`hdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:03:00.000000000 7\n    symfilecheck   \"(`comp`vars!(0b;(.dqe.hdbdir;`sym)))\"                                                                   \"`hdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:10:00.000000000 8\n    xmarketalert   \"`comp`vars!(0b;(`quote))\"                                                                               \"`rdb1\"        repeat 2020.03.20D09:00:00.000000000                               0D00:05:00.000000000 9\n</code></pre> <p>action - The check function that you would like to perform. Specific checks and usages can be found in the directory <code>code/dqc</code>.</p> <p>params - The parameters that are used by the function. The Checker accepts params as a dictionary, with <code>comp</code> and <code>vars</code> being the two keys when function is only used on one process, and <code>comp</code>, <code>compallow</code>, <code>compproc</code>, and <code>vars</code> being the four keys when function is used to compare two processes. <code>comp</code> should be assigned a boolean value - when it is <code>1b</code>, comparison is ON and the function is then used to compare two processes. <code>compallow</code> would then be the percentage allowed for for the difference between the results that are returned from the two processes. <code>compproc</code> would be the process that you are comparing <code>proc</code> with. <code>vars</code> would be the variable used for the function provided. When it is <code>0b</code>, comparison is OFF and the function is only used in one process. The <code>var</code> key should have a value of all the variables that are used by the function. Details of the variables used by checker functions can be found in <code>config/dqedetail.csv</code>.</p> <p>proc - The process(es) that you would want the check function to be used for - in symbol datatype.</p> <p>mode - Mode could be set to either <code>repeat</code> or <code>single</code>. When it is set to <code>repeat</code> the check will be periodically run based on the period parameter, which sets the time it will take before running the same check again. When it is set to <code>single</code>, the check will only be ran once.</p> <p>starttime - The start time of the check function - in timespan datatype.</p> <p>endtime - When mode is <code>repeat</code>, end time specifies when the check will run for the last time for the day. When mode is <code>single</code>, endtime should be set to <code>0N</code>. Should be in timespan datatype.</p> <p>period - When mode is <code>repeat</code>, period represents the time it takes for the next run to start. When mode is <code>single</code>, period should be set to <code>0N</code>. Should be in timespan datatype.</p> <p>An example of <code>.dqe.results</code> is shown below:</p> <pre><code>    id funct               params                                   procs       procschk     starttime                     endtime                       result descp                                            chkstatus chkruntype\n    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    2  .dqc.tableticking   quote,5,minute                           rdb         rdb1         2020.03.19D20:04:59.777402000 2020.03.19D20:04:59.784107000 1      \"there are 44 records\"                           complete  scheduled\n    0  .dqc.tableticking   quote,5,minute                           rdb         rdb1         2020.03.19D20:05:00.178288000 2020.03.19D20:05:00.186770000 1      \"there are 82 records\"                           complete  scheduled\n    9  .dqc.xmarketalert   quote                                    rdb         rdb1         2020.03.19D20:05:00.179664000 2020.03.19D20:05:00.193734000 1      \"bid has not exceeded the ask in market data\"    complete  scheduled\n    3  .dqc.constructcheck quote,table                              rdb         rdb1         2020.03.19D20:06:00.178885000 2020.03.19D20:06:00.196380000 1      \"quote table exists\"                             complete  scheduled\n    4  .dqc.constructcheck date,variable,comp(hdb1,0)               hdb         hdb2         2020.03.19D20:06:00.180247000 2020.03.19D20:06:00.203920000 1      \"hdb1  | match hdb2\"                             complete  scheduled\n    5  .dqc.attrcheck      quote,s,g,time,sym                       rdb         rdb1         2020.03.19D20:06:00.182379000 2020.03.19D20:06:00.201300000 1      \"attribute of time,sym matched expectation\"      complete  scheduled\n    7  .dqc.freeform       select from trade where date=2020.01.02  hdb         hdb1         2020.03.19D20:06:00.184577000 2020.03.19D20:06:00.205209000 1      \"select from trade where date=2020.01.02 passed\" complete  scheduled\n    3  .dqc.constructcheck quote,table                              rdb         rdb1         2020.03.19D20:08:00.378141000 2020.03.19D20:08:00.398781000 1      \"quote table exists\"                             complete  scheduled\n    4  .dqc.constructcheck date,variable,comp(hdb1,0)               hdb         hdb2         2020.03.19D20:08:00.379574000 2020.03.19D20:08:00.404501000 1      \"hdb1  | match hdb2\"                             complete  scheduled\n</code></pre> <p>The columns of results table provide information about the checks performed:</p> <p>id - The id of the check after being loaded into the process. In the sample table above, <code>.dqc.construckcheck</code> with the id 3 that checks whether quote table exists and <code>.dqc.construckcheck</code> with the id 4 that checks whether data in hdb1 matches hdb2 had two results showing as they have been ran twice within that time period, but the parameters of the checks have not been changed. The id column is also useful for manually running checks.</p> <p>funct - The check function that was performed.</p> <p>params - The variables that were input while the check function was  performed.</p> <p>procs - The process(es) type that the function was performed on.</p> <p>procschk - The specific process(es) that the function was performed on.</p> <p>starttime - When the function was started.</p> <p>endtime - When the function stopped running.</p> <p>result - Returns a boolean value. If the result is <code>1</code>, then the function was ran successfully, and no data anomaly was found. If the result is <code>0</code>, then the function may not have been run successfully, or the data quality may be corrupted.</p> <p>descp - A string description describing the result of the check  function.</p> <p>chkstatus - Could display either <code>complete</code> or <code>failed</code>. When the check function runs successfully, whether the result column is 0 or 1, chkstatus would be <code>complete</code>. However, if there was an error that caused the check to not run successfully(Ex: variables being a wrong type), <code>failed</code>  would be displayed instead.</p> <p>chkruntype - Could display either <code>scheduled</code> or <code>manual</code>, meaning either the check was ran as scheduled from the configtable, or it was forced to run manually from the console.</p> <p>Below, we list all the built-in checks that we offer as part of the Data Quality Checker.</p> <ul> <li><code>.dqc.constructcheck</code> - Checks if a construct exists.</li> <li><code>.dqc.tableticking</code> - Checks if a table has obtained records within a specified time period.</li> <li><code>.dqc.chkslowsub</code> - Checks queues on handles to make sure there are no slow subscribers.</li> <li><code>.dqc.tablecount</code> - Checks a table count against a number. This can be a <code>&gt;</code>, <code>&lt;</code> or <code>=</code> relationship.</li> <li><code>.dqc.tablehasrecords</code> - A projection of <code>.dqc.tablecount</code> that is used to check if a table is non-empty.</li> <li><code>.dqc.attrcheck</code> - Checks that a tables actual schema matches the expectation.</li> <li><code>.dqc.infinitychk</code> - Checks the percentage of infinities in certain columns of a table are below a given threshold.</li> <li><code>.dqc.freeform</code> - Checks if a query has passed correctly.</li> <li><code>.dqc.schemacheck</code> - Checks if the meta of a table matches expectation.</li> <li><code>.dqc.datechk</code> - Checks the date vector contains the latest date in a HDB.</li> <li><code>.dqc.nullchk</code> - Checks percentages of nulls in columns of a table are below a given threshold.</li> <li><code>.dqc.symfilecheck</code> - Checks that the sym file exists.</li> <li><code>.dqc.xmarketalert</code> - Tests whether the bid price has exceeded in the ask price in market data.</li> <li><code>.dqc.dfilechk</code> - Checks the <code>.d</code> file in the latest date partition matches the previous date values.</li> <li><code>.dqc.rangechk</code> - Checks whether the values of columns of a table are within a given range.</li> <li><code>.dqc.tablecomp</code> - Counts the number of rows in a table, used for comparison between two processes</li> <li><code>.dqc.pctAvgDailyChange</code> - Checks if a function applied to a table is within the threshold limits of an n-day average.</li> <li><code>.dqc.symfilegrowth</code> - Checks if today's sym file count has grown more than a certain percentage</li> <li><code>.dqc.timdiff</code> - Checks if idfferences between time columns are over a certain limit</li> <li><code>.dqc.memoryusage</code> - Checks percentage of memory usage compared to max memory</li> <li><code>.dqc.refdatacheck</code> - Checks whether the referenced column of a table is in another column of another table</li> </ul> <p>New Custom Check To add custom checks, create a new q file in /code/dqc. The new q script should be under the namespace dqc, and should contain the function. The function should return a mixed list with two atoms: first atom being boolean, and second being string. The first atom would contain whether the check was successful (1b) or was there an error/failed check(0b). This will be shown in the result column of the results table. The second atom would contain the description of the result of the check.</p> <p>Below is a sample of a qscript named customcheck.q, with the function customcheck, written in pseudo-code for reference:</p> <pre><code>\\d .dqc\n\ncustomcheck:{[variable1;variable2]\n  $[variable1~variable2;\n    (1b;\"Description if the function ran successfully\");\n    (0b;\"Description if the function failed to run\")]\n  }\n</code></pre> <p>To use the function to run check, proceed to /appconfig/dqcconfig.csv, and modify how you would want the check to be ran. As an example, to run the customcheck above with the following settings - </p> <p>params - Not comparing two processes, and running with the two variables being <code>abc</code> and <code>def</code>. proc - running on the processes <code>rdb1</code> and <code>rdb2</code>. mode - the function being run repeatedly. starttime - 9AM. endtime - not specified. period - the check to be run every 10 minutes.</p> <p>The line in dqcconfig.csv should be:</p> <pre><code>action,params,proc,mode,starttime,endtime,period\ncustomcheck,`comp`vars!(0b;(`abc;`def)),`rdb1;`rdb2,repeat,09:00:00.000000000,0Wn,0D00:10:00\n</code></pre> <p>To add a check that compares two processes, the check function would have to return a mixed listed with three atoms. The first two being the same as above, and the third being a numeric value. The numeric value would be what is compared between the two processes.</p> <p>Below is a sample of a qscript named customcheck.q, with the function customcheck, written in pseudo-code for reference to compare two processes:</p> <pre><code>\\d .dqc\n\ncustomcheck:{[variable1;variable2]\n  $[variable1~variable2;\n    (1b;\"Description if the function ran successfully\";count variable1);\n    (0b;\"Description if the function failed to run\";avg variable2)]\n  }\n</code></pre> <p>Secondly, the line in dqcconfig.csv should be modified. As mentioned above, the <code>params</code> parameter would now have to be changed, and two additional dictionary keys would have to be added. As an example, if we were to run the function customcheck comparing <code>hdb1</code> and <code>hdb2</code>, with there being no difference allowed between the two results returned from the two processes, the line would be the following:</p> <pre><code>action,params,proc,mode,starttime,endtime,period\ncustomcheck,`comp`compallow`compproc`vars!(1b;0;`hdb1;(`abc;`def)),`hdb2,repeat,09:00:00.000000000,0Wn,0D00:10:00\n</code></pre> <p>If we were to allow for 50% difference between the results returned from the two processes using the function customcheck, the line would be the following:</p> <pre><code>action,params,proc,mode,starttime,endtime,period\ncustomcheck,`comp`compallow`compproc`vars!(1b;50;`hdb1;(`abc;`def)),`hdb2,repeat,09:00:00.000000000,0Wn,0D00:10:00\n</code></pre>"},{"location":"Processes/#data-quality-engine-dqe","title":"Data Quality Engine (DQE)","text":"<p>The DQE process stores daily statistics of other TorQ processes. It is a separate process from the DQC  because the DQE does not run checks. The DQE and the DQC could be used to track the percentage change of records in a table from day to day. The Checker can then use the data saved the DQEDB to perform advanced checks.The behaviour of the Engine is based on the config file stored in <code>config/dqengineconfig.csv</code>.</p> <p>The config csv file is shown below:</p> <pre><code>    query,params,proc,querytype,starttime\n    -------------------------------------\n    tablecount,.z.d-1,`hdb1,table,09:00:00.000000000\n    symfilecheck,`sym,`hdb1,other,09:00:00.000000000\n    symcount,(`quote;`sym),`hdb1,table,09:00:00.000000000\n</code></pre> <p>query - The query function that is used to provide daily statistics of a process.</p> <p>params - the variables that is used for the query function.</p> <p>proc - The process that the query function is running on.</p> <p>querytype - Whether the query is ran for a <code>table</code> or <code>other</code>.</p> <p>starttime - What time should the query start.</p> <p>The daily statistics of other TorQ processes are saved to the <code>resultstab</code> and the <code>advancedres</code> tables in <code>dqe</code> namespace, which would be saved to Data Quality Engine Database (DQEDB). The <code>resultstab</code> table contains the results of simple qeuries that return intger values that is reflected by the column <code>resvalue</code>. The <code>advancedres</code> table contains the results of advanced queries that return whole tables, which is reflected by the column \"resultdata\".</p> <p>Example of <code>resultstab</code> is shown below:</p> <pre><code>    date       procs funct        table     column resvalue\n    -------------------------------------------------------\n    2020.03.16 hdb1  tablecount   quote            0\n    2020.03.16 hdb1  tablecount   quote_iex        0\n    2020.03.16 hdb1  tablecount   trade            0\n    2020.03.16 hdb1  tablecount   trade_iex        0\n    2020.03.16 hdb1  symfilecheck                  10\n    2020.03.16 hdb1  symcount     quote     sym    10\n</code></pre> <p>date - Date that the data was saved.</p> <p>procs - The process that the query function was running on.</p> <p>funct - The query function that was used.</p> <p>table - Table that the function ran on. If the query was not performed on a table, the section is left blank.</p> <p>column - Column of the table that the function ran on. If  the query did not specify the column, the section is left blank.</p> <p>resvalue - The value returned from the function that was ran.</p> <p>Example of <code>advancedres</code> is shown below:</p> <pre><code>    date       procs funct      table resultkeys resultdata\n    ---------------------------------------------------------\n    2020.07.22 hdb1  bycount    quote sym        (+(,`sym)!,`AAPL`AIG`AMD`DELL`DOW`GOOG`HPQ`IBM`INTC`MSFT)!+(,`i)!,209356 208544 209003 208687 208420 209706 208319 207438 207455 209588    \n</code></pre> <p>date - Date that the data was saved.</p> <p>procs - The process that the query function was running on.</p> <p>funct - The query function that was used.</p> <p>table - Table that the function ran on. If the query was not performed on a table, the section is left blank.</p> <p>resultkeys - Keys or variables used to generate the result table, or the table in resultdata.</p> <p>resultdata - The table retrned from the function that was ran.</p> <p>New Custom Queries To add custom queries, create a new q file in /code/dqe. The new q script should be under the namespace dqe, and should contain the function. The function should return a dictionary, With the key being the function name, and the value being the statistic that the query should return. The value from the dictionary will be shown as the resvalue in the <code>resultstab</code> table. </p> <p>Below is a sample of a qscript named customquery.q, with the function customquery, written in pseudo-code for reference:</p> <pre><code>\\d .dqe\n\ncustomquery:{[variable1;variable2]\n  (enlist variable1)!enlist count variable2\n  }\n</code></pre> <p>To use the function to run check, proceed to /appconfig/dqengineconfig.csv, and modify how you would want the check to be ran. As an example, to run the customquery above with the following settings -</p> <p>params - Variable being <code>abc</code>. proc - running on the process <code>hdb1</code>. querytype - other as it is not a table starttime - 9AM</p> <p>The line in the config csv should be:</p> <pre><code>query,params,proc,querytype,starttime\ncustomquery,`table`quote,`hdb1,other,09:00:00.000000000\n</code></pre>"},{"location":"analyticslib/","title":"Analytics Library","text":"<p>A set of analytical functions is provided for the simplification of common operations. This set of tools is targeted at new kdb+ developers or business users. Data visualization would be an example application of this library, as an effective visualization of data incurs various manipulations of data sets. For example, a user wishes to produce a 15 minute bucketed sample of a time series, and forward fill it, then pivot it. All of the above can be achieved with the functions defined below. </p>"},{"location":"analyticslib/#general-usage","title":"General Usage","text":"<p>These set of function are defined in the <code>.al</code> namespace. All of the functions below have an input parameter in the form of a dictionary. The specifics of each dictionary are detailed in the usage section of each function. </p> <p>This set of utilities also includes a general set of error traps which were designed to give informative errors specific to each function. For example if a dictionary has not been provided then the error would be:</p> <pre><code>q).al.pivot[123]\n'Input parameter must be a dictionary with keys:\n        -table\n        -by\n        -piv\n        -var\n</code></pre> <p>These error traps and messages are to guide the user in the correct use of the utilities and are designed to be as informative as possible.</p>"},{"location":"analyticslib/#ffill","title":"ffill","text":""},{"location":"analyticslib/#usage","title":"Usage","text":"<p>This script contains the utility to dynamically forward fill a given table keyed by given columns.</p> <p>Input is a dictionary containing:</p> <ul> <li>table: Table to be forward filled</li> <li>by: List of column names to key the table (optional)</li> <li>keycols: List of columns names to be forward filled (optional)</li> </ul> <p>OR </p> <ul> <li>Table</li> </ul> <p>This utility is equivalent to:  <code>update fills col1, fills col2 ... by col2 from table</code></p> <p>If you have a large data set or just a table with multiple columns typing this statement out can be quite laborious. With this utility you simply specify the table or parameter dictionary and pass it to the function. This utility also has the added functionality of being able to forward fill mixed list columns, i.e. strings.</p>"},{"location":"analyticslib/#examples","title":"Examples","text":""},{"location":"analyticslib/#example-11","title":"Example 1.1","text":"<p>By specifying the <code>by</code> condition in the input dictionary the function can forward fill keyed by specific column, for example:</p> <pre><code>q)table\ntime         sym  ask bid asize bsize a id\n------------------------------------------\n00:00:38.184 AMD  121 12  3     30    a 1\n00:01:25.332 AMD  121 3   3     30    b 4\n00:09:37.574 AAPL 63  32  3     30    b 3\n00:21:24.796 AAPL 63      12            4\n00:38:39.521 AAPL 121 3   5           a 3\n00:40:41.670 MSFT 63  3   4     20    c 4\n00:48:08.048 MSFT 63            40      3\n00:48:39.290 IBM  63  3   12    40    d 2\n00:57:47.067 AAPL     24  3     30      2\n01:08:00.945 AAPL 121 12  3     20    b 3\n\n</code></pre> <p>We can create the input dictionary in the following way to specify the by clause of the <code>ffill</code> utility:</p> <pre><code>q)args:(`table`by)!(table;`sym)\n</code></pre> <p>Passing this to the function we can see the result:</p> <pre><code>q).al.ffill args\ntime         sym  ask bid asize bsize a id\n------------------------------------------\n00:00:38.184 AMD  121 12  3     30    a 1\n00:01:25.332 AMD  121 3   3     30    b 4\n00:09:37.574 AAPL 63  32  3     30    b 3\n00:21:24.796 AAPL 63  32  12    30    b 4\n00:38:39.521 AAPL 121 3   5     30    a 3\n00:40:41.670 MSFT 63  3   4     20    c 4\n00:48:08.048 MSFT 63  3   4     40    c 3\n00:48:39.290 IBM  63  3   12    40    d 2\n00:57:47.067 AAPL 121 24  3     30    a 2\n01:08:00.945 AAPL 121 12  3     20    b 3\n\n</code></pre>"},{"location":"analyticslib/#example-12","title":"Example 1.2","text":"<p>By specifying the <code>keycols</code> condition in the input dictionary the function can forward fill only specific columns, for example:</p> <p>Using the data set below we can create an input specifying which column we want to forward fill:</p> <pre><code>q)table\ntime                          sym  src price size mode\n------------------------------------------------------\n2018.02.13D08:02:09.322000000 AAPL N   32    513  \"A\"\n2018.02.13D08:03:23.511000000 AAPL N   32    344  \"\"\n2018.02.13D08:06:35.424000000 AAPL N   32    1933 \"B\"\n2018.02.13D08:13:03.067000000 AAPL N   76    1009 \"B\"\n2018.02.13D08:15:09.130000000 AAPL O   43    5199 \"B\"\n2018.02.13D08:22:21.528000000 AAPL N   76    427  \"A\"\n2018.02.13D08:23:46.489000000 AAPL N         7918 \"B\"\n2018.02.13D08:26:34.645000000 AAPL N   43    420  \"\"\n2018.02.13D08:27:41.633000000 AAPL N         5391 \"A\"\n2018.02.13D08:28:00.078000000 AAPL N   54    713  \"A\"\n2018.02.13D08:28:39.200000000 AAPL N         8117 \"C\"\n2018.02.13D08:32:21.651000000 AAPL N   43    178  \"A\"\n\nq)args:(`table`keycols)!(table;`price)\nq).al.ffill args\ntime                          sym  src price size mode\n------------------------------------------------------\n2018.02.13D08:02:09.322000000 AAPL N   32    513  \"A\"\n2018.02.13D08:03:23.511000000 AAPL N   32    344  \"\"\n2018.02.13D08:06:35.424000000 AAPL N   32    1933 \"B\"\n2018.02.13D08:13:03.067000000 AAPL N   76    1009 \"B\"\n2018.02.13D08:15:09.130000000 AAPL O   43    5199 \"B\"\n2018.02.13D08:22:21.528000000 AAPL N   76    427  \"A\"\n2018.02.13D08:23:46.489000000 AAPL N   76    7918 \"B\"\n2018.02.13D08:26:34.645000000 AAPL N   43    420  \"\"\n2018.02.13D08:27:41.633000000 AAPL N   43    5391 \"A\"\n2018.02.13D08:28:00.078000000 AAPL N   54    713  \"A\"\n2018.02.13D08:28:39.200000000 AAPL N   54    8117 \"C\"\n2018.02.13D08:32:21.651000000 AAPL N   43    178  \"A\"\n\n\n</code></pre> <p>Note that without specifying the <code>by</code> condition the column was forward filled as it sits in the table.</p>"},{"location":"analyticslib/#example-13","title":"Example 1.3","text":"<p>Passing just a table into the function will forward fill all columns, for example:</p> <pre><code>q)table\ntime         sym  ask bid asize bsize a id\n------------------------------------------\n00:00:38.184 AMD  121 12  3     30    a 1\n00:01:25.332 AMD  121 3   3     30    b 4\n00:09:37.574 AAPL 63  32  3     30    b 3\n00:21:24.796 AAPL 63      12            4\n00:38:39.521 AAPL 121 3   5           a 3\n00:40:41.670 MSFT 63  3   4     20    c 4\n00:48:08.048 MSFT 63            40      3\n00:48:39.290 IBM  63  3   12    40    d 2\n00:57:47.067 AAPL     24  3     30      2\n01:08:00.945 AAPL 121 12  3     20    b 3\n\nq).al.ffill table\ntime         sym  ask bid asize bsize a id\n------------------------------------------\n00:00:38.184 AMD  121 12  3     30    a 1\n00:01:25.332 AMD  121 3   3     30    b 4\n00:09:37.574 AAPL 63  32  3     30    b 3\n00:21:24.796 AAPL 63  32  12    30    b 4\n00:38:39.521 AAPL 121 3   5     30    a 3\n00:40:41.670 MSFT 63  3   5     20    a 4\n00:48:08.048 MSFT 63  3   4     40    c 3\n00:48:39.290 IBM  63  3   12    40    c 2\n00:57:47.067 AAPL 63  24  3     30    c 2\n01:08:00.945 AAPL 121 12  3     20    b 3\n\n</code></pre>"},{"location":"analyticslib/#pivot","title":"pivot","text":"<p>A pivot table is a design tool used to reorganize and summarize selected columns and rows of data to gain a better understanding of the data being provided. An in-depth explanation of how to pivot a table is available here.</p> <p>This is a modified version of code available on code.kx</p>"},{"location":"analyticslib/#usage_1","title":"Usage","text":"<p>This script contains the utility to pivot a table, specifying the keyed columns, the columns you wish to pivot around and the values you wish to expose. Note that this method always produces the last value for the grouping. To circumvent this you can do your own aggregation on the table before using the pivot function. For example you can create a column to calculate the sum: <code>update totsum:sum price by sym,src from table</code> and then pivot the data.</p> <p>This utility takes a dictionary as input with the following parameters:</p> <ul> <li>table: The table you want to pivot</li> <li>by:  The keyed columns</li> <li>piv:     The pivot columns</li> <li>var:     The variables you want to see</li> <li>f:   The function to create your column names (optional)</li> <li>g:   The function to sort your column names (optional)</li> </ul> <p>The optional function f is a function of var and piv which creates column names for your pivoted table. The optional function g is a function of the keyed columns, piv and the return of f, which sorts the columns in ascending order.</p>"},{"location":"analyticslib/#examples_1","title":"Examples","text":""},{"location":"analyticslib/#example-11_1","title":"Example 1.1","text":"<p>We have a table of quotes:</p> <pre><code>q)quote\ndate       sym  time         side level price    size\n-----------------------------------------------------\n2009.01.05 bafc 09:30:00.619 B    0     88.31803 96\n2009.01.05 oljg 09:30:15.770 A    2     24.72941 14\n2009.01.05 mgab 09:30:30.993 B    0     33.80173 2\n2009.01.05 cflm 09:30:45.457 A    4     13.08412 98\n2009.01.05 jgjm 09:31:00.668 B    0     80.2705  26\n2009.01.05 cnkk 09:31:15.988 A    1     23.27025 38\n..\n</code></pre> <p>We can key the table by date,sym and time, pivot around both side and level showing price  and size at each time. The input dictionary is created in the following way:</p> <pre><code>args:(`table`by`piv`var)!(quote;`date`sym`time;`side`level;`price`size);\n</code></pre> <p>Here we are specifying the arguments for f and g as the default functions:</p> <pre><code>// create _ separated column headers\nf:{[v;P] `$\"_\" sv' string (v,()) cross P}\n// return the headers in order\ng:{[k;P;c] k,asc c}\n</code></pre> <p>The pivot function is then called and the output can be seen below:</p> <pre><code>q).al.pivot[args]\ndate       sym  time        | price_A_0 price_A_1 price_A_2 price_A_3 price_A_4 price_B_0 price_B_1 price_B_2  price_B_3 price_B_4 size_A_0 size_A_1 size_A_2 size_A_3 size_A_4 size_B_0 size_B_1 size_B_2 size_B_3 size_B_4\n----------------------------| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n2009.01.05 bafc 09:30:00.619|                                                   88.31803                                                                                        96\n2009.01.05 bafc 10:05:30.395|                                                                                            60.77025                                                                                   73\n2009.01.05 bafc 10:11:00.990|                                                                       0.03195086                                                                                    71\n2009.01.05 bafc 10:41:00.031|                                                             68.8886                                                                                        60\n2009.01.05 bafc 10:41:15.924|                     4.926275                                                                                           56\n2009.01.05 bafc 11:06:30.361|                                                             84.28182                                                                                       10\n2009.01.05 bafc 11:52:30.361|                                                   8.733561                                                                                        7\n..\n</code></pre>"},{"location":"analyticslib/#example-12_1","title":"Example 1.2","text":"<p>We have the following table showing some FX data:</p> <pre><code>q)t\nsym    time  price size lp   region\n-----------------------------------\nEURGBP 09:00 1     870  UBS  LON\nEURGBP 09:07 7     296  BARX LON\nEURGBP 09:19 3     850  BARX LON\nEURGBP 09:27 1     540  HSBC NYC\nEURUSD 09:31 4     995  UBS  LON\nAUDUSD 09:38 0     396  HSBC NYC\nEURUSD 09:41 6     152  UBS  LON\nEURUSD 09:42 4     317  HSBC NYC\nEURGBP 09:43 6     670  HSBC LON\nEURGBP 09:47 7     345  BARX NYC\n..\n</code></pre> <p>We want to see the different prices each liquidity provider has for each currency pair. For this we need to pivot the table t by sym around the lp's to show the various prices. We first create out parameter dictionary:</p> <pre><code>args:(`table`by`piv`var)!(t;`sym;`lp;`price`size)\n</code></pre> <p>We then pass the dictionary into the pivot utility:</p> <pre><code>q).al.pivot[args]\nsym   | price_BARX price_HSBC price_UBS\n------| -------------------------------\nEURGBP| 7          1          1\nEURUSD| 8          4          4\nAUDUSD| 4          0          0\n\n</code></pre> <p>Another way to manipulate the same data would be to key the table by sym and lp (i.e. currency pair and liquidity provider) and pivot by region to show both price and size. Setting up this dictionary and passing it to the pivot function we see the result below:</p> <pre><code>q)args:(`table`by`piv`v)!(t;`sym`lp;`region;`price`size)\nq).al.pivot[args]\nsym    lp  | price_LON price_NYC size_LON size_NYC\n-----------| -------------------------------------\nEURGBP UBS | 1         3         870      32\nEURGBP BARX| 7         7         296      345\nEURGBP HSBC| 6         1         670      540\nEURUSD UBS | 4         1         995      494\nAUDUSD HSBC| 5         0         879      396\nEURUSD HSBC| 1         4         459      317\nEURUSD BARX| 6         8         62       299\nAUDUSD BARX| 4         2         817      716\nAUDUSD UBS | 3         0         744      217\n\n</code></pre>"},{"location":"analyticslib/#intervals","title":"intervals","text":"<p>The intervals.q utility in the .al namespace is used to output a list of equally spaced intervals between given start and end points.</p>"},{"location":"analyticslib/#usage_2","title":"Usage","text":"<p>Input is a dictionary containing:</p> <ul> <li>start: Starting integer number</li> <li>end: Ending integer number</li> <li>interval: Interval spacing between values</li> <li>round: Toggle rounding to nearest specified interval (optional)</li> </ul> <p>Parameters should be passed in the form of a dictionary, where start and end must be of the same type and interval can be either a long int or of the same type as start and end (i.e if start:09:00 and end:12:00, and intervals of 5 minutes were required interval could equal 00:05 or 5)</p> <p>Allowed data types are:</p> <ul> <li>date </li> <li>month </li> <li>time </li> <li>minute </li> <li>second </li> <li>timestamp </li> <li>timespan </li> <li>integer </li> <li>short </li> <li>long</li> </ul>"},{"location":"analyticslib/#example","title":"Example","text":"<p>Using minute datatype:</p> <pre><code>q)params:`start`end`interval`round!(09:32;12:00;00:30;0b)\nq).al.intervals[params]\n09:32 10:02 10:32 11:02 11:32\n</code></pre> <p>or with round applied.</p> <pre><code>q)params:`start`end`interval`round!(09:32;12:00;00:30;1b)\nq).al.intervals[params]\n09:30 10:00 10:30 11:00 11:30 12:00\n</code></pre> <p>by default round is set to 1b, hence the result above can be obtained without inputting a value for round via:</p> <pre><code>q)params:`start`end`interval!(09:32;12:00;00:30)\nq).al.intervals[params]\n09:30 10:00 10:30 11:00 11:30 12:00\n</code></pre> <pre><code>q)params:`start`end`interval!(2001.04.07;2001.05.01;5)\nq).al.intervals[params]\n2001.04.05 2001.04.10 2001.04.15 2001.04.20 2001.04.25 2001.04.30\n</code></pre> <p>and without rounding</p> <pre><code>q)params:`start`end`interval`round!(2001.04.07;2001.05.01;5;0b)\nq).al.intervals[params]\n2001.04.07 2001.04.12 2001.04.17 2001.04.22 2001.04.27\n</code></pre> <pre><code>q)params:`start`end`interval!(00:20:30 01:00:00 00:10:00)\nq).al.intervals[params]\n00:20:00 00:30:00 00:40:00 00:50:00 01:00:00\n</code></pre> <pre><code>q)params:`start`end`interval`round!(00:20:30 01:00:00 00:10:00)\nq).al.intervals[params]\n00:20:30 00:30:30 00:40:30 00:50:30\n</code></pre> <pre><code>q)params:`start`end`interval!(00:01:00.000000007;00:05:00.000000001;50000000000)\nq).al.intervals[params]\n0D00:00:50.000000000 0D00:01:40.000000000 0D00:02:30.000000000 0D00:03:20.000000000 0D00:04:10.000000000 0D00:05:00.000000000\n</code></pre>"},{"location":"analyticslib/#rack","title":"rack","text":"<p>The rack utility gives the user the ability to create a rack table (the cross product of distinct values at the input).</p>"},{"location":"analyticslib/#usage_3","title":"Usage","text":"<p>Input is be a dictionary containing:</p> <ul> <li>table: Keyed or unkeyed in memory table</li> <li>keycols:  The columns of the table you want to create the rack from.</li> <li>base: This is an additional table, against which the rack can be created (optional)</li> <li>timeseries.start: Start time to create a timeseries rack (optional)</li> <li>timeseries.end: End time to create a time series rack (optional)</li> <li>timeseries.interval: The interval for the time racking (optional)</li> <li>timeseries.round: Should rounding be carried out when creating the timeseries (optional)</li> <li>fullexpansion: Determines whether the required columns of input table will be expanded themselves or not. (optional, default is 0b)</li> </ul> <p>A timeseries is optional but if it is required then start, end, and interval must be specified as a dictionary called 'timeseries' (round remains optional with a default value of 1b). Keyed tables can be provided, these will be unkeyed by the function and crossed as standard unkeyed tables.</p> <p>Full expansion in this case refers to the level to which the data is crossed with itself and the user-defined intervals. For example were full expansion disabled then the table would be crossed with the user defined intervals and then crossed with the base. If full expansion is enabled then all of the table columns are crossed with each other before being crossed with the intervals and then the base. Allowing for a more in depth and detailed representation of the data.</p>"},{"location":"analyticslib/#examples_2","title":"Examples","text":""},{"location":"analyticslib/#example-11_2","title":"Example 1.1","text":"<ul> <li>no fullexpansion, only table and keycols specified</li> </ul> <pre><code>q)t\nsym exch price\n--------------\na   nyse 1\nb   nyse 2\na   cme  3\n\nq)k\n`sym`exch\n\ncreate a dictionary\nq)dic:`table`keycols!(t;k)\n\nq).al.rack[dic]\nsym exch\n--------\na   nyse\nb   nyse\na   cme\n</code></pre> <p>(simplest case, only returns unaltered keycols)</p>"},{"location":"analyticslib/#example-12_2","title":"Example 1.2","text":"<ul> <li>timeseries,fullexpansion specified, table is a keyed table</li> </ul> <pre><code>q)dic\ntable        | (+(,`sym)!,`a`b`a)!+`exch`price!(`nyse`nyse`cme;1 2 3)\nkeycols      | `sym`exch\ntimeseries   | `start`end`interval!09:00 12:00 01:00\nfullexpansion| 1b\n\nq).al.rack[dic]\nsym exch interval\n-----------------\na   nyse 09:00\na   nyse 10:00\na   nyse 11:00\na   nyse 12:00\na   cme  09:00\na   cme  10:00\na   cme  11:00\na   cme  12:00\nb   nyse 09:00\nb   nyse 10:00\nb   nyse 11:00\nb   nyse 12:00\nb   cme  09:00\nb   cme  10:00\nb   cme  11:00\nb   cme  12:00\n</code></pre>"},{"location":"analyticslib/#example-13_1","title":"Example 1.3","text":"<ul> <li>timeseries,fullexpansion specified,base specified, table is keyed</li> </ul> <pre><code>q)dic\ntable        | (+(,`sym)!,`a`b`a)!+`exch`price!(`nyse`nyse`cme;1 2 3)\nkeycols      | `sym`exch\ntimeseries   | `start`end`interval!00:00:00 02:00:00 00:30:00\nbase         | +(,`base)!,`buy`sell`buy`sell\nfullexpansion| 1b\n\nq).al.rack[dic]\nbase sym exch interval\n----------------------\nbuy  a   nyse 00:00:00\nbuy  a   nyse 00:30:00\nbuy  a   nyse 01:00:00\nbuy  a   nyse 01:30:00\nbuy  a   nyse 02:00:00\nbuy  a   cme  00:00:00\nbuy  a   cme  00:30:00\nbuy  a   cme  01:00:00\nbuy  a   cme  01:30:00\nbuy  a   cme  02:00:00\nbuy  b   nyse 00:00:00\nbuy  b   nyse 00:30:00\nbuy  b   nyse 01:00:00\nbuy  b   nyse 01:30:00\nbuy  b   nyse 02:00:00\nbuy  b   cme  00:00:00\nbuy  b   cme  00:30:00\nbuy  b   cme  01:00:00\nbuy  b   cme  01:30:00\nbuy  b   cme  02:00:00\n</code></pre>"},{"location":"blog/","title":"TorQ Blog Posts","text":"<p> Creating a Custom Application </p> <p>Something that is not immediately clear is how a custom application built on TorQ should be structured and deployed. This blog outlines how a custom application should be structured.</p> <p> Avoiding End-of-Day Halts </p> <p>kdb+tick is great, but there\u2019s a problem- when the RDB (real time database) writes to disk on its daily schedule, users cannot access that day\u2019s data until the write out is complete. this blog post details how TorQ solves this problem.</p> <p> Fast, Flexible, Low Memory End-Of-Day Writes </p> <p>A discussion on which method you should use for an end-of-day sort in TorQ.</p> <p> End-of-Day Parallel Sorting </p> <p>Details on how TorQ utilises sortworkers to vastly speed up the end-of-day sort.</p> <p> Broadcast Publish </p> <p>kdb+ v3.4 introduces a new broadcast feature that reduces the work done when publishing messages to multiple subscribers. This blog post explains how and why to use this feature.</p> <p> Recovering Corrupt Tickerplant Logs </p> <p>Corrupt tickerplant logs are a curse that no one deserves but that doesn\u2019t stop them from happening even to the best of us. However, all hope is not lost as it is possible to recover the good messages and discard the bad. In this post we will extend upon the standard rescuelog procedure to recover as much as possible from the log file.</p> <p> kdb+ Gateways </p> <p>The advantages and methods of using a gateway in a kdb+ tick system.</p> <p> Faster Recovery With kdb+ tick </p> <p>How to effectively recover a process to its previous state after a crash using the RDB instead of the tickerplant log.</p> <p> Parallel kdb+ Database Access with QPad </p> <p>We\u2019ve been working with Oleg Zakharov, who created QPad, to implement asynchronous querying and allow users to run multiple concurrent queries more efficiently. This blog explains how it works.</p> <p> TorQ Permission Framework </p> <p>An in depth and interactive post explaining TorQ permissioning.</p>"},{"location":"cheatsheet/","title":"Cheat Sheet","text":"<p>The purpose of this cheatsheet is to provide a very condensed guide to the bits you need to know about TorQ to either debug a running process, or to extend a TorQ stack. It does not replace the main body of documentation, and ordering is presumed order-of-relevance. The below uses the default configuration of TorQ and TorQ Finance Starter Pack, though a lot of it is configurable. It's probably a good idea to read the About section at least. </p>"},{"location":"cheatsheet/#debugging-running-processes","title":"Debugging Running Processes","text":"<p>Each TorQ process has several internal tables which are useful. Connect to these using standard tools (qcon, an IDE etc.). Default user:pass of admin:admin will usually work. </p>"},{"location":"cheatsheet/#usageusage","title":".usage.usage","text":"<p>.usage.usage is used to track the queries that are executed against the process and is usually the first place to look for problems. Data is stored in memory for 24 hours and also persisted to disk in a usage_ file which is rolled daily. Every query and timer function call is logged, except for <code>`.u.upd</code> or <code>`upd</code> messages as this would bloat the log file considerably. Queries are logged before they are executed (status=\"b\") and after (status=\"c\" (complete) or status=\"e\" (error)). </p> <p>If a query blocks a process and makes it unresponsive, it will have an entry (status=\"b\") in the log file on disk.  </p> <p>.usage.usage can be queried like any other kdb+ table to diagnose problems e.g. </p> <pre><code>100 sublist `timer xdesc .usage.usage\nselect from .usage.usage where time within ... \n</code></pre> <p>Note that this table is not especially helpful for gateway queries which are executed in an async call back manner. The gateway part of the request will (should) usually have a very short run time so the back end services should be interrogated to see what the slow parts are. </p> <p>More info on usage logs.</p>"},{"location":"cheatsheet/#timertimer","title":".timer.timer","text":"<p>.timer.timer shows information about the timer calls which are scheduled / have been run. Pay attention to the \"active\" field- if a timer call fails it will be removed from the timer (active=0b). To avoid this if required, wrap the function being executed by the timer in an error trap in the standard way. Use .timer.timer in combination with .usage.usage to work out if there are slow running/too frequent timers which are causing problems. More info.</p>"},{"location":"cheatsheet/#log-files","title":"Log Files","text":"<p>Log files are stored in the log directory specified by the environment variable KDBLOG. Each process creates 3 log files: </p> <ul> <li>an out log (out_ ) with standard log messages</li> <li>an error log file (err_ ) with errors</li> <li>a usage log file (usage_ ) with a log of every request that hits the process. </li> </ul> <p>The error log file should be empty. Don't ignore the out_ log file, there is a lot of information in there which can be used to debug. One thing that is a bit awkward is that if there is an error then the error log message timestamp has to be matched off against the out message log messages. You can force a process to write to a single log file if the process is started with the -onelog command line parameter, or use system commands similar to below to sync them up when required.</p> <pre><code># format the out and err logs into a single output sorted on time\nsort -nk1 out_log err_log \n\n# combine into a single output, show the last n rows of output before an error \nsort -nk1 out_log err_log | grep -B n ERR \n</code></pre>"},{"location":"cheatsheet/#clientsclients","title":".clients.clients","text":"<p>This shows inbound connections (connections created into this process). It may have interesting information about connection open/close. If it has a lot of rows it means some clients are connecting and disconnecting frequently. More info.</p>"},{"location":"cheatsheet/#serversservers","title":".servers.SERVERS","text":"<p>This shows outbound connections (connections created by this process to other processes). It's useful for tracking connections which have died. </p>"},{"location":"cheatsheet/#starting-stopping-and-debugging-processes","title":"Starting, Stopping and Debugging Processes","text":"<p>95% of TorQ installations in production run on Linux, and the below applies to Linux only. Use the torq.sh script to start/stop/debug processes. Become familiar with torq.sh, it has some very handy utilities.</p> <pre><code>newdeploy$ ./deploy/bin/torq.sh \nArguments:\n  start all|&lt;processname(s)&gt;               to start all|process(es)\n  stop all|&lt;processname(s)&gt;                to stop all|process(es)\n  print all|&lt;processname(s)&gt;               to view default startup lines\n  debug &lt;processname(s)&gt;                   to debug a single process\n  qcon &lt;processname&gt; &lt;username&gt;:&lt;password&gt; to qcon process\n  procs                                    to list all processes\n  summary                                  to view summary table\n  top &lt;processname&gt;                        to show top.q statistics for a single process\nOptional flags:\n  -csv &lt;fullcsvpath&gt;                       to run a different csv file\n  -extras &lt;args&gt;                           to add/overwrite extras to the start line\n  -csv &lt;fullcsvpath&gt; -extras &lt;args&gt;        to run both\n  -force                                   to force stop process(es) using kill -9\n</code></pre> <p>It is very, very difficult to try to debug a running kdb+ process remotely. Do not do this. Use torq.sh to stop the process and run it in the foreground in a test environment. </p> <pre><code>torquser@homer:/home/torquser/newdeploy$ ./deploy/bin/torq.sh stop rdb1\n09:45:40 | Shutting down rdb1...\ntorquser@homer:/home/torquser/newdeploy$ ./deploy/bin/torq.sh debug rdb1\n09:45:45 | Executing...\nq /home/torquser/newdeploy/deploy/TorQ/latest/torq.q -stackid 43100 -proctype rdb -procname rdb1 -U /home/torquser/newdeploy/deploy/TorQApp/latest/appconfig/passwords/accesslist.txt -localtime 1 -g 1 -T 180 -load /home/torquser/newdeploy/deploy/TorQ/latest/code/processes/rdb.q  -procfile /home/torquser/newdeploy/deploy/TorQApp/latest/appconfig/process.csv  -debug\nKDB+ 4.0 2020.06.18 Copyright (C) 1993-2020 Kx Systems\nl64/ 24()core 128387MB torquser homer 127.0.1.1 EXPIRE 2021.06.30 Data Intellect #59946\n(::;::)\n################################################################################\n#                                                                              #\n#                                 TorQ v3.8.0                                  #\n#                               Data Intellect                                 #\n#               We turn big data problems into smart data solutions            #\n#                                                                              #\n#      For questions, comments, requests or bug reports please contact us      #\n#                           w :     www.dataintellect.com                      #\n#                           e : torqsupport@dataintellect.com                  #\n#                                                                              #\n#                         Running on kdb+ 4 2020.06.18                         #\n#                                                                              #\n#                      TorQ Finance Starter Pack v 1.9.1                       #\n#                                                                              #\n################################################################################\n2020.11.23D09:45:45.294308000|homer|torq|/home/torquser/newdeploy/deploy/TorQ/latest/torq.q_3407_0|INF|init|trap mode (initialisation errors will be caught and thrown, rather than causing an exit) is set to 0\n2020.11.23D09:45:45.294327000|homer|torq|/home/torquser/newdeploy/deploy/TorQ/latest/torq.q_3407_0|INF|init|stop mode (initialisation errors cause the process loading to stop) is set to 0\n2020.11.23D09:45:45.294815000|homer|torq|/home/torquser/newdeploy/deploy/TorQ/latest/torq.q_3407_0|INF|init|attempting to read required process parameters proctype,procname from file /home/torquser/newdeploy/deploy/TorQApp/latest/appconfig/process.csv\n2020.11.23D09:45:45.295076000|homer|torq|/home/torquser/newdeploy/deploy/TorQ/latest/torq.q_3407_0|INF|readprocfile|port set to 43102\n2020.11.23D09:45:45.295109000|homer|torq|/home/torquser/newdeploy/deploy/TorQ/latest/torq.q_3407_0|INF|init|read in process parameters of proctype=rdb; procname=rdb1\n2020.11.23D09:45:45.295616000|homer|rdb|rdb1|INF|fileload|config file /home/torquser/newdeploy/deploy/TorQ/latest/config/settings/default.q found\n2020.11.23D09:45:45.295627000|homer|rdb|rdb1|INF|fileload|loading /home/torquser/newdeploy/deploy/TorQ/latest/config/settings/default.q\n2020.11.23D09:45:45.296164000|homer|rdb|rdb1|INF|fileload|successfully loaded /home/torquser/newdeploy/deploy/TorQ/latest/config/settings/default.q\n... snip ...\n2020.11.23D09:45:47.432583000|homer|rdb|rdb1|INF|setpartition|rdbpartition contains - 2020.11.23\n2020.11.23D09:45:47.432643000|homer|rdb|rdb1|INF|fileload|successfully loaded /home/torquser/newdeploy/deploy/TorQ/latest/code/processes/rdb.q\n2020.11.23D09:45:47.432670000|homer|rdb|rdb1|INF|init|Resetting .z.pi to kdb+ default value\n################################################################################\n#                                                                              #\n#                                 TorQ v3.8.0                                  #\n#                               Data Intellect                                 #\n#               We turn big data problems into smart data solutions            #\n#                                                                              #\n#      For questions, comments, requests or bug reports please contact us      #\n#                           w :     www.dataintellect.com                      #\n#                           e : torqsupport@dataintellect.com                  #\n#                                                                              #\n#                         Running on kdb+ 4 2020.06.18                         #\n#                                                                              #\n#                      TorQ Finance Starter Pack v 1.9.1                       #\n#                                                                              #\n################################################################################\nq)\n</code></pre>"},{"location":"cheatsheet/#deploying","title":"Deploying","text":"<p>Deployments should be very simple on Linux using the installation script. </p> <pre><code># pull in latest TorQ FSP install script \nwget https://raw.githubusercontent.com/DataIntellectTech/TorQ-Finance-Starter-Pack/master/installlatest.sh\n# execute it\nbash installlatest.sh \n# It will finish with a message like below:\n=============================================================\nINSTALLATION COMPLETE\n=============================================================\nInstallation is finished. For a regular installation, run it as follows in the working directory: ./deploy/bin/torq.sh start all\n# you may need to change the value of KDBBASEPORT held in deploy/bin/setenv.sh to avoid conflicts with other TorQ stacks if running on a shared host\n# once done execute start line and check it:\ntorquser@homer:/home/torquser/newdeploy$ ./deploy/bin/torq.sh start all\n08:28:02 | Starting discovery1...\n08:28:02 | Starting tickerplant1...\n... snip ...\n08:28:06 | Starting dqe1...\n08:28:06 | Starting dqedb1...\ntorquser@homer:/home/torquser/newdeploy$ ./deploy/bin/torq.sh summary\nTIME      |  PROCESS        |  STATUS  |  PID    |  PORT\n08:28:30  |  discovery1     |  up      |  23221  |  43101\n08:28:30  |  tickerplant1   |  up      |  23333  |  43100\n08:28:30  |  rdb1           |  up      |  23443  |  43102\n08:28:30  |  hdb1           |  up      |  23553  |  43103\n... snip ...\n</code></pre>"},{"location":"cheatsheet/#modifying-existing-installations","title":"Modifying Existing Installations","text":"<p>We always try to esnure new versions of TorQ are backwardly compatible. Try to avoid modifying TorQ itself and instead make application specific modifications. The installation script deploys TorQ in a structure which keeps TorQ and the application separate, and this should be adhered to whenever possible. </p> <p>To modify the config for a process, do it either in the config directory or as a command line start up parameter as- almost all config variables that are defined in a config file and exists in a non-root namespace can be overridden from the command line. </p> <p>To make a process load additional files, you can:</p> <ul> <li>append the additional files to the -load parameter on the start line</li> <li>append a set of directories of files using -loaddir on the start line</li> <li>place the files in one of the directories that is loaded by default on start up</li> </ul> <p>Start line modifications can be made in process.csv and will be picked up by torq.sh. Of these approaches, the latter is probably preferable. </p>"},{"location":"cheatsheet/#adding-custom-processes","title":"Adding Custom Processes","text":"<p>When adding custom processes to TorQ it is important to understand the significance of proctype. In a nutshell, only processes which do exactly the same thing should have the same proctype. If two processes do roughly the same thing then -parentproctype can be used to share common functionality. Also there isn't any formal association between proctype and code name file name e.g. a process that loads code/processes/rdb.q can have any proctype we like. </p> <p>How TorQ manages connections is important. Avoid using hopen, use TorQ connection management.</p> <p>TorQ uses the fail fast principle (if you are going to fail, may as well do it as quickly as possible). This helps avoid processes starting up in inconsistent or unexpected states. If running a process with the -debug option, add the -stop or -trap options to stop at, or trap and continue through, start up errors. </p> <p>Code is loaded in a specific order, which can be overridden. To determine the order, inspect the bottom of the torq.q script (the last 100 lines or so). Everything after the switch into the root namespace is relevant. </p>"},{"location":"conn/","title":"Connection Management","text":"<p>trackservers.q is used to register and maintain handles to external servers. It is a heavily modified version of trackservers.q from code.kx. All the options are described in the default config file. All connections are tracked in the .servers.SERVERS table. When the handle is used the count and last query time are updated.</p> <pre><code>q).servers.SERVERS \nprocname     proctype  hpup                            w  hits startp                        lastp                         endp                          attributes                   \n---------------------------------------------------------------------------------\ndiscovery1   discovery :aquaq:9996    0                                  2014.01.08D11:13:10.583056000                               ()!()                        \ndiscovery2   discovery :aquaq:9995 6  0    2014.01.07D16:44:47.175757000 2014.01.07D16:44:47.174408000                               ()!()                        \nrdb_europe_1 rdb       :aquaq:9998 12 0    2014.01.07D16:46:47.897910000 2014.01.07D16:46:47.892901000 2014.01.07D16:46:44.626293000 `datacentre`country!`essex`uk\nrdb1         rdb       :aquaq:5011 7  0    2014.01.07D16:44:47.180684000 2014.01.07D16:44:47.176994000                               `datacentre`country!`essex`uk\nrdb_europe_1 hdb       :aquaq:9997    0                                  2014.01.08D11:13:10.757801000                               ()!()                        \nhdb1         hdb       :aquaq:9999    0                                  2014.01.08D11:13:10.757801000                               ()!()                        \nhdb2         hdb       :aquaq:5013 8  0    2014.01.07D16:44:47.180684000 2014.01.07D16:44:47.176994000                               `datacentre`country!`essex`uk\nhdb1         hdb       :aquaq:5012 9  0    2014.01.07D16:44:47.180684000 2014.01.07D16:44:47.176994000                               `datacentre`country!`essex`uk\n\nq)last .servers.SERVERS \nprocname  | `hdb2\nproctype  | `hdb\nhpup      | `:aquaq:5013\nw         | 8i\nhits      | 0i\nstartp    | 2014.01.08D11:51:01.928045000\nlastp     | 2014.01.08D11:51:01.925078000\nendp      | 0Np\nattributes| `datacentre`country!`essex`uk\n</code></pre>"},{"location":"conn/#connections","title":"Connections","text":"<p>Processes locate other processes based on their process type. The location is done either statically using the process.csv file or dynamically using a discovery service. It is recommended to use the discovery service as it allows the process to be notified as new processes become available.</p> <p>The main configuration variable is .servers.CONNECTIONS, which dictates which process type(s) to create connections to. .servers.startup[] must be called to initialise the connections. When connections are closed, the connection table is automatically updated. The process can be set to periodically retry connections.</p>"},{"location":"conn/#process-attributes","title":"Process Attributes","text":"<p>Each process can report a set of attributes. When process A connects to process B, process A will try to retrieve the attributes of process B. The attributes are defined by the result of the .proc.getattributes function, which is by default an empty dictionary. Attributes are used to retrieve more detail about the capabilities of each process, rather than relying on the broad brush process type and process name categorization. Attributes can be used for intelligent query routing. Potential fields for attributes include:</p> <ul> <li> <p>range of data contained in the process;</p> </li> <li> <p>available tables;</p> </li> <li> <p>instrument universe;</p> </li> <li> <p>physical location;</p> </li> <li> <p>any other fields of relevance.</p> </li> </ul>"},{"location":"conn/#connection-passwords","title":"Connection Passwords","text":"<p>The password used by a process to connect to external processes is retrieved using the .servers.loadpassword function call. By default, this will read the password from a txt file contained in $KDBCONFIG/passwords. A default password can be used, which is overridden by one for the process type, which is itself overridden by one for the process name. For greater security, the .servers.loadpassword function should be modified.</p> <p>Some non-torq processes require a username and password to allow connection.  These will be stored in a passwords dictionary.  Passing the host and port of a process into this dictionary will return the full connection string  if it is present within the dictionary.  If however it is not present in the dictionary then the default username and password will be returned.</p>"},{"location":"conn/#retrieving-and-using-handles","title":"Retrieving and Using Handles","text":"<p>A function .servers.getservers is supplied to return a table of handle information. .servers.getservers takes five parameters:</p> <ul> <li> <p>type-or-name: whether the lookup is to be done by type or name (can     be either proctype or procname);</p> </li> <li> <p>types-or-names: the types or names to retrieve e.g. hdb;</p> </li> <li> <p>required-attributes: the dictionary of attributes to match on;</p> </li> <li> <p>open-dead-connections: whether to re-open dead connections;</p> </li> <li> <p>only-one: whether we only require one handle. So for example if 3       services of the supplied type are registered, and we have an open       handle to 1 of them, the open handle will be returned and the others       left closed irrespective of the open-dead-connections parameter.</p> </li> </ul> <p>.servers.getservers will compare the required parameters with the available parameters for each handle. The resulting table will have an extra column called attribmatch which can be used to determine how good a match the service is with the required attributes. attribmatch is a dictionary of (required attribute key) ! (Boolean full match; intersection of attributes).</p> <pre><code>q).servers.SERVERS \nprocname     proctype  hpup                            w hits startp                        lastp                         endp attributes                   \n---------------------------------------------------------------------------------\ndiscovery1   discovery :aquaq:9996   0                                  2014.01.08D11:51:01.922390000      ()!()                        \ndiscovery2   discovery :aquaq:9995 6 0    2014.01.08D11:51:01.923812000 2014.01.08D11:51:01.922390000      ()!()                        \nrdb_europe_1 rdb       :aquaq:9998   0                                  2014.01.08D11:51:38.347598000      ()!()                        \nrdb_europe_2 rdb       :aquaq:9997   0                                  2014.01.08D11:51:38.347598000      ()!()                        \nrdb1         rdb       :aquaq:5011 7 0    2014.01.08D11:51:01.928045000 2014.01.08D11:51:01.925078000      `datacentre`country!`essex`uk\nhdb3         hdb       :aquaq:5012 9 0    2014.01.08D11:51:38.349472000 2014.01.08D11:51:38.347598000      `datacentre`country!`essex`uk\nhdb2         hdb       :aquaq:5013 8 0    2014.01.08D11:51:01.928045000 2014.01.08D11:51:01.925078000      `datacentre`country!`essex`uk\n\n/- pull back hdbs.  Leave the attributes empty\nq).servers.getservers[`proctype;`hdb;()!();1b;0b] \nprocname proctype lastp                         w hpup        attributes                    attribmatch\n-------------------------------------------------------------------------------\nhdb3     hdb      2014.01.08D11:51:38.347598000 9 :aquaq:5012 `datacentre`country!`essex`uk ()!()      \nhdb2     hdb      2014.01.08D11:51:01.925078000 8 :aquaq:5013 `datacentre`country!`essex`uk ()!()\n\n/- supply some attributes\nq).servers.getservers[`proctype;`hdb;(enlist`country)!enlist`uk;1b;0b] \nprocname proctype lastp                         w hpup        attributes                    attribmatch           \n-------------------------------------------------------------------------------\nhdb3     hdb      2014.01.08D11:51:38.347598000 9 :aquaq:5012 `datacentre`country!`essex`uk (,`country)!,(1b;,`uk)\nhdb2     hdb      2014.01.08D11:51:01.925078000 8 :aquaq:5013 `datacentre`country!`essex`uk (,`country)!,(1b;,`uk)\nq).servers.getservers[`proctype;`hdb;`country`datacentre!`uk`slough;1b;0b]                                                                                                                                                                                                    \nprocname proctype lastp                         w hpup        attributes                    attribmatch                                    \n-------------------------------------------------------------------------------\nhdb3     hdb      2014.01.08D11:51:38.347598000 9 :aquaq:5012 `datacentre`country!`essex`uk `country`datacentre!((1b;,`uk);(0b;`symbol$()))\nhdb2     hdb      2014.01.08D11:51:01.925078000 8 :aquaq:5013 `datacentre`country!`essex`uk `country`datacentre!((1b;,`uk);(0b;`symbol$()))\n</code></pre> <p>.servers.getservers will try to automatically re-open connections if required.</p> <pre><code>q).servers.getservers[`proctype;`rdb;()!();1b;0b] \n2014.01.08D12:01:06.023146000|aquaq|gateway1|INF|conn|attempting to open handle to :aquaq:9998\n2014.01.08D12:01:06.023581000|aquaq|gateway1|INF|conn|connection to :aquaq:9998 failed: hop: Connection refused\n2014.01.08D12:01:06.023597000|aquaq|gateway1|INF|conn|attempting to open handle to :aquaq:9997\n2014.01.08D12:01:06.023872000|aquaq|gateway1|INF|conn|connection to :aquaq:9997 failed: hop: Connection refused\nprocname proctype lastp                         w hpup         attributes                    attribmatch\n-------------------------------------------------------------------------------\nrdb1     rdb      2014.01.08D11:51:01.925078000 7 :aquaq:5011 `datacentre`country!`essex`uk ()!()\n\n/- If we only require one connection, and we have one open,then it doesn't retry connections\nq).servers.getservers[`proctype;`rdb;()!();1b;1b] \nprocname proctype lastp                         w hpup        attributes                    attribmatch\n-------------------------------------------------------------------------------\nrdb1     rdb      2014.01.08D11:51:01.925078000 7 :aquaq:5011 `datacentre`country!`essex`uk ()!()\n</code></pre> <p>There are two other functions supplied for retrieving server details, both of which are based on .servers.getservers. .servers.gethandlebytype returns a single handle value, .servers.gethpupbytype returns a single host:port value. Both will re-open connections if there are not any valid connections. Both take two parameters:</p> <ul> <li> <p>types: the type to retrieve e.g. hdb;</p> </li> <li> <p>selection-algorithm: can be one of any, last or roundrobin.</p> </li> </ul>"},{"location":"conn/#connecting-to-non-torq-processes","title":"Connecting To Non-TorQ Processes","text":"<p>Connections to non-torq (external) processes can also be established. This is useful if you wish to integrate TorQ with an existing infrastructure. Any process can connect to external processes, or it can be managed by the discovery service only. Every external process should have a type and name in the same way as TorQ processes, to enable them to be located and used as required.</p> <p>Non-TorQ processes need to be listed by default in $KDBCONFIG/settings/nontorqprocess.csv. This file has the same format as the standard process.csv file. The location of the non-TorQ process file can be adjusted using the .servers.NONTORQPROCESSFILE variable. To enable connections, set .servers.TRACKNONTORQPROCESS to 1b.</p> <p>Example of nontorqprocess.csv file:</p> <pre><code>host,port,proctype,procname\naquaq,5533,hdb,extproc01\naquaq,5577,hdb,extproc02\n</code></pre>"},{"location":"conn/#manually-adding-and-using-connections","title":"Manually Adding And Using Connections","text":"<p>Connections can also be manually added and used. See .api.p\u201c.servers.*\u201d for details.</p>"},{"location":"conn/#ipc-types","title":"IPC types","text":"<p>In version kdb+ v3.4, two new IPC connection types were added. These new types are unix domain sockets and SSL/TLS (tcps). The incoming connections to a proctype can be set by updating .servers.SOCKETTYPE.</p> <p>In the settings example below, everything that connects to the tickerplant will use unix domain sockets.</p> <pre><code>\\d .servers \nSOCKETTYPE:enlist[`tickerplant]!enlist `unix\n</code></pre> <p>Attempting to open a unix domain socket connection to a process which has an older kdb+ version will fail. We allow for processes to fallback to tcp if this happens by setting .servers.SOCKETFALLBACK to true. It will not fallback if the connection error message returned is one of the following : timeout, access. It will also not fallback for SSL/TLS (tcps) due to security concerns.</p> <p>At the time of writing, using unix domain sockets syntax on windows will appear to work whilst it\u2019s actually falling back to tcp in the background. This can be misleading so we disabled using them on windows.</p>"},{"location":"dataaccess/","title":"Data Access API","text":""},{"location":"dataaccess/#introduction-and-key-features","title":"Introduction and Key Features","text":"<p>The Dataaccess API is a TorQ upgrade designed for seamless cross process data retrival.</p> <p>Other key upgrades of the API are: - Compatibility with non kdb+ processes such as Google BigQuery and qREST - Consistent queries across all processes - Data retrieval does not require q-SQL knowledge only q dictionary manipulation - User friendly interface including more comprehensible error messages - Queries are automatically optimised for each process - Thorough testing allowing ease of further development</p> <p>A more conceptual discussion of the API can be seen in this blog post</p>"},{"location":"dataaccess/#configuration","title":"Configuration","text":"<p>The API can be initialised in a TorQ process by either:</p> <p>1) Pass <code>\"-dataaccess /path/to/tableproperties.csv\"</code> on the startup line (see Example table properties file below for format) 2) Run <code>\".dataaccess.init[`:path/to/tableproperties.csv]\"</code> to initialise the code in a running process.</p> <p>In both cases the filepath should point to <code>tableproperties.csv</code> a <code>.csv</code> containing information about all the tables you want the API to query. The following table describes each of the columns of tableproperties.csv:</p>"},{"location":"dataaccess/#description-of-fields-in-tablepropertiescsv","title":"Description of fields in tableproperties.csv","text":"Field Description Default proctype Denotes the type of process the table is loaded in (passing <code>all</code> will involke default behaviour) procs in .gw.servers tablename Table to query  (Tables within namespaces are allowed) N/A primarytimecolumn Default timecolumn used to determine the partitioning of a process * attributecolumn Primary attribute column (see query optimisation) N/A instrumentcolumn Column containing instrument N/A rolltimeoffset Rollovertime offset from midnight .eodtime.rolltimeoffset rolltimezone Timezone of the Rollover Function .eodtime.rolltimezone datatimezone Timezone of the primary time column timestamps .eodtime.datatimezone partitionfield Partition field of the data <code>$[.Q.qp[];.Q.pf;`]</code> <p>* The Default behaviour of primarytimecolumn is:</p> <ol> <li>If the table is defined in the tickerplant schema file then primarytimecolumn is set to be the time column defined by the tickerplant.</li> <li>Else if a unique column of type z or p exists it is used. (If uniqueness isn't satisfied an error will occur here.)</li> <li>Else if a unique column of type d exist then it is used.</li> <li>Else the API will error.</li> </ol>"},{"location":"dataaccess/#example-default-configuration-file","title":"Example Default Configuration File","text":"<p>If the user wishes to use the TorQ FSP (see section below) the following example will suffice:</p> proctype tablename primarytimecolumn attributecolumn instrumentcolumn rolltimeoffset rolltimezone datatimezone partitionfield trade time sym sym quote time sym sym <p>This table will be configured as if it were the following</p> proctype tablename primarytimecolumn attributecolumn instrumentcolumn rolltimeoffset rolltimezone datatimezone partitionfield rdb trade time sym sym 00:00 GMT GMT hdb trade time sym sym 00:00 GMT GMT date rdb quote time sym sym 00:00 GMT GMT hdb quote time sym sym 00:00 GMT GMT date <p>A more complete explanation into the configuration can be seen in the Table Properties Configuration section.</p>"},{"location":"dataaccess/#usage","title":"Usage","text":"<p>When using the API to send queries direct to a process, the overarching function is <code>getdata</code>. <code>getdata</code> is a dynamic, lightweight function which takes in a uniform dictionary (see table below) and the above configuration to build a process bespoke query. Input consistency permits the user to disregard the pragmatics described in <code>tableproperties.csv</code> allowing <code>getdata</code> to be called either directly within a process or via <code>.dataccess.getdata</code> (discussed in the Gateway section).</p> <p>The <code>getdata</code> function is split into three sub functions:<code>.dataaccess.checkinputs</code>, <code>.eqp.extractqueryparams</code> and <code>queryorder.orderquery</code>.</p> <ul> <li><code>.dataaccess.checkinputs</code> checks if the input dictionary is valid (See custom API errors)</li> <li><code>.eqp.extractqueryparams</code> converts the arguments into q-SQL</li> <li><code>.queryorder.orderquery</code> is the API's query optimiser (See Debugging and Optimisation)</li> </ul> <p><code>getdata's</code> input takes the format of a dictionary who's keys represent attributes of a query and values that represent how these attributes are to look. Each of these parameter's in the input dictionary can map a very simplistic dictionary into queries that can become quite complex. The following table lists getdata's accepted arguments:</p>"},{"location":"dataaccess/#valid-inputs","title":"Valid Inputs","text":"Parameter Required Example** Invalidpairs* Description tablename Yes `quote Table to query starttime Yes 2020.12.18D12:00 Start time - must be a valid time type (see timecolumn) endtime Yes 2020.12.20D12:00 End time - must be a valid time type (see timecolumn) timecolumn No `time Column to apply(startime;endime) filter to instruments No `AAPL`GOOG Instruments to filter on - will usually have an attribute applied (see tableproperties.csv) columns No `sym`bid`ask`bsize`asize aggregations Table columns to return - symbol list - assumed all if not present grouping No `sym Columns to group by -  no grouping assumed if not present aggregations No `max`wavg!(`bidprice`askprice;(`asksize`askprice;`bidsize`bidprice)) columns|freeformcolumn dictionary of aggregations timebar No (10;`minute;`time) List of (bar size; time type;timegrouping column) valid types: `nanosecond`second`minute`hour`day) filters No `sym`bid`bsize!(enlist(like;\"AAPL\");((&lt;;85);(&gt;;83.5));enlist(not;within;5 43)) Dictionary of ordered filters to apply to keys of dictionary freeformwhere No \"sym=`AAPL, src=`BARX, price within 60 85\" Where clause in string format freeformby No \"sym:sym, source:src\" By clause in string format freeformcolumn No \"time, sym,mid\\:0.5*bid+ask\" aggregations Select clause in string format ordering No enlist(`desc`bidprice) List ordering results ascending or descending by column renamecolumn No `old1`old2`old3!`new1`new2`new3 Either a dictionary of old!new or list of column names postprocessing No {flip x} Post-processing of the data queryoptimisation No 0b Determines whether the query optimiser should be turned on/off, Default is 1b sublist No 42 Sublist getquery No 1b Runs <code>.dataaccess.buildquery</code> in each of the processes <p>* Invalid pairs are two dictionary keys not allowed to be defined simultaneously, this is done to prevent unexpected behaviour such as the following query:</p> <p><code>select price,mprice:max price from trade</code></p> <p>Although the above is a valid query the result may be unexpected as the column lengths don't match up.</p> <p>If an invalid key pair is desired the user should convert all inputs to the q-SQL version.</p> <p>** More complete examples are provided in the Examples section below</p> <p>Example function call</p> <pre><code>q)getdata`tablename`starttime`endtime`instruments`columns!(`quote;2021.01.20D0;2021.01.23D0;`GOOG;`sym`bid`bsize)\nsym  bid   bsize\n----------------\nGOOG 71.57 1\nGOOG 70.86 2\nGOOG 70.91 8\nGOOG 70.91 6\n...\n</code></pre> <p>From within a kdb+ process the <code>.dataaccess.buildquery</code> function provides the developer with an insight into the query that has been built for example:</p> <pre><code>q).dataaccess.buildquery `tablename`starttime`endtime`instruments`columns!(`quote;2021.01.20D0;2021.01.23D0;`GOOG;`sym`time`bid`bsize)\n? `quote ((=;`sym;,`GOOG);(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000)) 0b `sym`time`bid`bsize!`sym`time`bid`bsize\n\n</code></pre> <p>Alternatively, the <code>`getquery</code> key can also be used to produce an identical result:</p> <pre><code>q)getdata `tablename`starttime`endtime`instruments`columns`getquery!(`quote;2021.01.20D0;2021.01.23D0;`GOOG;`sym`time`bid`bsize;1b)\n? `quote ((=;`sym;,`GOOG);(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000)) 0b `sym`time`bid`bsize!`sym`time`bid`bsize\n\n</code></pre> <p>This method is preferable as it has been extended to work from within the gateway (see Gateway section) or another exotic process:</p> <pre><code>q).dataaccess.getdata `tablename`starttime`endtime`instruments`columns`getquery!(`quote;2021.01.20D0;.z.d+12:00;`GOOG;`sym`time`bid`bsize;1b)\n`rdb\n(?;`quote;((=;`sym;,`GOOG);(within;`time;2021.01.20D00:00:00.000000000 2021.03.16D12:00:00.000000000));0b;`sym`time`bid`bsize!`sym`time`bid`bsize)\n`hdb\n(?;`quote;((within;`date;2021.01.20 2021.03.17);(=;`sym;,`GOOG);(within;`time;2021.01.20D00:00:00.000000000 2021.03.16D12:00:00.000000000));0b;`sym`time`bid`bsize!`sym`time`bid`bsize)\n</code></pre>"},{"location":"dataaccess/#aggregations","title":"Aggregations","text":"<p>The aggregations key is a dictionary led method of perfoming mathematical operations on columns of a table. The dictionary should be of the form:</p> <p><code>`agg1`agg2`...`aggn!((`col11`col12...`col1a);(`col21`col22...`col2b);...;(`coln1`coln2...`colnm)</code></p> <p>Certain aggregations are cross process enabled, that is they can be calculated across multiple process (See example in the Gateway section). The key accepts the following table of inputs:</p> <p>Table of Avaliable Aggregations</p> Aggregation Description Example Cross Process Enabled (See Gateway) <code>avg</code> Return the mean of a list <code>(enlist`avg)!enlist enlist `price</code> No <code>cor</code> Return Pearson's Correlation coefficient of two lists <code>(enlist `cor)!enlist enlist `bid`ask</code> No <code>count</code> Return The length of a list <code>(enlist`count)!enlist enlist `price</code> Yes <code>cov</code> Return the covariance of a list pair <code>(enlist `cov)!enlist enlist `bid`ask</code> No <code>dev</code> Return the standard deviation of a list <code>(enlist`dev)!enlist enlist `price</code> No <code>distinct</code> Return distinct elements of a list <code>(enlist`distinct)!enlist enlist `sym</code> Yes <code>first</code> Return first element of a list <code>(enlist`first)!enlist enlist `price</code> Yes <code>last</code> Return the final value in a list <code>(enlist`last)!enlist enlist `price</code> Yes <code>max</code> Return the maximum value of a list <code>(enlist`max)!enlist enlist `price</code> Yes <code>med</code> Return the median value of a list <code>(enlist`med)!enlist enlist `price</code> No <code>min</code> Return the minimum value of a list <code>(enlist`min)!enlist enlist `price</code> Yes <code>prd</code> Return the product of a list <code>(enlist`prd)!enlist enlist `price</code> Yes <code>sum</code> Return the total of a list <code>(enlist`sum)!enlist enlist `price</code> No <code>var</code> Return the Variance of a list <code>(enlist`var)!enlist enlist `price</code> No <code>wavg</code> Return the weighted mean of two lists <code>(enlist`wavg)!enlist enlist `asize`ask</code> No <code>wsum</code> Return the weighted sum of two lists <code>(enlist`wsum)!enlist enlist `asize`ask</code> No <p>The postprocessing key provides a work around for creating these cross process aggregations (see the postprocessing example in Further Examples section).</p> <p>The following function can be used to merge two aggregation dictionaries:</p> <pre><code>q)f:{{(key x,y)!{:$[0=count raze x[z];y[z];$[2=count raze y[z];($[1=count x[z];raze x[z];x[z]];raze y[z]);raze x[z],raze y[z]]]}[x;y;] each key x,y}/[x]}\n</code></pre> <pre><code>q)A\nmin| price\nq)B\nmin| time\nq)C\nwavg| bid bsize\nq)f[(A;B;C)]\nmin | `price`time\nwavg| ,`bid`bsize\n</code></pre>"},{"location":"dataaccess/#filters","title":"Filters","text":"<p>The filters key is a dictionary led method of controlling which entries of a given table are being queried by setting out a criteria. The dictionary uses a table column as the key and the entries as the condition to be applied to that column. Any condition to be applied should be entered as a nest of two item lists for each condition and each sublist entered as an operator first followed by conditional values, for example:</p> <p><code>`col1`col2`...`coln!((op;cond);((op;cond);(op;cond));...;(op;cond)</code></p> <p>For negative conditionals, the not and ~: operators can be included as the first item of a three item list for the operators in, like and within, e.g.</p> <p><code>enlist`col1!enlist(not;within;`cond1`cond2)</code></p> <p>Table of Available Filters</p> Operator Description Example <code>&lt;</code> less than <code>(enlist`col)!enlist(&lt;;input)</code> <code>&gt;</code> greater than <code>(enlist`col)!enlist(&gt;;input)</code> <code>&lt;&gt;</code> not equal <code>(enlist`col)!enlist(&lt;&gt;;input)</code> <code>&lt;=</code> less than or equal to <code>(enlist`col)!enlist(&lt;=;input)</code> <code>&gt;=</code> greater than or equal to <code>(enlist`col)!enlist(&gt;=;input)</code> <code>=</code> equal to <code>(enlist`col)!enlist(=;input)</code> <code>~</code> match/comparison <code>(enlist`col)!enlist(~;input)</code> <code>in</code> column value is an item of input list <code>(enlist`col)!enlist(in;input)</code> <code>within</code> column value is within bounds of two inputs <code>(enlist`col)!enlist(within;input)</code> <code>like</code> column symbol or string matches input string pattern <code>(enlist`col)!enlist(like;input)</code> <code>not</code> negative conditional when used with in,like or within <code>(enlist`col)!enlist(not;in/like/within;input)</code>"},{"location":"dataaccess/#gateway","title":"Gateway","text":"<p>The documentation for the gateway outside the API can be found here</p> <p>Accepting a uniform dictionary allows queries to be sent to the gateway using <code>.dataaccess.getdata</code>. Using <code>.dataaccess.getdata</code> allows the user to</p> <ul> <li>Leverage the checkinputs library from within the gateway and catch errors before they hit the process</li> <li>Uses <code>.gw.servers</code> to dynamically determine the appropriate processes to execute <code>getdata</code> in</li> <li>Determines the query type to send to the process(es)</li> <li>Provide further optional arguments to better determine the behaviour of the function see table below:</li> </ul> <p>Gateway Accepted Keys</p> Input Key Example Default behaviour Description postback <code>{0N!x}</code> () Post back function for retuning async queries only join <code>raze</code> <code>.dataaccess.multiprocjoin</code> Join function to merge the tables timeout <code>00:00:03</code> 0Wn Maximum time for query to run procs <code>`rdb`hdb</code> <code>.dataaccess.attributesrouting</code> Choose which processes to run <code>getdata</code> in * <p>* By default, <code>.dataaccess.forceservers</code> is set to <code>0b</code>. In this case, only a subset of <code>.dataaccess.attributesrouting</code> can be used. However, if <code>.dataaccess.forceservers</code> is set to <code>1b</code> any server in <code>.gw.servers</code> can be used.</p> <p>One major benefit of using <code>.dataaccess.getdata</code> can be seen when performing aggregations across different processes. An example of this can be seen below, where the user gets the max/min of bid/ask across both the RDB and HDB.</p> <pre><code>q)querydict:`tablename`starttime`endtime`aggregations!(`quote;2021.02.08D00:00:00.000000000;2021.02.09D09:00:00.000000000;`max`min!(`ask`bid;`ask`bid))\nq)querydicttoday:`tablename`starttime`endtime`aggregations!(`quote;2021.02.09D00:00:00.000000000;2021.02.09D09:00:00.000000000;`max`min!(`ask`bid;`ask`bid))\nq)querydictyesterday:`tablename`starttime`endtime`aggregations!(`quote;2021.02.09D00:00:00.000000000;2021.02.09D09:00:00.000000000;`max`min!(`ask`bid;`ask`bid))\n\n// open connection to the gateway g\nq)g:hopen`::1234:admin:admin\n\nq)g(`.dataaccess.getdata;querydict)\nmaxAsk maxBid minAsk minBid\n---------------------------\n214.41 213.49 8.43   7.43\nq)g(`.dataaccess.getdata;querydictyesterday)\nmaxAsk maxBid minAsk minBid\n---------------------------\n214.41 213.49 8.8    7.82\nq)g(`.dataaccess.getdata;querydicttoday)\nmaxAsk maxBid minAsk minBid\n---------------------------\n94.81  93.82  8.43   7.43\n</code></pre> <p>The cross process aggregations also work with groupings and freeformby keys, for example</p> <pre><code>q)querydict1:`tablename`starttime`endtime`freeformby`aggregations`ordering`sublist!(`quote;2021.03.16D01:00:00.000000000;2021.03.17D18:00:00.000000000;\"sym\";`max`min!(`ask`bid;`ask`bid);`desc`maxAsk;-2)\nq)g(`.dataaccess.getdata;querydict1)\nsym | maxAsk maxBid minAsk minBid\n----| ---------------------------\nDELL| 29.37  28.33  7.87   6.84\nDOW | 24.52  23.48  2.56   1.55\n</code></pre> <p>Such behaviour is not demonstrated when using freeform queries, for example:</p> <pre><code>q)querydict2:`tablename`starttime`endtime`freeformcolumn!(`quote;2021.02.08D00:00:00.000000000;2021.02.09D09:00:00.000000000;\"max ask,min ask,max bid, min bid\")\nq)g(`.dataaccess.getdata;querydict2)\nask    bid    ask1 bid1\n-----------------------\n214.41 213.49 8.8  7.82\n94.81  93.82  8.43 7.43\n</code></pre> <p>Updates to the dataaccess gateway code sees an ability to perform all map-reducable aggregations (except median) currently available to be performed over multiple processes without the need for a grouping based upon the partitioning field. The gateway now collects all the appropriate aggregates needed to calculate a value, and then re-aggregates the collected data based upon groupings when brought back to the gateway process. For complete clarity the full list of aggregations that can span multiple processes without a partitioned grouping are as follows: <code>avg</code>, <code>cor</code>, <code>count</code>, <code>cov</code>, <code>dev</code>, <code>first</code>, <code>last</code>, <code>max</code>, <code>min</code>, <code>prd</code>, <code>sum</code>, <code>var</code>, <code>wavg</code> and <code>wsum</code>.</p>"},{"location":"dataaccess/#checkinputs","title":"Checkinputs","text":"<p>A key goal of the API is to prevent unwanted behaviour and return helpful error messages- this is done by  <code>.dataaccess.checkinputs</code>. which under the covers runs two different checking libraries:</p> <ul> <li><code>.checkinputs</code> A set of universal basic input checks as defined in <code>checkinputs.csv</code> (example <code>.csv</code> below). These checks are performed from within the gateway if applicable.</li> <li><code>.dataaccess</code>  A set of process bespoke checks, performed from within the queried process.</li> </ul> <p>Description of Fields in checkinputs.csv</p> Field Description parameter Dictionary key to pass to <code>getdata</code> required Whether this parameter is mandatory checkfunction Function to determine whether the given value is valid invalid pairs Whether a parameter is invalid in combination with some other parameter <p>Example <code>checkinputs.csv</code></p> parameter required checkfunction invalidpairs description tablename 1 .checkinputs.checktable table to query starttime 1 .checkinputs.checktimetype starttime - see timecolumn endtime 1 .checkinputs.checkendtime endtime - see timecolumn timecolumn 0 .checkinputs.checktimecolumn column to apply (startime;endime) filter to instruments 0 .checkinputs.checkinstruments instruments of interest - see tableproperties.csv columns 0 .checkinputs.checkcolumns table columns to return - assumed all if not present grouping 0 .checkinputs.checkgrouping columns to group by -  no grouping assumed if not present aggregations 0 .checkinputs.checkaggregations columns freeformcolumn timebar 0 .checkinputs.checktimebar list of (time column to group on;size;type - `nanosecond`second`minute`hour`day) filters 0 .checkinputs.checkfilters a dictionary of columns + conditions in string format ordering 0 .checkinputs.checkordering a list of pairs regarding the direction (`asc or `desc) of ordering and a column to order freeformwhere 0 .checkinputs.isstring where clause in string format freeformby 0 .checkinputs.isstring by clause in string format freeformcolumn 0 .checkinputs.isstring select clause in string format instrumentcolumn 0 .checkinputs.checkinstrumentcolumn column to select instrument parameter from renamecolumn 0 .checkinputs.checkrenamecolumn dictionary to rename a column in results postprocessing 0 .checkinputs.checkpostprocessing applies postback lambda functions to data join 0 .checkinputs.checkjoin Joins queries together postback 0 .checkinputs.checkpostback sends async queries back timeout 0 .checkinputs.checktimeout Checks the time of the timeout sublist 0 .checkinputs.checksublist checks the head parameter procs 0 .checkinputs.checkprocs Checks the procs is the correct servers sqlquery 0 .checkinputs.isstring Select clause in string format getquery 0 .checkinputs.isboolean Returns the queries in each of the process dryrun 0 .checkinputs.isboolean Calculates the number of MB processed firstlastsort 0 .checkinputs.checkinstrumentcolumn Allows for use of firstlastsort (not supported by dataaccess) optimisation 0 .checkinputs.isboolean Toggle optimastion in queryorder <p>The csv file enables developers simple extension, modification or deletion of the accepted inputs.</p> <p>For example if the user want to add a key <code>`docs</code> which accepts a boolean input they would add the following line to <code>checkinputs.csv</code></p> <p>docs|0|.checkinputs.isboolean||info about docs function|</p> <p>Furthermore, using the <code>.checkinputs.isboolean</code> function would provide the user with a more comprehesive error message than <code>'type</code> see messages below.</p>"},{"location":"dataaccess/#custom-api-errors","title":"Custom API Errors","text":"<p>Below is a list of all the errors the API will return: Error|Function|Library| |-----|---------|-------------| |Table:{tablename} doesn't exist|checktablename|dataaccess| |Column(s) {badcol} presented in {parameter} is not a valid column for {tab}|checkcolumns|dataaccess| | If the distinct function is used, it cannot be present with any other aggregations including more of itself|checkaggregations|dataaccess| | Aggregations dictionary contains undefined function(s)|checkaggregations|dataaccess| | Incorrect number of input(s) entred for the following aggregations|checkaggregations|dataaccess| | Aggregations parameter must be supplied in order to perform group by statements|checkaggregations|dataaccess| | In order to use a grouping parameter, only aggregations that return single values may be used|checkaggregations|dataaccess| | The inputted size of the timebar argument: {size}, is not an appropriate size. Appropriate sizes are:|checktimebar|dataaccess| | Timebar parameter's intervals are too small. Time-bucket intervals must be greater than (or equal to) one nanosecond|checktimebar|dataaccess| |Input dictionary must have keys of type 11h|checkdictionary|checkinputs| |Required parameters missing:{}|checkdictionary|checkinputs| |Invalid parameter present:{}|checkdictionary|checkinputs| |Input must be a dictionary|isdictionary|checkinputs| |Parameter:{parameter} cannot be used in conjunction with parameter(s):{invalidpairs}|checkeachpair|checkinputs| |{} parameter(s) used more than once|checkrepeatparams|checkinputs| |Starttime parameter must be &lt;= endtime parameter|checktimeorder|checkinputs| |Aggregations parameter key must be of type 11h - example:|checkaggregations|checkinputs| |Aggregations parameter values must be of type symbol - example:|checkaggregations|checkinputs| |First argument of timebar must be either -6h or -7h|checktimebar|checkinputs| |Second argument of timebar must be of type -11h|checktimebar|checkinputs| |Third argument of timebar must be have type -11h|checktimebar|checkinputs| |Filters parameter key must be of type 11h - example:|checkfilters|checkinputs| |Filters parameter values must be paired in the form (filter function;value(s)) or a list of three of the form (not;filter function;value(s)) - example:|checkfilters|checkinputs| |Filters parameter values containing three elements must have the first element being the not keyword - example|checkfilters|checkinputs| |Allowed operators are: =, &lt;, &gt;, &lt;=, &gt;=, in, within, like. The last three may be preceeded with 'not' e.g. (not within;80 100)|checkfilters|checkinputs| |The 'not' keyword may only preceed the operators within, in and like.|checkfilters|checkinputs| |(not)within statements within the filter parameter must contain exatly two values associated with it - example:|withincheck|checkinputs| |The use of inequalities in the filter parameter warrants only one value|inequalitycheck|checkinputs| |The use of equalities in the filter parameter warrants only one value - example:|inequalitycheck|checkinputs| |Ordering parameter must contain pairs of symbols as its input - example:|checkordering|checkinputs| |Ordering parameter's values must be paired in the form (direction;column) - example:|checkordering|checkinputs| |The first item in each of the ordering parameter's pairs must be either `asc or `desc - example:|checkordering|checkinputs| |Ordering parameter vague. Ordering by a column that aggregated more than once|checkordering|checkinputs| |Ordering parameter contains column that is not defined by aggregations, grouping or timebar parameter|checkordering|checkinputs|</p>"},{"location":"dataaccess/#table-properties-configuration","title":"Table Properties Configuration","text":"<p>Although the default configuration is often the best, there are examples when the user will have to define there own <code>tableproperties.csv</code> file. This will happen whenever a process has tables spanning timezones or a table has two columns of type p. We provide a complete example for clearer explanation:</p> <p>Suppose a vanilla TorQ process has two tables trade and quote for a New York FX market (timezone ET).</p> <p>In our scenario the TorQ system is GMT based and the rollover times are as follows: - trade rolls over at midnight GMT - quote rolls over at 01:00 am New York time (ET)</p> <p>The meta for tables in the hdb are:</p> <pre><code>q)meta trade\nc    | t f a\n-----| -----\ndate | d\ntime | p\nsym  | s   p\nprice| f\nsize | i\nstop | b\ncond | c\nex   | c\nside | s\n\nq)meta quote\nc     | t f a\n------| -----\ndate  | d\ntime  | p\nextime| p\nsym   | s   p\nbid   | f\nask   | f\nbsize | j\nasize | j\nmode  | c\nex    | c\nsrc   | s\n\n</code></pre> <p>Determining the correct primary time column for the trade table is simple as time is the unique column with of type p.</p> <p>The quote table is more complicated as it has two time columns extime and time. - The extime column is the time when the trade was made - The time column is the time when the data entered the tickerplant</p> <p>The time column is the most illuminating into the partition structure.</p> <p>The reason extime is not the primary time column is due to the latency between the exchange and TorQ process. Suppose the latency from the feed to tickerplant was a consistent 200ms. Now consider the following quote</p> <ul> <li>Quote1 comes into the exchange at 2020.02.02D00:59:59.900000000(ET)</li> <li>Quote1 comes into the tickerplant at 2020.02.03D06:00:00.100000000(GMT)</li> <li>Quote1 will be in partition 2020.02.03</li> </ul> <p>As such the partitioning structure is dependent on the time column not the extime column.</p> <p>The p attribute on the sym column shows why it should be used as the attribute column.</p> <p>For this example the following <code>tableproperties.csv</code> should be defined.</p> proctype tablename primarytimecolumn attributecolumn instrumentcolumn rolltimeoffset rolltimezone datatimezone partitionfield rdb trade time sym sym 00:00 GMT GMT hdb trade time sym sym 00:00 GMT GMT date rdb quote time sym sym 01:00 ET GMT hdb quote time sym sym 01:00 ET GMT date"},{"location":"dataaccess/#query-optimisation","title":"Query Optimisation","text":"<p>The queries are automatically optimised using <code>.queryorder.orderquery</code> this function is designed to improve the performance of certain queries as well as return intuative results. This is done by:</p> <ul> <li>Prioritising filters against the primary attribute column in tableproperties.csv</li> <li>Swapping in for multiple = statements and razing the result together</li> </ul> <p>Furthermore, columns are ordered to put date then sym columns to the left.</p> <p>Optimisation can be toggled off by setting the value of <code>`queryoptimisation</code> in the input dictionary to <code>0b</code>.</p>"},{"location":"dataaccess/#debugging-and-optimisation","title":"Debugging and Optimisation","text":"<p>A key focus of the API is to improve accessibility whilst maintaining a strong performance. There are cases where the accessibilty impedes the usabilty or the query speed drops below what could be developed. In these situations one should ensure:</p> <ol> <li>The user has a filter against a table attributes</li> <li>The query only pulls in the essential data</li> <li>The output of <code>dataaccess.buildquery</code> is what is expected.</li> </ol>"},{"location":"dataaccess/#metrics","title":"Metrics","text":""},{"location":"dataaccess/#introduction","title":"Introduction","text":"<p>A test was performed to determine the performance of:</p> <ul> <li>The <code>getdata</code> function with optimisation on</li> <li>The <code>getdata</code> function with optimisation off</li> <li>Raw kdb+ query</li> </ul>"},{"location":"dataaccess/#methodology","title":"Methodology","text":"<p>Each query was run against 10/100/1000 sym TorQ stack each with a 5GB HDB (68 million rows over 22 partitions) and a 120 MB RDB (2 million rows) quotes table.</p>"},{"location":"dataaccess/#query-list","title":"Query List","text":"Queryname Call Optimised1 <code>`tablename`starttime`endtime`freeformby`aggregations`freeformwhere)!(`quote;00:00+2020.12.17D10;.z.d+12:00;\\\"sym\\\";(`max`min)!((`ask`bid);(`ask`bid));\\\"sym in `AMD`HPQ`DOW`MSFT`AIG`IBM</code> kdb1 <code>select max ask,min bid,max bid,min ask by sym from quote where sym in `AMD`HPQ`DOW`MSFT`AIG`IBM</code> Optimised2 <code>(`tablename`starttime`endtime`aggregations`timebar)!(`quote;2021.02.23D1;.z.p;(enlist(`max))!enlist(enlist(`ask));(6;`hour;`time))</code> kdb2 <code>select max ask by 21600000000000 xbar time from quote where time&gt;2021.02.23</code> Optimised3 <code>(`tablename`starttime`endtime`filters!(`quote;2021.01.20D0;2021.02.25D12;`bsize`sym`bid!(enlist(not;within;5 43);enlist(like;\\\"*OW\\\");((&lt;;85);(&gt;;83.5)))))</code> kdb3 <code>select from quote where bid within(83.5;85),not bsize within(5;43),sym like \"*OW\"</code>"},{"location":"dataaccess/#results","title":"Results","text":"<p>The results show the average execution time in ms for each query</p> Queryname 10 syms 100 syms 1000 syms Optimised1 17 53 22 Unoptimised1 8 58 17 kdb1 27 50 19 Optimised2 365 220 327 Unoptimised2 320 224 649 kdb2 404 362 488 Optimised3 291 153 145 Unoptimised3 283 360 391 kdb3 344 392 413"},{"location":"dataaccess/#discussion","title":"Discussion","text":"<ul> <li>Case 1 - Limited difference amongst all three queries, this occurs whenever a query can't be optimised or the dataset is too small for a change to be noticed.</li> <li>Case 2 - The API's strong all round performance, this occurs whenever a kdb+ query doesn't use the semantics of a process</li> <li>Case 3 - Demonstrates the performance boost of the API's optimiser, this occurs whenever a kdb+ query is not optimised</li> </ul>"},{"location":"dataaccess/#testing-library","title":"Testing Library","text":"<p>Each subfunction of <code>getdata</code> has thorough tests found in <code>${KDBTESTS}/dataaccess/</code>. To run the tests:</p> <ol> <li>Set environment variables</li> <li>Ensure your TorQ stack is not running</li> <li>Navigate to the appropriate testing directory</li> <li>Run <code>. run.sh -d</code></li> </ol>"},{"location":"dataaccess/#logging","title":"Logging","text":"<p>Upon calling either <code>.dataaccess.getdata</code> or <code>getdata</code> the corresponding user, startime, endtime, handle, success and any error messages are upserted to the <code>.dataaccess.stats</code> table for example when a good and bad query are sent to the gateway:</p> <pre><code>// Good gateway query\nq)g\".dataaccess.getdata`tablename`starttime`endtime`aggregations`grouping!(`quote;2021.02.12D0;.z.p;((enlist `max)!enlist `ask`bid);`sym)\"\nsym | maxAsk maxBid\n----| -------------\nAAPL| 246.33 245.26\nAIG | 85.07  84\n...\n// Bad gateway query\nq)g\".dataaccess.getdata`tablename`starttime`endtime`aggregations`grouping!(`quote;2021.02.12D0;15;((enlist `max)!enlist `ask`bid);`sym)\"\n'`endtime input type incorrect - valid type(s):-12 -14 -15h - input type:-7h\n  [0]  g\".dataaccess.getdata`tablename`starttime`endtime`aggregations`grouping!(`quote;2021.02.12D0;15;((enlist `max)!enlist `ask`bid);`sym)\"\n       ^\n</code></pre> <p>The following are the gateway and rdb logs:</p> <pre><code>// The logging in the gateway returns\n\nq)g\".dataaccess.stats\"\nquerynumber| user  starttime                     endtime                       handle request                                                                                                                                        success error\n-----------| -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n1          | admin 2021.03.25D14:52:03.380485000 2021.03.25D14:52:04.138481000 11     `tablename`starttime`endtime`aggregations`grouping!(`quote;2021.02.12D00:00:00.000000000;2021.03.25D14:52:03.380478000;(,`max)!,`ask`bid;`sym) 1\n2          | admin 2021.03.25D14:52:20.546227000 2021.03.25D14:52:20.546341000 11     `tablename`starttime`endtime`aggregations`grouping!(`quote;2021.02.12D00:00:00.000000000;15;(,`max)!,`ask`bid;`sym)                            0       `endtime input type incorrect - valid type(s):-12 -14 -15h - input type:-7h\n\n// The bad query errored out in the gateway, consequently only the good query is seen in the rdb logs\nq)g\".dataaccess.stats\"\nquerynumber| user    starttime                     endtime                       handle request                                                                                                                                                                          success error\n-----------| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n1          | gateway 2021.03.25D14:52:03.381980000 2021.03.25D14:52:03.407870000 10     `tablename`starttime`endtime`aggregations`grouping`checksperformed`procs!(`quote;2021.02.12D00:00:00.000000000;2021.03.25D14:52:03.380478000;(,`max)!,`ask`bid;`sym;1b;`hdb`rdb) 1\n\n</code></pre> <p>Logging can be toggled off from within a process by setting the value of <code>.dataaccess.logging</code> to <code>0b</code>.</p>"},{"location":"dataaccess/#further-integration","title":"Further Integration","text":"<p>This section describes the remaining features of the API as well as how the API can be leveraged to work with other Data Intellect technologies.</p>"},{"location":"dataaccess/#implementation-with-torq-fsp","title":"Implementation with TorQ FSP","text":"<p>The API is compatible with the most recent TorQ Finance-Starter-Package, the fastest way to import the API is opening <code>{APPCONFIG}/processes.csv</code> and adding the following flag <code>-dataaccess ${KDBCONFIG}/dataaccess/tableproperties.csv</code> to the <code>rdb</code>, <code>hdb</code> and <code>gateway</code> extras column. For example:</p> <pre><code>host,port,proctype,procname,U,localtime,g,T,w,load,startwithall,extras,qcmd\nlocalhost,{KDBBASEPORT}+2,rdb,rdb1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,-dataaccess ${KDBCONFIG}/dataaccess/tableproperties.csv ,q\nlocalhost,{KDBBASEPORT}+3,hdb,hdb1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,60,4000,${KDBHDB},1,-dataaccess ${KDBCONFIG}/dataaccess/tableproperties.csv,q\nlocalhost,{KDBBASEPORT}+4,hdb,hdb2,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,60,4000,${KDBHDB},1,,q\nlocalhost,{KDBBASEPORT}+7,gateway,gateway1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,,4000,${KDBCODE}/processes/gateway.q,1,-dataaccess ${KDBCONFIG}/dataaccess/tableproperties.csv,q\n</code></pre>"},{"location":"dataaccess/#implementation-with-q-rest","title":"Implementation with q-REST","text":"<p>The API is compatible with q-REST. To do this:</p> <ol> <li>Download q-REST</li> <li>Open <code>application.properties</code> and point <code>kdb.host/port</code> to the gateway</li> <li>Use the execute function argument to send <code>.json</code>s of the form:</li> </ol> <pre><code>{\n\"function_name\": \".dataaccess.qrest\",\n\"arguments\":{\n\"tablename\":\"quote\",\n\"starttime\":\"2021.02.17D10:00:00.000000000\",\n\"endtime\":\"2021.02.18D12:00:00.000000000\",\n\"freeformby\":\"sym\",\n\"aggregations\":\" `max`min!(`ask`bid;`ask)\",\n\"filters\":\"`sym`bid`bsize!(enlist(like;'*PL');((&lt;;85);(&gt;;83.5));enlist(~:;within;5 43))\"\n}\n}\n</code></pre> <p>q-REST requires some modifications to the input dictionary:</p> <ol> <li>All dictionary values must be in string format</li> <li>Nested quotion marks are not permitted (Even when escaped out using <code>\\\"</code>)</li> <li>The second argument in a <code>like</code> filter should be have ' rather than \" e.g <code>(like; 'AMD')</code></li> </ol>"},{"location":"dataaccess/#implementation-with-google-bigquery","title":"Implementation with Google BigQuery","text":"<p>As key goal of the API has been TorQ's integration with other SQL databases such as Google BigQuery the successful outcome is discussed in this blog.</p>"},{"location":"dataaccess/#further-examples","title":"Further Examples","text":"<p>For every key in the dictionary the following examples provide a query, output and the functional select executed from within the process.</p>"},{"location":"dataaccess/#time-default","title":"Time default","text":"<p>If the time column isn't specified it defaults to the value of <code>`primaryattributecolumn</code></p> <pre><code>q)getdata`tablename`starttime`endtime!(`quote;2021.01.20D0;2021.01.23D0)\ndate       time                          sym  bid   ask   bsize asize mode ex src\n----------------------------------------------------------------------------------\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 84.01 84.87 77    33    A    N  BARX\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.1  84.52 58    84    Y    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.3  84.63 76    28    I    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.58 84.93 13    89    Y    N  SUN\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.96 84.24 50    73    Y    N  DB\n\n...\n.dataaccess.buildquery `tablename`starttime`endtime!(`quote;2021.01.20D0;2021.01.23D0)\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) 0b ()\n</code></pre>"},{"location":"dataaccess/#instrument-filter","title":"Instrument Filter","text":"<p>Use the <code>`instruments</code> parameter to filter for <code>sym=`AAPL</code></p> <pre><code>q)getdata`tablename`starttime`endtime`instruments!(`quote;2021.01.20D0;2021.01.23D0;`AAPL)\ndate       time                          sym  bid   ask   bsize asize mode ex src\n----------------------------------------------------------------------------------\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 84.01 84.87 77    33    A    N  BARX\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.1  84.52 58    84    Y    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.3  84.63 76    28    I    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.58 84.93 13    89    Y    N  SUN\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.96 84.24 50    73    Y    N  DB\n..\n...\nq).dataaccess.buildquery `tablename`starttime`endtime`instruments!(`quote;2021.01.20D0;2021.01.23D0;`AAPL)\n? `quote ((=;`sym;,`AAPL);(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000)) 0b ()\n</code></pre>"},{"location":"dataaccess/#columns","title":"Columns","text":"<p>Use the <code>`columns</code> parameter to extract the following columns - <code>`sym`time`bid</code></p> <pre><code>q)getdata`tablename`starttime`endtime`columns!(`quote;2021.01.20D0;2021.01.23D0;`sym`time`bid)\nsym  time                          bid\n----------------------------------------\nAAPL 2021.01.21D13:36:45.714478000 84.01\nAAPL 2021.01.21D13:36:45.714478000 83.1\nAAPL 2021.01.21D13:36:45.714478000 83.3\nAAPL 2021.01.21D13:36:45.714478000 83.58\nAAPL 2021.01.21D13:36:46.113465000 83.96\n\n...\nq).dataaccess.buildquery `tablename`starttime`endtime`columns!(`quote;2021.01.20D0;2021.01.23D0;`sym`time`bid)\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) 0b `sym`time`bid!`sym`time`bid\n\n</code></pre>"},{"location":"dataaccess/#free-form-select","title":"Free form select","text":"<p>Run a free form select using the <code>`freeformcolumn</code> parameter</p> <pre><code>q)getdata`tablename`starttime`endtime`freeformcolumn!(`quote;2021.01.20D0;2021.01.23D0;\"sym,time,mid:0.5*bid+ask\")\nsym  time                          mid\n-----------------------------------------\nAAPL 2021.01.21D13:36:45.714478000 84.44\nAAPL 2021.01.21D13:36:45.714478000 83.81\nAAPL 2021.01.21D13:36:45.714478000 83.965\nAAPL 2021.01.21D13:36:45.714478000 84.255\nAAPL 2021.01.21D13:36:46.113465000 84.1\n\n...\nq).dataaccess.buildquery `tablename`starttime`endtime`freeformcolumn!(`quote;2021.01.20D0;2021.01.23D0;\"sym,time,mid:0.5*bid+ask\")\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) 0b `sym`time`mid!(`sym;`time;(*;0.5;(+;`bid;`ask)))\n</code></pre> <p>This can be used in conjunction with the <code>columns</code> parameter, however the <code>columns</code> parameters will be returned first. It is advised to use the <code>columns</code> parameter for returning existing columns and the <code>freeformcolumn</code> for any derived columns.</p>"},{"location":"dataaccess/#grouping","title":"Grouping","text":"<p>Use <code>`grouping</code> parameter to group average <code>`mid</code>, by <code>`sym</code></p> <pre><code>getdata`tablename`starttime`endtime`freeformcolumn`grouping!(`quote;2021.01.20D0;2021.01.23D0;\"avgmid:avg 0.5*bid+ask\";`sym)\nsym | avgmid\n----| --------\nAAPL| 70.63876\nAIG | 31.37041\nAMD | 36.46488\nDELL| 8.34496\nDOW | 22.8436\n\nq).dataaccess.buildquery `tablename`starttime`endtime`freeformcolumn`grouping!(`quote;2021.01.20D0;2021.01.23D0;\"avgmid:avg 0.5*bid+ask\";`sym)\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) (,`sym)!,`sym (,`avgmid)!,(avg;(*;0.5;(+;`bid;`ask)))\n</code></pre>"},{"location":"dataaccess/#string-style-grouping","title":"String style grouping","text":"<p>Group average <code>`mid</code>, by <code>instru:sym</code> using the <code>`freeformby</code> parameter</p> <pre><code>q)getdata`tablename`starttime`endtime`freeformcolumn`freeformby!(`quote;2021.01.20D0;2021.01.23D0;\"avgmid:avg 0.5*bid+ask\";\"sym\")\ninstr| avgmid\n-----| --------\nAAPL | 70.63876\nAIG  | 31.37041\nAMD  | 36.46488\nDELL | 8.34496\nDOW  | 22.8436\n\nq).dataaccess.buildquery `tablename`starttime`endtime`freeformcolumn`freeformby!(`quote;2021.01.20D0;2021.01.23D0;\"avgmid:avg 0.5*bid+ask\";\"sym\")\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) (,`sym)!,`sym (,`avgmid)!,(avg;(*;0.5;(+;`bid;`ask)))\n\n</code></pre>"},{"location":"dataaccess/#time-bucket","title":"Time bucket","text":"<p>Group max ask by  6 hour buckets using the <code>`timebar</code> parameter</p> <pre><code>q)getdata(`tablename`starttime`endtime`aggregations`instruments`timebar)!(`quote;2021.01.21D1;2021.01.28D23;(enlist(`max))!enlist(enlist(`ask));`AAPL;(6;`hour;`time))\ntime                         | maxAsk\n-----------------------------| ------\n2021.01.21D12:00:00.000000000| 98.99\n2021.01.21D18:00:00.000000000| 73.28\n2021.01.22D12:00:00.000000000| 97.16\n2021.01.22D18:00:00.000000000| 92.58\n...\nq).dataaccess.buildquery (`tablename`starttime`endtime`aggregations`instruments`timebar)!(`quote;2021.01.21D1;2021.01.28D23;(enlist(`max))!enlist(enlist(`ask));`AAPL;(6;`hour;`time))\n? `quote ((=;`sym;,`AAPL);(within;`time;2021.01.21D01:00:00.000000000 2021.01.28D23:00:00.000000000)) (,`time)!,({[timebucket;x]\n  typ:type x;\n  if[typ~12h;:timebucket xbar x];\n  if[typ in 13 14h;:..\n\n</code></pre>"},{"location":"dataaccess/#aggregations_1","title":"Aggregations","text":"<p>Max of both <code>`bidprice</code> and <code>`askprice</code></p> <pre><code>q)getdata`tablename`starttime`endtime`aggregations!(`quote;2021.01.20D0;2021.01.23D0;((enlist `max)!enlist `ask`bid))\nmaxAsk maxBid\n-------------\n109.5  108.6\n\nq).dataaccess.buildquery `tablename`starttime`endtime`aggregations!(`quote;2021.01.20D0;2021.01.23D0;((enlist `max)!enlist `ask`bid))\n? `quote ,(within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000) 0b `maxAsk`maxBid!((max;`ask);(max;`bid))\n\n</code></pre>"},{"location":"dataaccess/#filters_1","title":"Filters","text":"<p>Use the <code>`filters</code> parameter to execute a functional select style where clause</p> <pre><code>q)getdata`tablename`starttime`endtime`filters!(`quote;2021.01.20D0;2021.01.23D0;(enlist(`src))!enlist enlist(in;`GETGO`DB))\ndate       time                          sym  bid   ask   bsize asize mode ex src\n---------------------------------------------------------------------------------\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.1  84.52 58    84    Y    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.3  84.63 76    28    I    N  DB\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.96 84.24 50    73    Y    N  DB\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.8  84.76 78    32    Z    N  DB\n2021.01.21 2021.01.21D13:36:48.714396000 AAPL 83.5  84.99 42    71    R    N  DB\n..\nq).dataaccess.buildquery `tablename`starttime`endtime`filters!(`quote;2021.01.20D0;2021.01.23D0;(enlist(`src))!enlist enlist(in;`GETGO`DB))\n? `quote ((within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000);(in;`src;,`GETGO`DB)) 0b ()\n\n...\n</code></pre>"},{"location":"dataaccess/#free-form-filters","title":"Free form Filters","text":"<p>Use the <code>`freefromwhere</code> parameter to execute the same filter as above</p> <pre><code>q)getdata`tablename`starttime`endtime`freeformwhere!(`quote;2021.01.20D0;2021.01.23D0;\"src in `DB`GETGO\")\ndate       time                          sym  bid   ask   bsize asize mode ex src\n---------------------------------------------------------------------------------\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.1  84.52 58    84    Y    N  DB\n2021.01.21 2021.01.21D13:36:45.714478000 AAPL 83.3  84.63 76    28    I    N  DB\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.96 84.24 50    73    Y    N  DB\n2021.01.21 2021.01.21D13:36:46.113465000 AAPL 83.8  84.76 78    32    Z    N  DB\n2021.01.21 2021.01.21D13:36:48.714396000 AAPL 83.5  84.99 42    71    R    N  DB\n\n...\nq).dataaccess.buildquery `tablename`starttime`endtime`freeformwhere!(`quote;2021.01.20D0;2021.01.23D0;\"src in `DB`GETGO\")\n? `quote ((within;`time;2021.01.20D00:00:00.000000000 2021.01.23D00:00:00.000000000);(in;`src;,`DB`GETGO)) 0b ()\n\n\n</code></pre>"},{"location":"dataaccess/#ordering","title":"Ordering","text":"<p>Use the <code>`ordering</code> parameter to sort results by column ascending or descending</p> <pre><code>q)getdata`tablename`starttime`endtime`ordering!(`quote;2000.01.01D00:00:00.000000000;2000.01.06D10:00:00.000000000;enlist(`asc`asksize))\nsym    time                          sourcetime                    bidprice bidsize askprice asksize\n----------------------------------------------------------------------------------------------------\nAAPL   2000.01.01D02:24:00.000000000 2000.01.01D02:24:00.000000000 90.9     932.4   111.1    1139.6\nAAPL   2000.01.01D04:48:00.000000000 2000.01.01D04:48:00.000000000 98.1     933.3   119.9    1140.7\nGOOG   2000.01.01D10:24:00.000000000 2000.01.01D11:12:00.000000000 96.3     940.5   117.7    1149.5\nAAPL   2000.01.01D00:00:00.000000000 2000.01.01D00:00:00.000000000 97.2     959.4   118.8    1172.6\nGOOG   2000.01.01D00:48:00.000000000 2000.01.01D01:36:00.000000000 93.6     1008    114.4    1232\nGOOG   2000.01.01D03:12:00.000000000 2000.01.01D04:00:00.000000000 101.7    1078.2  124.3    1317.8\n...\nq).dataaccess.buildquery `tablename`starttime`endtime`ordering!(`quote;2000.01.01D00:00:00.000000000;2000.01.06D10:00:00.000000000;enlist(`asc`asksize))\n? `quote ,(within;`time;2000.01.01D00:00:00.000000000 2000.01.06D10:00:00.000000000) 0b ()\n</code></pre>"},{"location":"dataaccess/#rename-columns","title":"Rename Columns","text":"<p>Use the <code>`renamecolumn</code> parameter to rename the columns</p> <pre><code>q)getdata (`tablename`starttime`endtime`freeformby`freeformcolumn`instruments`renamecolumn)!(`trade;2021.01.18D0;2021.01.20D0;\"sym,date\";\"max price\";`IBM`AAPL`INTC;`sym`price`date!`newsym`newprice`newdate)\nnewdate    newsym| newprice\n-----------------| --------\n2021.01.18 IBM   | 69.64\n2021.01.19 IBM   | 55.91\n2021.01.18 AAPL  | 121.66\n2021.01.19 AAPL  | 111.67\n2021.01.18 INTC  | 70.77\n2021.01.19 INTC  | 65.6\nq).dataaccess.buildquery (`tablename`starttime`endtime`freeformby`freeformcolumn`instruments`renamecolumn)!(`trade;2021.01.18D0;2021.01.20D0;\"sym,date\";\"max price\";`IBM`AAPL`INTC;`sym`price`date!`newsym`newprice`newdate)\n? `trade ((=;`sym;,`IBM);(within;`time;2021.01.18D00:00:00.000000000 2021.01.20D00:00:00.000000000))  `date`sym!`time.date`sym (,`price)!,(max;`price)\n? `trade ((=;`sym;,`AAPL);(within;`time;2021.01.18D00:00:00.000000000 2021.01.20D00:00:00.000000000)) `date`sym!`time.date`sym (,`price)!,(max;`price)\n? `trade ((=;`sym;,`INTC);(within;`time;2021.01.18D00:00:00.000000000 2021.01.20D00:00:00.000000000)) `date`sym!`time.date`sym (,`price)!,(max;`price)\n</code></pre>"},{"location":"dataaccess/#postprocessing","title":"Postprocessing","text":"<p>Use the <code>`postprocessing</code> key to under go post processing on a table for example flipping the table into a dictionary</p> <pre><code>q)getdata`tablename`starttime`endtime`aggregations`postprocessing!(`quote;2021.02.12D0;2021.02.12D12;((enlist `max)!enlist `ask`bid);{flip x})\nmaxAsk| 91.74\nmaxBid| 90.65\n\nq).dataaccess.buildquery `tablename`starttime`endtime`aggregations`postprocessing!(`quote;2021.02.12D0;2021.02.12D12;((enlist `max)!enlist `ask`bid);{flip x})\n? `quote ,(within;`time;2021.02.12D00:00:00.000000000 2021.02.12D12:00:00.000000000) 0b `maxAsk`maxBid!((max;`ask);(max;`bid))\n\n</code></pre> <p>More complex example collecting the avg price across multiple processes in the gateway g</p> <pre><code>q)g\".dataaccess.getdata`tablename`starttime`endtime`aggregations`postprocessing!(`quote;2021.02.12D0;.z.p;(`sum`count)!2#`ask;{flip x})\"\nsumAsk  | 1.288549e+09\ncountAsk| 28738958\nq)g\".dataaccess.getdata`tablename`starttime`endtime`aggregations`postprocessing!(`quote;2021.02.12D0;.z.p;(`sum`count)!2#`ask;{select avgprice: sumAsk%countAsk from x})\"\navgprice\n--------\n44.83632\n\n</code></pre>"},{"location":"dataaccess/#sublist","title":"Sublist","text":"<p>Use the <code>`sublist</code> key to return the first n rows of a table, for example we get the first 2 rows of the table.</p> <pre><code>\nq)getdata `tablename`starttime`endtime`freeformby`aggregations`ordering`sublist!(`quote;00:00+2021.02.17D10;.z.d+18:00;\"sym\";(`max`min)!((`ask`bid);(`ask`bid));enlist(`desc;`maxAsk);2)\nsym | maxAsk maxBid minAsk minBid\n----| ---------------------------\nAAPL| 171.23 170.36 56.35  55.32\nGOOG| 101.09 99.96  45.57  44.47\n\nq).dataaccess.buildquery `tablename`starttime`endtime`freeformby`aggregations`ordering`sublist!(`quote;00:00+2021.02.17D10;.z.d+18:00;\"sym\";(`max`min)!((`ask`bid);(`ask`bid));enlist(`desc;`maxAsk);2)\n? `quote ,(within;`time;2021.02.17D10:00:00.000000000 2021.03.03D18:00:00.000000000) (,`sym)!,`sym `maxAsk`maxBid`minAsk`minBid!((max;`ask);(max;`bid);(min;`ask);(min;`bid))\n\nq)getdata `tablename`starttime`endtime`freeformby`aggregations`ordering`sublist!(`quote;00:00+2021.02.17D10;.z.d+18:00;\"sym\";(`max`min)!((`ask`bid);(`ask`bid));enlist(`desc;`maxAsk);3)\nsym | maxAsk maxBid minAsk minBid\n----| ---------------------------\nINTC| 68.51  67.56  44.59  43.63\nIBM | 48.53  47.61  37.1   36.11\nHPQ | 46.09  45.05  29.97  29.03\n\n</code></pre>"},{"location":"gettingstarted/","title":"Getting Started","text":"<p>kdb+ is very customisable. Customisations are contained in q scripts (.q files), which define functions and variables which modify the behaviour of a process. Every q process can load a single q script, or a directory containing q scripts and/or q data files. Hooks are provided to enable the programmer to apply a custom function to each entry point of the process (.z.p*), to be invoked on the timer (.z.ts) or when a variable in the top level namespace is amended (.z.vs). By default none of these hooks are implemented.</p> <p>We provide a codebase and a single main script, torq.q. torq.q is essentially a wrapper for bespoke functionality which can load other scripts/directories, or can be sourced from other scripts. Whenever possible, torq.q should be invoked directly and used to load other scripts as required. torq.q will:</p> <ul> <li> <p>ensure the environment is set up correctly;</p> </li> <li> <p>define some common utility functions (such as logging);</p> </li> <li> <p>execute process management tasks, such as discovering the name and     type of the process, and re-directing output to log files;</p> </li> <li> <p>load configuration;</p> </li> <li> <p>load the shared code based;</p> </li> <li> <p>set up the message handlers;</p> </li> <li> <p>load any required bespoke scripts.</p> </li> </ul> <p>The behavior of torq.q is modified by both command line parameters and configuration. We have tried to keep as much as possible in configuration files, but if the parameter either has a global effect on the process or if it is required to be known before the configuration is read, then it is a command line parameter.</p> <p></p>"},{"location":"gettingstarted/#installing-torq","title":"Installing TorQ","text":"<p>A guide on how to install TorQ using installation script here.</p>"},{"location":"gettingstarted/#using-torqq","title":"Using torq.q","text":"<p>torq.q can be invoked directly from the command line and be set to source a specified file or directory. torq.q requires the 5 environment variables to be set (see section\u00a0envvar). If using a unix environment, this can be done with the setenv.sh script. To start a process in the foreground without having to modify any other files (e.g. process.csv) you need to specify the type and name of the process as parameters. An example is below.</p> <pre><code>$ . setenv.sh\n$ q torq.q -debug -proctype testproc -procname test1\n</code></pre> <p>To specify the parent process type, do:</p> <pre><code>$ q torq.q -debug -parentproctype testparentproc -proctype testproc -procname test1\n</code></pre> <p>To load a file, do:</p> <pre><code>$ q torq.q -load myfile.q -debug -proctype testproc -procname test1\n</code></pre> <p>It can also be sourced from another script. If this is the case, some of the variables can be overridden, and the usage information can be modified or extended. Any variable that has a definition like below can be overridden from the loading script.</p> <pre><code>myvar:@[value;`myvar;1 2 3]\n</code></pre> <p>The available command line parameters are:</p> Cmd Line Param Description -procname x -proctype y The process name and process type -parentproctype x The parent process type. Specifying will load in any additional code or configuration that is associated with another process type -procfile x The name of the file to get the process information from -load x [y..z] The files or database directory to load -loaddir x [y..z] Load all .q, .k files in specified directories -localtime Sets processes running in local time rather than GMT for log messages, timer calls etc. The change is backwards compatible; without -localtime flag the process will print logs etc. in GMT but can also have a different .z.P -trap Any errors encountered during initialization when loading external files will be caught and logged, processing will continue -stop Stop loading the file if an error is encountered but do not exit -noredirect Do not redirect std out/std err to a file (useful for debugging) -noredirectalias Do not create an alias for the log files (aliases drop any suffix e.g. timestamp suffix) -noconfig Do not load configuration -nopi Reset the definition of .z.pi to the initial value (useful for debugging) -debug Equivalent to [-nopi -noredirect] -usage Print usage info and exit -onelog Writes all messages to stdout log file, note non-trapped errors will still be written to stderr log file -test x Use for unit testing. Pass the location of tests directory -dataaccess path/to/csv Initialise the Dataaccess API in the process with table properties <p>In addition any process variable in a namespace (.*.*) can be overridden from the command line. Any value supplied on the command line will take priority over any other predefined value (.e.g. in a configuration or wrapper). Variable names should be supplied with full qualification e.g. -.servers.HOPENTIMEOUT 5000.</p> <p></p>"},{"location":"gettingstarted/#using-torqsh","title":"Using torq.sh","text":"<p>torq.sh is a script that runs processes in torq with added functionality, one key enhancement is all the process configuration is now in one place. The default process file is located in $KDBCONFIG/process.csv. This  script is only available on Linux. It requires environment variables to  be set, similar to torq.q. A usage statement for the script can be seen  by running the following in a unix environment: <code>./torq.sh</code>.</p>"},{"location":"gettingstarted/#environment-variables","title":"Environment Variables","text":"<p>Five environment variables are required:</p> Environment Variable Description KDBCONFIG The base configuration directory KDBCODE The base code directory KDBLOGS Where standard out/error and usage logs are written KDBHTML Contains HTML files KDBLIB Contains supporting library files <p>torq.q will check for these and exit if they are not set. If torq.q is being sourced from another script, the required environment variables can be extended by setting .proc.envvars before loading torq.q.</p> <p></p>"},{"location":"gettingstarted/#process-identification","title":"Process Identification","text":"<p>At the crux of Data Intellect TorQ is how processes identify themselves. This is defined by two required variables - .proc.proctype and .proc.procname which are the type and name of the process respectively. An optional variable parentproctype allows an inital codebase and configuration to be loaded. The two required  values determine the code base and configuration loaded, and how they are connected to by other processes. If both of the required variables are not defined, TorQ will attempt to use the port number a process was started on to determine the code base and configuration loaded.</p> <p>The most important of these is the proctype. It is up to the user to define at what level to specify a process type. For example, in a production environment it would be valid to specify processes of type \u201chdb\u201d (historic database) and \u201crdb\u201d (real time database). It would also be valid to segregate a little more granularly based on approximate functionality, for example \u201chdbEMEA\u201d and \u201chdbAmericas\u201d. In this example it may be sensible to set the parentproctype as \"hdb\" and putting all shared code in the \"hdb\" configuration to be loaded first with the region-specific configuration being loaded after. The actual functionality of a process can be defined more specifically, but this will be discussed later. The procname value is used solely for identification purposes. A process can determine its type and name in a number of ways:</p> <ol> <li> <p>From the process file in the default location of     $KDBCONFIG/process.csv;</p> </li> <li> <p>From the process file defined using the command line parameter     -procfile;</p> </li> <li> <p>From the port number it is started on, by referring to the process     file for further process details;</p> </li> <li> <p>Using the command line parameters -proctype and -procname;</p> </li> <li> <p>By defining .proc.proctype and .proc.procname in a script which     loads torq.q.</p> </li> </ol> <p>For options 4 and 5, both parameters must be defined using that method or neither will be used (the values will be read from the process file).</p> <p>For option 3, TorQ will check the process file for any entries where the port matches the port number it has been started on, and deduce it\u2019s proctype and procname based on this port number and the corresponding hostname entry.</p> <p>The process file has format as below.</p> <pre><code>aquaq$ cat config/process.csv \nhost,port,proctype,procname,U,localtime,g,T,w,load,startwithall,extras,qcmd\naquaq,9997,rdb,rdb_europe_1,appconfig/passwords/accesslist.txt,1,1,3,,${KDBCODE}/processes/rdb.q,1,,q\naquaq,9998,hdb,hdb_europe_1,appconfig/passwords/accesslist.txt,1,1,60,4000,${KDBHDB},1,,q\naquaq,9999,hdb,hdb_europe_2,appconfig/passwords/accesslist.txt,1,1,60,4000,${KDBHDB},1,,q\n</code></pre> <p>The process will read the file and try to identify itself based on the host and port it is started on. The host can either be the value returned by .z.h, or the ip address of the server. If the process can not automatically identify itself it will exit, unless proctype and procname were both passed in as command line parameters. If both of these parameters are passed in then default configuration settings will be used.</p> <p>The parameters following procname set the following:</p> Parameter Description U Authentication requiring a usr:pwd file localtime Sets process running in local time rather than GMT g Garbage collection immediate (1) or deferred (0) T Timeout in seconds for client queries, 0 for no timeout w Workspace MB limit load Files or database directory to load startwithall Determine if process is started when all is specified extras Specify any additional parameters qcmd Allows different versions of q to be used or different command line options - rlwap, numactl <p>Where U/g/T/w are standard q command line arguments and localtime and  load are TorQ command line parameters. </p>"},{"location":"gettingstarted/#running-processes-using-torqsh","title":"Running processes using torq.sh","text":"<p>torq.sh is able to start or stop processes seperately, in a batch or  all at once. Before a process is started/stopped the script will  check that the process is not already running before attempting to  start/stop a process, a time of when this is executed is printed to screen.</p> <pre><code>$ ./torq.sh start rdb1 hdb1 tickerplant1\n    15:42:00 | Starting rdb1...\n    15:42:00 | hdb1 already running\n    15:42:00 | Starting tickerplant1...\n\n$ ./torq.sh stop all\n    15:46:19 | Shutting down hdb1...\n    15:46:19 | Shutting down hdb2...\n</code></pre> <p>A status summary table of all the processes can be printed to screen,  the summary provides information on the time the process was checked,  process name, status and the port number and PID of that process.</p> <pre><code>$ ./torq.sh summary\n    TIME     | PROCESS        | STATUS | PORT   | PID\n    11:33:59 | discovery1     | up     | 41001  | 14426\n    11:33:59 | tickerplant1   | down   |\n</code></pre> <p>It is possible to view the underlying start code for all processes.  This is useful if another available command line parameter was required  for start up. </p> <pre><code>$ ./torq.sh print discovery1 \n    Start line for discovery1:\n    nohup q deploy/torq.q -procname discovery1 -stackid 41000 -proctype discovery -U appconfig/passwords/accesslist.txt -localtime 1 -g 0 -load deploy/code/processes/discovery.q -procfile deploy/appconfig/process.csv &lt;/dev/null &gt; deploy/logs/torqdiscovery1.txt 2&gt;&amp;1 &amp;\n</code></pre> <p>The debug command line parameter can be appended to the start line  straight from torq.sh to start a process in debug mode. Note it is only  possible to start one process at a time in debug mode.</p> <pre><code>$ ./torq.sh debug tickerplant1 \n</code></pre> <p>If a process name not present in the process.csv is used, the input  process name will return as an invalid input. To see a list of all the  processes in the process.csv see below.</p> <pre><code>$ ./torq.sh procs\n</code></pre> <p>A different process file can be used with this script from the command  line. The argument following the csv flag needs to be a full path to  the process.csv.</p> <pre><code>$ ./torq.sh start all -csv ${KDBAPPCONFIG}/process.csv\n</code></pre> <p>To add/override the default values in the g, T, w, or extras column the  extras flag can be used in this script. </p> <pre><code>$ ./torq.sh start rdb1 -extras -T 60 -w 4000\n$ ./torq.sh start sort1 -extras -s -3\n</code></pre>"},{"location":"gettingstarted/#using-the-code-profiler-with-torqsh","title":"Using the Code Profiler with torq.sh","text":"<p>KDB 4.0 includes an experimental built-in call-stack snapshot primitive that allows building a sampling profiler.  The profiler uses the new function <code>.Q.prf0</code>. </p> <p>Requirements and documentation of the new code profiler by kx can be found here.</p> <p>Assuming a process is running, you can run the code below as an example in the command line. Note that this <code>top</code> function currently only allows a single process as an argument and multiple processes is not currently supported.</p> <pre><code>$ ./torq.sh top rdb1\n</code></pre> <p>This uses the <code>top.q</code> script given by kx (description found here) which will show an automatically updated display of functions most heavily  contributing to the running time. The display has the following fields:</p> Field Description self the percentage of time spent in the function itself total percentage of time spent in the function including all descendants name the name of the function file the file path where the function is located <p></p>"},{"location":"gettingstarted/#logging","title":"Logging","text":"<p>By default, each process will redirect output to a standard out log and a standard error log, and create aliases for them. These will be rolled at midnight on a daily basis. They are all written to the $KDBLOGS directory. The log files created are:</p> Log File Description out_[procname]_[date].log Timestamped out log err_[procname]_[date].log Timestamped error log out_[procname].log Alias to current log log err_[procname].log Alias to current error log <p>The date suffix can be overridden by modifying the .proc.logtimestamp function and sourcing torq.q from another script. This could, for example, change the suffixing to a full timestamp.</p> <p>In the case where -onelog is flagged TorQ will attempt to redirect all output to the out log file, unfortunately this is not perfect.</p> <p>TorQ uses \\1 and \\2 to redirect stderr and stdout, onelog only overrides handled errors to the \\1 redirect. This is because there are issuses with redirecting both to the same file, (the ordering of messages will be incorrect) the issue is with KDB+ rather than with TorQ.</p> <p>Because of this errors that are raised by KDB+ and unhandled are still directed to the err log file because \\1 and \\2 cannot be redirected to the same file.</p> <p></p>"},{"location":"gettingstarted/#configuration-loading","title":"Configuration Loading","text":""},{"location":"gettingstarted/#default-configuration-loading","title":"Default Configuration Loading","text":"<p>Default process configuration is contained in q scripts, and stored in the $KDBCONFIG /settings directory. Each process tries to load all the configuration it can find and will attempt to load three configuration files in the below order:-</p> <ul> <li> <p>default.q: default configuration loaded by all processes. In a     standard installation this should contain the superset of     customisable configuration, including comments.</p> </li> <li> <p>[parentproctype].q: configuration for a specific parent process     type (only if parentproctype specified).</p> </li> <li> <p>[proctype].q: configuration for a specific process type.</p> </li> <li> <p>[procname].q: configuration for a specific named process.</p> </li> </ul> <p>The only one which should always be present is default.q. Each of the other scripts can contain a subset of the configuration variables, which will override anything loaded previously.</p>"},{"location":"gettingstarted/#application-configuration-loading","title":"Application Configuration Loading","text":"<p>Application specific configuration can be stored in a user defined directory and made visible to TorQ by setting the $KDBAPPCONFIG environment variable. If $KDBAPPCONFIG is set, then TorQ will search the $KDBAPPCONFIG/settings directory and load all configuration it can find. Application configuration will be loaded after all default configuration in the following order:-</p> <ul> <li> <p>default.q: Application default configuration loaded by all     processes.</p> </li> <li> <p>[[parentproctype]]{}.q : Application specific configuration for a     specific parent process type (only if parentproctype specified).</p> </li> <li> <p>[[proctype]]{}.q: Application specific configuration for a     specific process type.</p> </li> <li> <p>[[procname]]{}.q: Appliction specific configuration for a specific     named process.</p> </li> </ul> <p>All loaded configuration will override anything loaded previously. None of the above scripts are required to be present and can contain a subset of the default configuration variables from the default configuration directory.</p> <p>All configuration is loaded before code.</p>"},{"location":"gettingstarted/#application-dependency","title":"Application Dependency","text":"<p>TorQ will automatically check application version and dependency information. TorQ will check the $KDBAPPCONFIG directory for a dependency.csv file. This file should contain information in the format:</p> app version dependency app0 1.0.0 app1 1.1.1;app2 2.1.0 <p>TorQ will also search the $KDBCONFIG directory for the TorQ dependency.csv file. If any of the dependency versions exceed application versions, TorQ will exit and log the error. </p> <p>If no dependency files are supplied, TorQ will run as normal. However, if only an  application dependency file is supplied, TorQ will exit and log the error.</p> <p>Each version number can be up to 5 digits in length, separated by '.' and  the current kdb+ version will be automatically added with the format major.minor.yyyy.mm.dd</p> <p></p>"},{"location":"gettingstarted/#code-loading","title":"Code Loading","text":"<p>Code is loaded from the $KDBCODE directory. There is also a common codebase, a codebase for each process type, and a code base for each process name, contained in the following directories and loaded in this order:</p> <ul> <li> <p>$KDBCODE/common: shared codebase loaded by all processes;</p> </li> <li> <p>$KDBCODE/[parentproctype]: code for a specific parent process type     (only if parentproctype specified);</p> </li> <li> <p>$KDBCODE/[proctype]: code for a specific process type;</p> </li> <li> <p>$KDBCODE/[procname]: code for a specific process name;</p> </li> </ul> <p>For any directory loaded, the load order can be specified by adding order.txt to the directory. order.txt dictates the order that files in the directory are loaded. If a file is not in order.txt, it will still be loaded but after all the files listed in order.txt have been loaded.</p> <p>In addition to loading code form $KDBCODE, application specific code can be  saved in a user defined directory with the same structure as above, and made visible to TorQ by setting the $KDBAPPCODE environment variable.</p> <p>If this environment variable is set, TorQ will load codebase in the following order.</p> <ul> <li> <p>$KDBCODE/common: shared codebase loaded by all processes;</p> </li> <li> <p>$KDBAPPCODE/common: application specific code shared by all processes;</p> </li> <li> <p>$KDBCODE/[parentproctype]: code for a specific parent process type (only if     parentproctype specified);</p> </li> <li> <p>$KDBAPPCODE/[parentproctype]: application specific code for a specific parent     process type (only if parentproctype specified);</p> </li> <li> <p>$KDBCODE/[proctype]: code for a specific process type;</p> </li> <li> <p>$KDBAPPCODE/[proctype]: application specific code for a specific process type;</p> </li> <li> <p>$KDBCODE/[procname]: code for a specific process name;</p> </li> <li> <p>$KDBAPPCODE/[procname]: application specific code for a specific process name;</p> </li> </ul> <p>Additional directories can be loaded using the -loaddir command line parameter.</p> <p></p>"},{"location":"gettingstarted/#initialization-errors","title":"Initialization Errors","text":"<p>Initialization errors can be handled in different ways. The default action is any initialization error causes the process to exit. This is to enable fail-fast type conditions, where it is better for a process to fail entirely and immediately than to start up in an indeterminate state. This can be overridden with the -trap or -stop command line parameters. With -trap, the process will catch the error, log it, and continue. This is useful if, for example, the error is encountered loading a file of stored procedures which may not be invoked and can be reloaded later. With -stop the process will halt at the point of the error but will not exit. Both -stop and -trap are useful for debugging.</p>"},{"location":"handlers/","title":"Message Handlers","text":"<p>There is a separate code directory containing message handler customizations. This is found at $KDBCODE/handlers. Much of the code is derived from Simon Garland\u2019s contributions to code.kx.</p> <p>Every external interaction with a process goes through a message handler, and these can be modified to, for example, log or restrict access. Passing through a bespoke function defined in a message handler will add extra processing time and therefore latency to the message. All the customizations we have provided aim to minimise additional latency, but if a bespoke process is latency sensitive then some or all of the customizations could be switched off. We would argue though that generally it is better to switch on all the message handler functions which provide diagnostic information, as for most non-latency sensitive processes (HDBs, Gateways, some RDBs etc.) the extra information upon failure is worth the cost. The message handlers can be globally switched off by setting .proc.loadhandlers to 0b in the configuration file.</p> Script NS Diag Function Modifies logusage.q .usage Y Log all client interaction to an ascii log file and/or in-memory table. Messages can be logged before and after they are processed. Timer calls are also logged. Exclusion function list can be applied to .z.ps to disable logging of asynchronous real time updates pw, po, pg, ps, pc, ws, ph, pp, pi, exit, timer controlaccess.q .access N Restrict access for set of users/user groups to a list of functions, and from a defined set of servers pw, pg, ps, ws, ph, pp, pi trackclients.q .clients Y Track client process details including then number of requests and cumulative data size returned po, pg, ps, ws, pc trackservers.q .servers Y Discover and track server processes including name, type and attribute information. This also contains the core of the code which can be used in conjunction with the discovery service. pc, timer zpsignore.q .zpsignore N Override async message handler based on certain message patterns ps writeaccess.q .readonly N Restrict client write access to prevent any modification to data in place. Also disables all HTTP access. pg, ps, ws, ph, pp ldap.q .ldap N Restrict client access to process using ldap authentication. pw <p>Each customization can be turned on or off individually from the configuration file(s). Each script can be extensively customised using the configuration file. Example customization for logusage.q, taken from $KDBCONFIG/settings/default.q is below. Please see default.q for the remaining configuration of the other message handler files.</p> <pre><code>/- Configuration used by the usage functions - logging of client interaction\n\\d .usage\nenabled:1b      /- whether the usage logging is enabled\nlogtodisk:1b        /- whether to log to disk or not\nlogtomemory:1b      /- write query logs to memory\nignore:1b       /- check the ignore list for functions to ignore\nignorelist:(`upd;\"upd\") /- the list of functions to ignore in async calls\nflushtime:1D00      /- default value for how long to persist the\n            /- in-memory logs. Set to 0D for no flushing\nsuppressalias:0b    /- whether to suppress the log file alias creation\nlogtimestamp:{[].z.d}   /- function to generate the log file timestamp suffix\nLEVEL:3         /- log level. 0=none;1=errors;2=errors+complete\n            /- queries;3=errors+before a query+after\nlogroll:1b      /- Whether or not to roll the log file\n            /- automatically (on a daily schedule)\n</code></pre>"},{"location":"handlers/#dotzq","title":"dotz.q","text":"<p>Stores all the default values for the message handlers and can be used to revert back to the default if necessary.</p> <p></p>"},{"location":"handlers/#logusageq","title":"logusage.q","text":"<p>logusage.q is probably the most important of the scripts from a diagnostic perspective. It is a modified version of the logusage.q script on code.kx.</p> <p>In its most verbose mode it will log information to an in-memory table (.usage.usage) and an on-disk ASCII file, both before and after every client interaction and function executed on the timer. These choices were made because:</p> <ul> <li> <p>logging to memory enables easy interrogation of client interaction;</p> </li> <li> <p>logging to disk allows persistence if the process fails or locks up.       ASCII text files allow interrogation using OS tools such as vi, grep       or tail;</p> </li> <li> <p>logging before a query ensures any query that adversely effects the       process is definitely captured, as well as capturing some state       information before the query execution;</p> </li> <li> <p>logging after a query captures the time taken, result set size and       resulting state;</p> </li> <li> <p>logging timer calls ensures a full history of what the process is       actually doing. Also, timer call performance degradation over time       is a common source of problems in kdb+ systems.</p> </li> </ul> <p>The following fields are logged in .usage.usage:</p> Field Description time Time the row was added to the table id ID of the query. Normally before and complete rows will be consecutive but it might not be the case if the incoming call invokes further external communication timer Execution time. Null for rows with status=b (before) zcmd .z handler the query arrived through status Query status. One of b, c or e (before, complete, error) a Address of sender. .dotz.ipa can be used to convert from the integer format to a hostname u Username of sender w Handle of sender cmd Command sent mem Memory statistics sz Size of result. Null for rows with status of b or e error Error message <p></p>"},{"location":"handlers/#controlaccessq","title":"controlaccess.q","text":"<p>controlaccess.q is used to restrict client access to the process. It is modified version of controlaccess.q from code.kx. The script allows control of several aspects:</p> <ul> <li> <p>the host/ip address of the servers which are allowed to access the     process;</p> </li> <li> <p>definition of three user groups (default, poweruser and superuser)       and the actions each group is allowed to do;</p> </li> <li> <p>the group(s) each user is a member of, and any additional actions an       individual user is allowed/disallowed outside of the group       permissions;</p> </li> <li> <p>the maximum size of the result set returned to a client.</p> </li> </ul> <p>The access restrictions are loaded from csv files. The permissions files are stored in $KDBCONFIG/permissions.</p> File Description *_hosts.csv Contains hostname and ip address (patterns) for servers which are allowed or disallowed access. If a server is not found in the list, it is disallowed *_users.csv Contains individual users and the user groups they are are a member of *_functions.csv Contains individual functions and whether each user group is allowed to execute them. ; separated user list enables functions to be allowed by individual users <p>The permissions files are loaded using a similar hierarchical approach as for the configuration and code loading. Three files can be provided- default_.csv, [proctype]_.csv, and [procname]_.csv. All of the files will be loaded, but permissions for the same entity (hostpattern, user, or function) defined in [procname]_.csv will override those in [proctype]_.csv which will in turn override [procname]_.csv.</p> <p>When a client makes a query which is refused by the permissioning layer, an error will be raised and logged in .usage.usage if it is enabled.</p> <p></p>"},{"location":"handlers/#trackclientsq","title":"trackclients.q","text":"<p>trackclients.q is used to track client interaction. It is a slightly modified version of trackclients.q from code.kx, and extends the functionality to handle interaction with the discovery service.</p> <p>Whenever a client opens a connection to the q process, it will be registered in the .clients.clients table. Various details are logged, but from a diagnostic perspective the most important information are the client details, the number of queries it has run, the last time it ran a query, the number of failed queries and the cumulative size of results returned to it.</p> <p></p>"},{"location":"handlers/#trackserversq","title":"trackservers.q","text":"<p>trackservers.q is used to register and maintain handles to external servers. It is a heavily modified version of trackservers.q from code.kx. It is explained more in the\u00a0Connection Management section.</p> <p></p>"},{"location":"handlers/#zpsignoreq","title":"zpsignore.q","text":"<p>zpsignore.q is used to check incoming async calls for certain patterns and to bypass all further message handler checks for messages matching the pattern. This is useful for handling update messages published to a process from a data source.</p> <p></p>"},{"location":"handlers/#writeaccessq","title":"writeaccess.q","text":"<p>writeaccess.q is used to restrict client write access to data within a process. The script uses the reval function, released in KDB+ 3.3, to prevent client queries from modifying any data in place. At present only queries in the form of strings are passed through the reval function. Additionally the script disables any form of HTTP access. If using versions of KDB+ prior to 3.3, this feature must be disabled. An attempt to use this feature on previous KDB+ versions will result in an error and the relevant process exiting.</p>"},{"location":"handlers/#permissionsq","title":"permissions.q","text":"<p>permissions.q is used to control client access to a server process. It allows:</p> <ul> <li> <p>Access control via username/password access, either in combination     with the -u/U process flags or in place of them.</p> </li> <li> <p>Definition of user groups, which control variable access.</p> </li> <li> <p>Definition of user roles, which allow control over function     execution.</p> </li> <li> <p>Deeper control over table subsetting through the use of \u201cvirtual     tables\u201d, using enforced where clauses.</p> </li> </ul> <p>Access restriction in TorQ can be enabled on all processes, each of which can then load the default.q in $KDBCONFIG/permissions/, which adds users, groups and roles allowing standard operation of TorQ. The admin user and role by default can access all functions, and each of the system processes has access only to the required system functions.</p> <p>Permissions are enabled or disabled on a per-process basis through setting .pm.enabled as 1b or 0b at process load (set to 0b by default). A permissioned process can safely interact with a non-permissioned process while still controlling access to itself.</p> <p>The access schema consists of 7 control tables:</p> Name Descriptions user Username, locality, encryption type and password hash usergroup User and their group. userrole User and role. functiongroup Functions and their group function Function names, the roles which can access them, and a lambda checking the parameters those roles can use. access Variable names, the groups which can access them, and the read or write access level. virtualtable Virtual table name, main table name, and the where clause it enforces on access to that table. <p>In addition to groupinfo and roleinfo tables, which contain the group/role name and a string describing each group and role. A user can belong to multiple groups, and have multiple roles. In particular the schema supports group hierarchy, where a user group can be listed as a user in the group table, and inherit all the permissions from another other group, effectively inheriting the second group itself. Note that a group cannot have the same name as an individual user.</p> <p>A user belonging to a group listed in the access table will have the specified level of access (read or write) to that group\u2019s variables, e.g.</p> Table Group Level quote headtrader write trade juniortrader read <p>Here, users in headtrader will have write access to the quote table, while juniortrader group has read access to the trade table. If headtraders have been set to inherit the juniortrader group, they will also have read access to trade. Note that read access is distinct from write access. Headtraders in this circumstance do not have implicit read access to the quote table. This control is for direct name access only. Selects, execs and updates are controlled via the function table, as below.</p> <p>The permissions script can be set to have permissive mode enabled with permissivemode:1b (disabled by default). When enabled at script loading, this bypasses access checks on variables which are not listed in the access table, effectively auto-allowlisting any variables not listed in the access table for all users, which may be useful in partly restricted development environments.</p> <p>Function access is controlled through non-hierarchical roles. A user attempting to run a named function will have their access checked against the function table through their role, for example, trying to run a function timedata[syms;bkttype], which selects from a table by a time bucket type bkttype on xbar:</p> Function Role Param. Check timedata quant {1b} timedata normal user {x[`bkttype] in `hh} select quant {1b} <p>The parameter check in the third column must be a lambda accepting a dictionary of parameters and their values, which can then return a boolean if some parameter condition is met. Here, any normal user must have their bucket type as an hour. If they try anything else, the function is not permitted. This could be extended to restriction to certain syms as well, in this example, the quant can run this function with any parameters. Anything passed to the param. check function returns 1b. A quant having general select access is listed as having 1b in the param. check.</p> <p>Further restriction of data can be achieved with virtual tables, via which users can be restricted to having a certain subset of data from a main table available. To avoid the need to replicate a potentially large subset of a table into a separately-controlled variable, this is done through pointing to the table under a different name via a where clause, e.g.</p> Virtual Table Table Where Clause trade_lse trade ,(in;`src;\u201cL\u201d) quote_new quote ,(&gt;;`time;(-;`.z.p;01:00)) <p>When a select from trade_lse is performed, a select on trade is modified to contain the where clause above. Access to virtual tables can be controlled identically to access to real tables through the access table.</p> <p>If the process is given the flag \u201c-public 1\u201d, it will run in public access mode. This allows a user to log in without a password and be given the publicuser role and membership of the public group, which can be configured as any other group or role.</p> <p>The permissions control has a default size restriction of 2GB, set (as bytes) on .pm.maxsize. This is a global restriction and is not affected by user permissions.</p> <p>Adding to the groups and roles is handled by the functions:</p> <pre><code>adduser[`user;`locality;`hash type; md5\"password\"]\nremoveuser[`user]\naddgroup[`groupname; \"description\"]\nremovegroup[`groupname]\naddrole[`rolename; \"description\"]\nremoverole[`rolename]\naddtogroup[`user;`groupname]\nremovefromgroup[`user; `groupname]\nassignrole[`user; `rolename]\nunassignrole[`user; `rolename]\naddfunction[`function; `functiongroup]\nremovefunction[`function; `functiongroup]\ngrantaccess[`variable; `groupname; `level]\nrevokeaccess[`variable; `groupname; `level]\ngrantfunction[`function; `rolename; {paramCheckFn}]\nrevokefunction[`function; `rolename]\ncreatevirtualtable[`vtablename; `table; ,(whereclause)]\nremovevirtualtable[`vtablename]\ncloneuser[`user;`newuser;\"password\"]\n</code></pre> <p>which are further explained in the script API.</p> <p>Permission control operates identically on the gateway. A user connected to the gateway must have access to the gateway, and their roles must have access to the .gw.syncexec or .gw.asyncexec functions.</p>"},{"location":"handlers/#usage-example","title":"Usage Example","text":"<p>To connect to a permissioned RDB in the TorQ system, a group and role for the user must be established. If the RDB contains the tables trade, quote, and depth, and the process contains the functions getdata[syms, bkttype,bktsize] and hloc[table], restricted access would be configured like so:</p> <pre><code>.pm.adduser[`adam;`local;`md5;md5\"pass\"]\n.pm.adduser[`bob;`local;`md5;md5\"pass\"]\n\n.pm.addtogroup[`adam;`fulluser]\n.pm.addtogroup[`bob;`partuser]\n.pm.addtogroup[`fulluser;`partuser]\n.pm.grantaccess[`quote;`fulluser;`read]\n.pm.grantaccess[`trade;`partuser;`read]\n\n.pm.createvirtualtable[`quotenew;`quote;enlist(&gt;;`time;(-;`.z.p;01:00))]\n.pm.grantaccess[`quotenew;`partuser;`read]\n\n.pm.assignrole[`adam;`toplevel]\n.pm.assignrole[`bob;`lowlevel]\n.pm.grantfunction[`getdata;`toplevel;{1b}]\n.pm.grantfunction[`getdata;`lowlevel;{x[`syms] in `GOOG}]\n.pm.grantfunction[`hloc;`toplevel;{1b}]\n.pm.grantfunction[`hloc;`lowlevel;{x[`table] in `trade}]\n</code></pre> <p>This provides a system in which Bob can access only the trade table, while Adam has access to the trade table and quote table (through inheritance from Bob\u2019s group). Through a virtual table, if Bob runs \u201cselect from quotenew\u201d, he is able to get a table of the last hour of quotes. When the system is started in normal mode, there is no IPC access to the depth table, however if the system was started in permissive mode, in this case any user who could log in could access depth.</p> <p>Adam can run the getdata function however he wants, and Bob can only run it against sym GOOG. Similarly Adam can run hloc against any table, but Bob can only look at trade with it.</p> <p>Additionally, any system calls would need to be actively permissioned in the same way, after defining a systemuser role (or expanding the default role in TorQ). The superuser is given global function access by assigning them .pm.ALL in the function table, for example a tickerplant pushing to the RDB would need to have a user and role defined:</p> <pre><code>.pm.adduser[`ticker;`local;`md5;md5\"plant\"]\n.pm.assignrole[`ticker;`tp]\n</code></pre> <p>And then grant that role access to the .u.upd function:</p> <pre><code>.pm.grantfunction[`.u.upd;`tp;{1b}]\n</code></pre> <p>Although the .u.upd function updates to a table, there is no need to grant direct access to that table.</p>"},{"location":"handlers/#gateway-example","title":"Gateway Example","text":"<p>The gateway user will have superuser role by default. The execution of a function passed through the gateway is checked against the user who sent the call. This should not be modified.</p> <p>Within the gateway itself, access to target processes can be controlled via the function table. For example, if Adam in the previous example was allowed to access only the RDB with .gw.syncexec, you could use:</p> <pre><code>.pm.grantfunction[`.gw.syncexec;`toplevel;{x[`1] in `rdb}]\n</code></pre> <p>Since .gw.syncexec is a projection, the arguments supplied are checked in order, with dictionary keys `0`1`2... etc. This could be further extended to restrict access to queries with the .pm.allowed[user;query] function, which checks permissions of the current user as listed on the gateway permission tables:</p> <pre><code>.pm.grantfunction[`.gw.syncexec;`toplevel;\n    {.pm.allowed[.z.u;x[`0]] and x[`1] in `rdb}]\n</code></pre> <p></p>"},{"location":"handlers/#ldapq","title":"ldap.q","text":"<p>Authentication with an ldap server is managed with ldap.q. It allows:</p> <ul> <li> <p>A user to authenticate against an ldap server;</p> </li> <li> <p>Caching of user attempts to allow reauthentication without server if within checktime period;</p> </li> <li> <p>Users to be blocked if too many failed authentication attempts are made.</p> </li> </ul> <p>Default parameters in the ldap namespace are set in {TORQHOME}/config/settings/default.q.</p> parameter description enabled Whether ldap authentication is enabled debug Whether logging message are written to console servers <code>&lt;schema&gt;://&lt;host&gt;:&lt;port&gt;</code> address(es) of server(s) to connect to version Ldap version number. blocktime Time that must elapse before a blocked user can attempt to authenticate. If set to 0Np then the user is permanently blocked until an admin unblocks them. checklimit Login attempts before user is blocked. checktime Period of time that allows user to reauthenticate without confirming with ldap server. buildDNsuf Suffix for building distinguished name. buildDN Function to build distiniguished name. <p>To get started the following will need altered from their default values: enabled, servers, buildDNsuf.</p> <p>The value buildDNsuf is required to build a users bind_dn from the supplied username and is called by the function buildDN. An example definition is:</p> <pre><code>.ldap.buildDNsuf:\"ou=users,dc=website,dc=com\";\n</code></pre> <p>Authentication is handled by .ldap.authenticate which is wrapped by .ldap.login, which is in turn wrapped by .z.pw when ldap authentication is enabled. When invoked .ldap.login retrieves the users latest authentication attempt from the cache, if it exists, and performs several checks before authenticating the user.</p> <p>To authenticate the function first checks whether the user has been blocked by reaching the checklimit and blocktime has not passed, immediately returning false if this is the case. If the user has previously successfully authenticated within the period defined by checktime and is using the same credentials authentication will be permitted. For all other cases an authentication attempt will be made against the ldap server. </p> <p>Example authentication attempt:</p> <pre><code>.ldap.login[`user;pass]\n0b\n</code></pre> <p>To manually unblock a user the function .ldap.unblock must be passed their userame as a symbol. The function checks the cache to see whether a user is blocked and will reset the blocked status if necessary. An example usage of this function is:</p> <pre><code>.ldap.unblock[`user]\n</code></pre> <p></p>"},{"location":"handlers/#diagnostic-reporting","title":"Diagnostic Reporting","text":"<p>The message handler modifications provide a wealth of diagnostic information including:</p> <ul> <li> <p>the timings and memory usage for every query run on a process;</p> </li> <li> <p>failed queries;</p> </li> <li> <p>clients trying to do things they are not permissioned for;</p> </li> <li> <p>the clients which are querying often and/or regularly extracting       large datasets;</p> </li> <li> <p>the number of clients currently connected;</p> </li> <li> <p>timer calls and how long they take.</p> </li> </ul> <p>Although not currently implemented, it would be straightforward to use this information to implement reports on the behaviour of each process and the overall health of the system. Similarly it would be straightforward to set up periodic publication to a central repository to have a single point for system diagnostic statistics.</p>"},{"location":"monit/","title":"Monitoring TorQ","text":"<p>There are lots of standard tools available to monitor a TorQ stack. It can be easily integrated with incumbent monitoring systems. We have outlined how to use two of our preferred options below- Monit and Datadog. Some of their features overlap and some are complementary. </p>"},{"location":"monit/#monit","title":"Monit","text":"<p>Monit is a small open source utility for monitoring and managing UNIX systems. Monit's ease of use makes it the perfect tool for tracking the status of TorQ processes.</p>"},{"location":"monit/#installation","title":"Installation","text":"<p>Monit is included in most Unix distributions but can also be downloaded from here. This monit addition to TorQ allows the monit config files to be easily generated, based on the contents of the process.csv file. </p> <p>The basic monit directory which has been added to TorQ can be seen below: </p> <pre><code>${TORQHOME}\n|---monit\n    |---bin\n    |   |---monit.sh \n    |---templates \n        |---monitalert.cfg\n        |---monitrc\n        |---monittemplate.txt\n</code></pre> <p>It is important to mention that Data Intellect will not offer support for monitalert.cfg and monitrc. Those two files have been added as an example on how monit can be configured to monitor your system and to offer an out-of-the-box configuration that you can use to test that monit works.  If the monit installation contains an updated version of monitrc, this should be used instead. </p>"},{"location":"monit/#features","title":"Features","text":"<p>Monit is only available for UNIX and it comes with a bash script that you can use to generate the configuration and start the processes. More details on how you use this script can be found below. </p> <p>We have also included a standard monitrc which will: </p> <ul> <li>Set the check interval to 30 seconds </li> <li>Set the location of the monit.log file </li> <li>Set the location of monit.state fsile </li> <li>Define the mail alert basic configuration </li> <li>Define the e-mail format</li> <li>Set the interface port (11000) user and password</li> <li>Set the location of the *.cfg files </li> </ul> <p>The monitalert.cfg it is only an example on how you can configure your own alerts for monitoring your UNIX system. There are no TorQ specific examples in this file. </p> <p>The only file which will be updated with future TorQ releases is the monittemplate.txt which generates the monitconfig.cfg. An example is included below: </p> <pre><code>check process tickerplant1\n  matching \"15000 -proctype tickerplant -procname tickerplant1\"\n    start program = \"/bin/bash -c '/home/USER/torqprodsupp/torqdev/deploy/torq.sh start tickerplant1'\"\n      with timeout 10 seconds\n    stop program = \"/bin/bash -c '/home/USER/torqprodsupp/torqdev/deploy/torq.sh stop tickerplant1'\"\n    every \"* * * * *\"\n    mode active\n</code></pre>"},{"location":"monit/#usage-guide","title":"Usage Guide","text":"<p>If you want to use monit to monitor your UNIX system and TorQ processes you must first generate the configuration files and then start monit. We will assume that you start with a fresh copy of TorQ. </p> <ol> <li>Install TorQ and the any optional customisations (e.g. the TorQ Finanace Starter Pack)</li> <li>Navigate to ${TORQHOME}/monit/bin/</li> <li>Execute:  </li> <li>bash monit.sh generate all - to generate all the config files </li> <li>bash monit.sh generate alert - to generate the alert configuration file</li> <li>bash monit.sh generate monitconfig - to generate the monitconfig.cfg </li> <li>bash monit.sh generate monitrc - to generate the monitrc file </li> </ol> <p>However, you can also use your own configuration files by either creating a new directory in monit called config and moving all the .cfg files and the monitrc file in there or by modifying the last line in the monitrc to point to the folder where the .cfg files can be found. </p> <ol> <li>Start monit by executing bash monit.sh start </li> </ol> <p>The start function also take a parameter (\"string\") whch can specify the location of the monitrc.</p>"},{"location":"monit/#datadog","title":"Datadog","text":"<p>Datadog is a monitoring service for cloud-scale applications, providing monitoring of servers, databases, tools, and services, through a SaaS-based data analytics platform. This documentation provides a guideline on how to integrate TorQ and Datadog on a Linux host.</p> <p></p> <p>Note: The Datadog Agent used in this integration is version 7, and may not be backwards or forwards compatible with other versions. See the Datadog documentation for more detail. </p>"},{"location":"monit/#installation_1","title":"Installation","text":"<p>Please Note: At this time the integration of Datadog with TorQ is supported on a unix host. We have not yet provided instructions or functionality for the use of Datadog with TorQ on other operating systems.</p> <p>The Datadog Agent is software that runs on your host, collecting events and metrics from the host and sending them to Datadog, where you can analyze your monitoring and performance data. We have provided the functionality to monitor system metrics such as CPU and memory usage, report process errors to Datadog, perform data checks and visualise the results on a custom dashboard. The datadog agent can be installed here. Note that there are multiple price plans for Datadog, and the functionality available to you is dependent on your plan. </p> <p>A 14-day free trial is available, on which all the monitoring provided within this integration will work. </p> <p>Once you've set up an account with datadog, more information on getting started can be found here.  An easy one-step install is provided as shown in the video above.</p> <p>Code is provided within TorQ to enable the integration of Datadog with a TorQ stack on a unix host. The directory layout of the relevant code is as shown below:</p> <pre><code>${TORQHOME}\n|---datadog\n    |---Example_TorQ_Monitoring_Dashboard.json\n    |---monitors\n    |---setupdatadog.sh\n</code></pre> <pre><code>${TORQHOME}\n|---code\n    |---common\n    |   |---datadog.q\n    |---monitor\n        |---datadogchecks.q\n</code></pre> <p>The <code>setupdatadog.sh</code> script is provided as a quick-start install to set up datadog on your host. It edits the config files required by datadog: </p> <ul> <li>Datadog.yaml, which contains the port number to listen on, and enables the agent to receive metrics and events from processes. </li> <li>Process.yaml, which determines which processes datadog will retrieve CPU and memory stats for. This file is generated using the process.csv, and by default all processes will be monitored. If you wish to monitor only certain processes, a \"datadog\" column can be added to the process.csv, and a value of 1 or 0 added to each of the processes (1 meaning monitored, 0 meaning not monitored).</li> </ul>"},{"location":"monit/#features_1","title":"Features","text":"<ul> <li>Send Metrics and Events</li> </ul> <p>Metrics are values sent from the system to quickly indicate the state of a process or the system itself. We have provided the functionality to send metrics from TorQ processes to the datadog agent, via the <code>.dg.sendmetric</code> function. </p> <pre><code>q) .dg.sendmetric[\"metric_name\";metric_value]\n\n</code></pre> <p>The default configuration generated by <code>setupdatadog.sh</code> also automates the sending of process stats as metrics, using the process.yaml as a template for which processes to monitor. </p> <p>Events are sent in a similar way to Metrics, but indicate a noteworthy record of activity</p> <p>We can send an event from a TorQ process using the .dg.sendevent function:</p> <pre><code>.dg.sendevent[event_title;event_text;tags;alert_type]\n</code></pre> <p>This expects string arguments, and can accept any number of custom tags, and an alert type one of \"error\", \"warning\" or \"success\".</p> <ul> <li>Send Process Errors To Datadog</li> </ul> <p>We can utilise the sendevent functionality to track any TorQ process errors on datadog. TorQ provides a hook for extended logging, .lg.ext. We have provided the option to edit this to send errors and warnings to datadog as events:</p> <pre><code>enablelogging:{[]\n  .lg.ext:{[olddef;loglevel;proctype;proc;id;message;dict]\n  olddef[loglevel;proctype;proc;id;message;dict];\n  if[loglevel in `ERR`WARN;.dg.sendevent[string proc;message;string proctype;]$[loglevel=`ERR;\"error\";\"warning\"]]}[@[value;`.lg.ext;{{[loglevel;proctype;proc;id;message;dict]}}]]\n }\n</code></pre> <p>By default, this is not enabled, but should you wish to enable this and view process errors and warnings, you can change the value of .dg.enabled in <code>$TORQHOME/config/settings/default.q</code>.</p> <pre><code>.dg.enabled:1b\n</code></pre> <ul> <li>Automate checks using monitor process</li> </ul> <p>TorQ's monitor process lets us define a series of user-specific checks to be run at specified intervals on specified processes.  We have provided an example check (.dg.isok) and (.dg.sendresultmetric). </p> <p>The .dg.isok function is a simple check to see if a process is available and can be queried. The monitor process will execute this function within the processes it has been configured to monitor, and a value of 1b is returned if the process is available. Within the monitor process, the .dg.sendresultmetric result handler then sends this result to datadog as a metric, which can be displayed on the UI dashboard. </p> <p>Other checks can be added to provide more specific metrics to monitor, such as table record counts, e.g: </p> <pre><code>.dg.checkcount:{[table;day] count select from table where date=day}\n</code></pre> <p>No default monitor configuration is provided, but if you wish to add a check such as the above to be run by the monitor process, the <code>monitorconfig.csv</code> can be edited as shown: </p> <pre><code>family|metric|process|query|resultchecker|params|period|runtime\ndatadog|okcheck|rdb1;sort1;gateway1;hdb1;hdb2;wdb1;feed1|.dg.isok|.dg.sendresultmetric|`varname`cond!(`datadogcheck;`true)|0D00:01|0D00:00:00.5\n</code></pre>"},{"location":"monit/#usage-guide_1","title":"Usage Guide","text":"<p>If you wish to incorporate Datadog into your system as a monitoring tool, you can follow the instructions in the video above or the written instructions as follows. This will configure datadog according to default settings, and will not enable error logging or any monitoring functions unless configured by the user.  </p> <ol> <li>Install Datadog agent on your host according to instructions here</li> <li>Set up required configuration on host:<ul> <li>(Optional) Change the port on which the agent listens, DOGSTATSD_PORT. This can be edited in the setenv.sh script in the $TORQHOME directory, and will default to port 8125.</li> <li>Execute <code>. setenv.sh</code> in the $TORHOME directory, to pick up any changes to DOGSTATSD_PORT</li> <li>Execute <code>. setupdatadog.sh</code>. This will edit the required datadog config files, datadog.yaml and process.yaml.</li> <li>Restart the datadog agent: <code>sudo service datadog-agent restart</code>. This ensures the updated config is used by the agent.</li> </ul> </li> </ol> <p>The agent is now reporting process stats, and these can be visualised on the datadog UI. For more detailed metrics and events, enable the error logging using <code>.dg.enabled:1b</code> and configure the monitor process to run some checks. </p>"},{"location":"monit/#using-the-datadog-ui","title":"Using the Datadog UI","text":"<p>You can visualise your metrics and events on a dashboard, and configure monitors and alerts. </p> <p>An example dashboard has been provided in <code>$TORQHOME/datadog/Example_TorQ_Monitoring_Dashboard.json.</code> This displays simple metrics such as process cpu %, process memory % and relative changes in these, as well as TorQ-specific process checks and a stream of any errors from TorQ processes. To import this into your datadog UI, go to the dashboards section here And click add new screenboard. In the settings section, select import  dashboard json and copy and paste the json or browse your files to select the json dashboard you want to import. You will be prompted with whether or  not you want to replace whatever is on the screenboard - click yes. Your dashboard will then load and display as below. The appearance of the dashboard will depend on whether you've enabled the extended error logging, and configured the monitor process. </p> <p></p> <p>Alternatively, you can create your own custom dashboard according to the documentation here</p> <p>Monitors can be set up to track metrics and establish alerts based on critical changes. We've provided some example monitors, designed to notify if a process goes down, or system resources reach a limit. To import an example monitor, go to the \"Monitors\" section on your datadog account, click New Monitor, then Import Monitor, and copy and paste the JSON of the monitor you'd like to use into the text box provided, then click save. The monitor will then become available and start alerting.</p> <p>You can create custom monitors using the guidelines in the Datadog documentation here</p>"},{"location":"monit/#monitoring-multiple-hosts","title":"Monitoring Multiple Hosts","text":"<p>Depending on your datadog pricing plan, the option to monitor multiple hosts is provided. To integrate Datadog and TorQ across all hosts, you will need to install the agent on each host, and follow the installation instructions as above. If your TorQ setup is operating across different hosts, you will need to establish which processes to monitor on which host by configuring a \"datadog\" column in the process.csv as discussed earlier.</p>"},{"location":"unittesting/","title":"Unit Testing in TorQ","text":""},{"location":"unittesting/#introduction","title":"Introduction","text":"<p>Unit testing is a software validation methodology where individual modules or 'units' of source code are tested to determine whether they work as intended. TorQ's unit testing framework has been designed to be user-friendly and includes lots of useful features such as debugging and integration testing. We shall see that, using this framework, it is straightforward to test both small units of code as well as larger pieces of application functionality.</p>"},{"location":"unittesting/#test-basics","title":"Test Basics","text":"<p>My First Test</p> <p>Tests are written in the style of Kx's k4unit, where tests are written in CSV files and loaded into a Q process along with the testing code and are run line by line, with the results being stored in a table. In order to write and run a basic test, in a new folder create a CSV file with some basic tests in it, like the following:</p> <pre><code>action,ms,bytes,lang,code,repeat,minver,comment\ncomment,0,0,,this will be ignored,1,,\"\"\nbefore,0,0,q,aa:22,1,,\"This sets a variable before the tests begin\"\ntrue,0,0,q,2=sum 1 1,1,,\"A basic arithmetic check\"\nfail,0,0,q,2=`aa,1,,\"This ought to fail\"\nafter,0,0,q,bb:33,1,,\"This code executes after the tests have run\"\n</code></pre> <p>Then use the <code>torq.q</code> script to start up a TorQ process with the test flag pointing to the directory where the CSV is written and a debug flag so that the process outputs its logs into the prompt and stays alive:</p> <pre><code>$ q ${TORQHOME}/torq.q -proctype test -procname test1 -test /path/to/my/tests -debug\n</code></pre> <p>This will automatically load in the test code and all CSVs in that directory into a test TorQ process and run the tests in those files, then output the results to the screen.</p> <p>Simple RDB Test</p> <p>A similar scenario is when the test code is loaded into a 'production' TorQ process, ie. an RDB or a tickerplant, in order to test the functioning of that process. A simple RDB example can be seen here:</p> <pre><code>action,ms,bytes,lang,code,repeat,minver,comment\ntrue,0,0,q,`segmentedtickerplant~.rdb.tickerplanttypes,1,,\"Check the TP type\"\ntrue,0,0,q,`~.rdb.subscribeto,1,,\"Check RDB is subscribed to null symbol (all tables)\"\ntrue,0,0,q,0~count heartbeat,1,,\"Check heartheat table is empty\"\nrun,0,0,q,.rdb.upd[`heartbeat;(.z.p;`test;`rdb1;1;1i;`testhost;1i)],1,,\"Call RDB UPD function\"\ntrue,0,0,q,1~count heartbeat,1,,\"Check that a row has been added to the heartbeat table\"\n</code></pre> <p>These tests simply check that certain process variables have been set properly and test the UPD function, and these are triggered similarly to the previous set, except that an RDB process is used to load in the tests rather than a 'blank' test process. Here, the <code>-proctype</code> is an RDB, which loads in the code in the <code>${KDBCODE}/rdb/</code> folder as well as any common code, so that the process logic can be tested. The <code>procname</code> can be anything you want:</p> <pre><code>$ q ${TORQHOME}/torq.q -proctype rdb -procname rdb1 -test /path/to/my/tests -debug\n</code></pre>"},{"location":"unittesting/#integration-testing-wdb-subscription-tests","title":"Integration Testing: WDB Subscription Tests","text":"<p>Once the basic concepts from before have been understood it is possible to generate much more complex testing scenarios. Often it will be necessary to test interactions between different processes, in which case you will need more than just the one testing process. In this example test we are examining the interaction between a Segmented Tickerplant (STP) and three WDBs, one of which is subscribed to everything, one to a subset of syms and the other to a subset of tables. In order to facilitate this, we need to make some additions to our test directory. As well as the CSVs containing the tests themselves we now add three more files: <code>process.csv</code>, <code>run.sh</code> and <code>settings.q</code>, and we shall examine these in more detail.</p> <p>process.csv</p> <p>An easy way to spin up multiple custom processes is to pass a custom version of <code>process.csv</code> into the TorQ start script. Our file will contain a discovery process, three WDBs and an STP and can be seen here:</p> <pre><code>host,port,proctype,procname,U,localtime,g,T,w,load,startwithall,extras,qcmd\nlocalhost,{KDBBASEPORT}+100,discovery,discovery1,${TORQHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/discovery.q,1,,q\nlocalhost,{KDBBASEPORT}+101,wdb,wdball,${TORQHOME}/appconfig/passwords/accesslist.txt,1,1,,,${KDBCODE}/processes/wdb.q,1,-.wdb.tickerplanttypes segmentedtickerplant,q\nlocalhost,{KDBBASEPORT}+102,wdb,wdbsymfilt,${TORQHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/wdb.q,1,-.wdb.tickerplanttypes segmentedtickerplant -.wdb.subsyms GOOG,q\nlocalhost,{KDBBASEPORT}+103,wdb,wdbtabfilt,${TORQHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/wdb.q,1,-.wdb.tickerplanttypes segmentedtickerplant -.wdb.subtabs quote,q\nlocalhost,{KDBBASEPORT}+104,segmentedtickerplant,stp1,${TORQHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/segmentedtickerplant.q,1,-schemafile ${TORQHOME}/database.q,q\n</code></pre> <p>As we can see here, three WDBs are being started up but with different parameters in the 'extras' column, meaning they will have different subscription behaviour. </p> <p>run.sh</p> <p>Since we need to run multiple shell commands to bring up all the processes and run the tests, it makes sense to move them to a file:</p> <pre><code>#!/bin/bash\n\n# Path to test directory\ntestpath=${KDBTESTS}/demo\n\n# Start procs\n${TORQHOME}/torq.sh start all -csv ${testpath}/process.csv\n\n# Start test proc\n/usr/bin/rlwrap q ${TORQHOME}/torq.q \\\n  -proctype test -procname test1 \\\n  -test ${testpath} \\\n  -load ${KDBTESTS}/helperfunctions.q ${testpath}/settings.q \\\n  -procfile ${testpath}/process.csv -debug\n\n# Shut down procs\n${TORQHOME}/torq.sh stop all -csv ${testpath}/process.csv\n</code></pre> <p>The first piece of code in this script simply sets a variable with the path for the test directory. Then the discovery, STP and WDB processes are started, with the custom CSV flag pointing to the file we just created above. If only a subset of the processes in that file are needed then they can be called by name instead of using 'all'. Next, our test process is started up with some extra flags. The <code>-load</code> flag allows other q files to be loaded, in this case we are loading a file of helper functions defined in the <code>KDBTESTS</code> directory and the <code>settings.q</code> file which will be explored in greater depth shortly. There is also a <code>-procfile</code> flag in use which, again, points to our custom process CSV, and this more easily allows the use of TorQ connection management in tests. Finally, once all the tests have been run and the test process exited, all the other processes are brought down. The tests can now be run from the command line with a simple <code>/path/to/tests/run.sh</code>.</p> <p>settings.q</p> <p>This file, while not strictly speaking necessary, is a very handy place to store variables and functions that will be used in the tests rather than having to declare them in the CSV itself. In this example we are storing TorQ connection parameters and test updates for the trade and quote tables:</p> <pre><code>// IPC connection parameters\n.servers.CONNECTIONS:`wdb`segmentedtickerplant`tickerplant;\n.servers.USERPASS:`admin:admin;\n\n// Test updates\ntesttrade:((5#`GOOG),5?`4;10?100.0;10?100i;10#0b;10?.Q.A;10?.Q.A;10#`buy);\ntestquote:(10?`4;(5?50.0),50+5?50.0;10?100.0;10?100i;10?100i;10?.Q.A;10?.Q.A;10#`3);\n</code></pre> <p>WDB Tests</p> <p>The following CSV shows a fairly straightforward use of this setup:</p> <pre><code>action,ms,bytes,lang,code,repeat,minver,comment\nbefore,0,0,q,.servers.startup[],1,,\"Start TorQ connection management\"\nbefore,0,0,q,.proc.sys \"sleep 2\",1,,\"Wait for proc to start\"\nbefore,0,0,q,stpHandle:gethandle[`stp1],1,,\"Open STP handle\"\nbefore,0,0,q,wdbHandles:`all`sym`tab!gethandle each `wdball`wdbsymfilt`wdbtabfilt,1,,\"Open WDB handles\"\nbefore,0,0,q,t1:wdbHandles[`all`sym] @\\: \"count trade\",1,,\"Get initial trade table counts\"\nbefore,0,0,q,q1:(value wdbHandles) @\\: \"count quote\",1,,\"Get initial quote table counts\"\nrun,0,0,q,\"stpHandle @/: `.u.upd ,/: ((`trade;testtrade);(`quote;testquote))\",1,,\"Send trade and quote updates to STP\"\nrun,0,0,q,.proc.sys \"sleep 2\",1,,\"Wait for updates to publish\"\ntrue,0,0,q,(t1+10 5)~wdbHandles[`all`sym] @\\: \"count trade\",1,,\"Check trade update was correctly published\"\ntrue,0,0,q,(q1+10 0 10)~(value wdbHandles) @\\: \"count quote\",1,,\"Check quote update was correctly published\"\n</code></pre> <p>The first thing that happens is that TorQ connection management is set up, then handles are opened to the STP and WDBs and some test updates are sent to the STP. Finally, the test process grabs the latest table counts from the WDBs and checks they have updated correctly. Note that functions and variables not defined in the test are brought in from the settings and helper function files.</p> <p>Our test directory now looks like this:</p> <pre><code>wdbtests\n|---- process.csv\n|---- run.sh\n|---- settings.q\n|---- test.csv\n</code></pre>"},{"location":"unittesting/#adding-functionality-to-the-run-script","title":"Adding functionality to the run script","text":"<p>In order to make our tests more dynamic and useful there are a few things we can do. In the <code>KDBTESTS</code> directory there is a <code>flagparse.sh</code> script which contains some basic code for parsing command line flags. If we add this line to the top of our run script:</p> <pre><code>source $KDBTESTS/flagparse.sh\n</code></pre> <p>We can now pass flags to our run script, and these are as follows:</p> Flag Description <code>-d</code> Starts the test process in debug mode <code>-s</code> Starts the test process in debug and stop mode (thrown out to q prompt on error or test failure) <code>-w</code> Writes test results to CSVs on disk <code>-q</code> Starts the test process in quiet mode <code>-r timestamp</code> Passes a timestamp into the tests for on-disk versioning <p>The other addition to be made is a <code>-testresults</code> flag to the TorQ start line in the run script. This passes in a folder where the test process will store its logs and test results in a date-partitioned folder structure. Our run script now looks like the following:</p> <pre><code>#!/bin/bash\n\n# Handle command-line arguments\nsource $KDBTESTS/flagparse.sh\n\n# Path to test directory\ntestpath=${KDBTESTS}/demo\n\n# Start procs\n${TORQHOME}/torq.sh start discovery1 stp1 wdball wdbsymfilt wdbtabfilt -csv ${testpath}/process.csv\n\n# Start test proc\n/usr/bin/rlwrap q ${TORQHOME}/torq.q \\\n  -proctype test -procname test1 \\\n  -test ${testpath} \\\n  -load ${KDBTESTS}/helperfunctions.q ${testpath}/settings.q \\\n  -testresults ${KDBTESTS}/demo/results/ \\\n  -runtime $run \\\n  -procfile ${testpath}/process.csv \\\n  $debug $stop $write $quiet\n\n# Shut down procs\n${TORQHOME}/torq.sh stop discovery1 stp1 wdball wdbsymfilt wdbtabfilt -csv ${testpath}/process.csv\n</code></pre> <p>Near the end we have four variables which are optional flags that will be added by the flag parser script. We now have plenty of options when it comes to running the script:</p> <pre><code># Run in debug mode\n./run.sh -d\n# Run in debug and stop mode\n./run.sh -s\n# Run in quiet mode, pass in a runtime and write results to disk\n./run.sh -r 2020.10.12D16:34:44.261143000 -wq\n</code></pre>"},{"location":"unittesting/#running-multiple-test-sets","title":"Running Multiple Test Sets","text":"<p>When testing a large piece of functionality it is very likely that there will a large number of tests to run. It is advised in such a case that the tests are split up into different technical groupings, each with their own folder with test CSVs, process and settings files and run scripts. This is essentially creating an isolated environment for each group of tests. The issue though is that it becomes cumbersome to run all tests, and so a script has been created which executes all the run scripts in each of the directories, saves their results to disk and displays them at the end of the run. </p> <p>The <code>runall.q</code> script lives in the <code>KDBTESTS</code> directory and it takes two arguments, <code>-rundir</code> and <code>-resdir</code>, which are the top level directory where your test sub-folders live, and the folder where the test logs and results are kept respectively. This script runs each of the <code>run.sh</code> scripts in each of the sub-folders in the <code>-rundir</code> folder in write and quiet mode, passing in the current timestamp so that all will be saved to disk in an easily-versioned manner. An example run would look like the following:</p> <pre><code>q runall.q -rundir /path/to/top/test/folder/ -resdir /path/to/results/folder/\n</code></pre>"},{"location":"unittesting/#debugging-tests","title":"Debugging Tests","text":"<p>In the scenario where there are a large number of tests spread across several folders, you can use the run-all mechanic to test them all. However, say there is an error in one of the test files. Normally, this would be fairly difficult to track down and deal with, but the features of this framework make it much easier. At the end of the run, three things will be shown on the console, a results table, a failures table and dictionary of error logs and any errors in them. Any tests that fail will be displayed in the fails table and any code errors that occur will be logged to disk and displayed in the dictionary, and both of these sources contain the file the test was in, the line number it is on and the code itself. </p> <p>A demo folder has been prepared which contains a code error and a test failure. All the tests in the folder were run as follows:</p> <pre><code>q runall.q -rundir demo -resdir demo/results\n</code></pre> <p>When the tests finish running the results are displayed on the console. There are various failed tests and an entry appears in our error logs which can be expanded out:</p> <pre><code>...\n\"Logged errors:\"\n:demo/results/2020.11.11/logs/err_eod.log| ()\n:demo/results/2020.11.11/logs/err_wdb.log| ,\"2020.11.11D16:37:21.716171000|aquaq-184|test|test1|ERR|KUexecerr|run error in file :/ho..\"\n...\nq) raze value errors\n\"2020.11.11D16:37:21.716171000|aquaq-184|test|test1|ERR|KUexecerr|run error in file :/home/mpotter/kdbCode/segtp/deploy/tests/demo/wdb/test.csv on line 8 - stHandle. Code: 'stHandle @/: `.u.upd ,/: ((`trade;testtrade);(`quote;testquote))'\"\n</code></pre> <p>The script has read the file <code>demo/results/2020.11.11/logs/err_wdb.log</code> and from the message within we can see that there is a code error in a 'run' command in the file <code>/home/mpotter/kdbCode/segtp/deploy/tests/demo/wdb/test.csv</code> on line 8, and the offending piece of code is also displayed. This may be enough information for us to solve the issue, but if not we can dig deeper. </p> <p>We can see that the error is coming from the WDB tests, and so we run those in debug mode in the following way:</p> <pre><code>./demo/wdb/run.sh -d\n</code></pre> <p>This runs the tests and displays the error message we saw earlier before outputting our test results and failures and leaving us in the q session. By examining the error message and being able to access the q session we can see that the variable <code>stHandle</code> should in fact be <code>stpHandle</code> and this typo is causing the error. Once this is fixed, it can be run again and the error doesn't appear any more. There is still one test failing, however:</p> <pre><code>q) select action,code,csvline from KUerr\naction code                                               csvline\n-----------------------------------------------------------------\ntrue   (t1+1 5)~t2:wdbHandles[`all`sym] @\\: \"count trade\" 10\n</code></pre> <p>The best way to debug this would be to be able to exit the tests as this line is being run and be able to examine it from there. We can do this by invoking the stop mode in our test script:</p> <pre><code>./demo/wdb/run.sh -s\n</code></pre> <p>This throws us out to the q prompt at this point in the tests with the following error:</p> <pre><code>'failed to load /home/mpotter/kdbCode/segtp/deploy/tests/runtests.q : true test failure in file :/home/mpotter/kdbCode/segtp/deploy/tests/demo/wdb/test.csv on line 10\n</code></pre> <p>We can get the code which failed and run it here to see what it returns. From doing some quick debugging we can see that one of the items being added to <code>t1</code> is wrong, it should be ten rather than 1. Once this is fixed we can run the WDB tests again and we see that there are now no errors and all the tests pass! We can then run all of our tests again as at the start and no new test failures come up and the latest error logs are empty.</p>"},{"location":"unittesting/#what-needs-tested","title":"What Needs Tested?","text":"<p>There are many areas that need tested in TorQ. There is a directory within TorQ named 'tests' where all the required tests are situated. The directories that contain the tests can be seen here;</p> <pre><code>.\n\u251c\u2500\u2500 bglaunchprocess\n\u251c\u2500\u2500 dataaccess\n\u251c\u2500\u2500 dqe\n\u251c\u2500\u2500 k4unit\n\u251c\u2500\u2500 merge\n\u251c\u2500\u2500 pcap\n\u251c\u2500\u2500 performance\n\u251c\u2500\u2500 permissions\n\u251c\u2500\u2500 rdb\n\u2514\u2500\u2500 stp\n</code></pre> <p>Each of these directories contain their own tests that need to be ran, apart from k4unit. In the 'bglaunchprocess' for example, there are the following files;</p> <pre><code>kod.q.acct  process.csv  run.sh  settings.q  test.csv\n</code></pre> <p>Now in this directory, we can run the tests by the following command;</p> <pre><code>bash run.sh -d\n</code></pre> <p>This will present us with 2 tables, a KUT which is a table with all the tests that have been ran, and a KUTR table which is the results of these tests.</p> <p>The purpose of testing is to ensure that any changes you have made to TorQ has not broken anything and that TorQ still functions properly. Therefore, these tests must be ran both on your development branch and on the master branch and compared in order to ensure nothing has been broken. The resulting tables can sometimes be extensive and difficult to compare from the console. I find the best way to compare the results is to apply a SQL statement to the KUTR table.</p> <pre><code>errors:select from KUTR where not ok\n</code></pre> <p>This statement will return a table of all the failed tests. If the errors table is then saved as a csv file on both branches by;</p> <pre><code>save `:errors.csv\n</code></pre> <p>These two csv's can easily be compared by a simple text comparison website. If there is no difference between these two tables, then nothing has been broken and that particular test can be deemed as a pass.</p> <p>All tests are ran in this manner apart from a few which are noted below.</p> <p>RDB</p> <p>The RDB does not contain the run.sh file like the majority of the other directories. In order to run this test, change directory into the tests directory, and run the aforementioned basic command used for running a test, changing the proctype to rdb and the procname to test1 as seen below:</p> <pre><code>q ${TORQHOME}/torq.q -proctype rdb -procname test1 -test rdb -debug\n</code></pre> <p>STP</p> <p>The STP contains 23 subdirectories, all of which containing their own test. All of which are tested by the standard;</p> <pre><code>bash run.sh -d\n</code></pre> <p>However when running this in the Stripe directory, you will not recieve the KUT and KUTR csv's. Instead, this test will create a new directory named 'results', situated in the STP directory. In results, there will be a subdirectory named stripe, then within that, the present day's date and finally in that directory, your test result csv's will be present.</p>"},{"location":"unittesting/#notes-on-best-practice","title":"Notes on Best Practice","text":"<p>Here are some recommendations on making test development more straightforward:</p> <ul> <li>Use TorQ connection management when dealing with multiple processes</li> <li>When just unit testing one process in isolation, run the tests from an instance of that process</li> <li>When performing integration tests that examine the interaction of multiple processes, run the tests from a 'blank' process where possible, as this ensures that test code and process code don't get in each other's way</li> <li>Put any variable or function declarations in a settings file so as not to clutter the test code</li> <li>If there are a large number of tests, split into folders of related tests</li> <li>Try to keep test output isolated from the rest of the application, ie. any logs or HDB data should be output to a separate testing location and cleared afterwards if appropriate</li> </ul>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#utilities","title":"Utilities","text":"<p>We have provided several utility scripts, which either implement developer aids or standard operations which are useful across processes.</p> <p></p>"},{"location":"utilities/#apiq","title":"api.q","text":"<p>This provides a mechanism for documenting and publishing function/variable/table or view definitions within the kdb+ process. It provides a search facility both by name and definition (in the case of functions). There is also a function for returning the approximate memory usage of each variable in the process in descending order.</p> <p>Definitions are added using the .api.add function. A variable can be marked as public or private, and given a description, parameter list and return type. The search functions will return all the values found which match the pattern irrespective of them having a pre-defined definition.</p> <p>Whether a value is public or private is defined in the definitions table. If not found then by default all values are private, except those which live in the .q or top level namespace.</p> <p>.api.f is used to find a function, variable, table or view based on a case-insensitive pattern search. If a symbol parameter is supplied, a wildcard search of *[suppliedvalue]* is done. If a string is supplied, the value is used as is, meaning other non-wildcard regex pattern matching can be done.</p> <pre><code>\n    q).api.f`max                                                                                                                                                                                                                    \n    name                | vartype   namespace public descrip             ..\n    --------------------| -----------------------------------------------..\n    maxs                | function  .q        1      \"\"                  ..\n    mmax                | function  .q        1      \"\"                  ..\n    .clients.MAXIDLE    | variable  .clients  0      \"\"                  ..\n    .access.MAXSIZE     | variable  .access   0      \"\"                  ..\n    .cache.maxsize      | variable  .cache    1      \"The maximum size in..\n    .cache.maxindividual| variable  .cache    1      \"The maximum size in..\n    max                 | primitive           1      \"\"                  ..\n    q).api.f\"max*\"                                                                                                                                                                                                                  \n    name| vartype   namespace public descrip params return\n    ----| ------------------------------------------------\n    maxs| function  .q        1      \"\"      \"\"     \"\"    \n    max | primitive           1      \"\"      \"\"     \"\"    \n\n</code></pre> <p>.api.torqnamespaces is a variable which returns a symbol list of torq  namespaces.</p> <p>.api.exportconfig uses the table returned by .api.f` to give a table of the current values and descriptions of variables within the inputted namespace. This can be used to quickly see what configurable variables are currently set to.</p> <p>.api.exportallconfig is .api.exportconfig evaluated with all the available torqnamespaces and returns the same format as .api.exportconfig.</p> <p>.api.p is the same as .api.f, but only returns public functions. .api.u is as .api.p, but only includes user defined values i.e. it excludes q primitives and values found in the .q, .Q, .h and .o namespaces. .api.find is a more general version of .api.f which can be used to do case sensitive searches.</p> <p>.api.s is used to search function definitions for specific values.</p> <pre><code>q).api.s\"*max*\"                                                                                                                                                                                                                 \nfunction            definition                                       ..\n---------------------------------------------------------------------..\n.Q.w                \"k){`used`heap`peak`wmax`mmap`mphy`syms`symw!(.\\\"..\n.clients.cleanup    \"{if[count w0:exec w from`.clients.clients where ..\n.access.validsize   \"{[x;y;z] $[superuser .z.u;x;MAXSIZE&gt;s:-22!x;x;'\\..\n.servers.getservers \"{[nameortype;lookups;req;autoopen;onlyone]\\n r:$..\n.cache.add          \"{[function;id;status]\\n \\n res:value function;\\n..\n</code></pre> <p>.api.m is used to return the approximate memory usage of variables and views in the process, retrieved using -22!. Views will be re-evaluated if required. Use .api.mem[0b] if you do not want to evaluate and return views.</p> <pre><code>q).api.m[]                                                                                                                                                                                                                      \nvariable          size    sizeMB\n--------------------------------\n.tz.t             1587359 2     \n.help.TXT         15409   0     \n.api.detail       10678   0     \n.proc.usage       3610    0     \n.proc.configusage 1029    0     \n..\n</code></pre> <p>.api.whereami[lambda] can be used to retrieve the name of a function given its definition. This can be useful in debugging.</p> <pre><code>q)g:{x+y}                                                                                                                                                                                                                                                                     \nq)f:{20 + g[x;10]}                                                                                                                                                                                                                                                            \nq)f[10]                                                                                                                                                                                                                                                                       \n40\nq)f[`a]                                                                                                                                                                                                                                                                       \n{x+y}\n`type\n+\n`a\n10\nq)).api.whereami[.z.s]                                                                                                                                                                                                                                                        \n`..g\n</code></pre>"},{"location":"utilities/#apidetailsq","title":"apidetails.q","text":"<p>This file in both the common and the handler directories is used to add to the api using the functions defined in api.q</p> <p></p>"},{"location":"utilities/#timerq","title":"timer.q","text":"<p>kdb+ provides a single timer function, .z.ts which is triggered with the frequency specified by -t. We have provided an extension to allow multiple functions to be added to the timer and fired when required. The basic concept is that timer functions are registered in a table, with .z.ts periodically checking the table and running whichever functions are required. This is not a suitable mechanism where very high frequency timers are required (e.g. sub 500ms).</p> <p>There are two ways a function can be added to a timer- either as a repeating timer, or to fire at a specific time. When a repeating timer is specified, there are three options as to how the timer can be rescheduled. Assuming that a timer function with period P is scheduled to fire at time T0, actually fires at time T1 and finishes at time T2, then</p> <ul> <li> <p>mode 0 will reschedule for T0+P;</p> </li> <li> <p>mode 1 will reschedule for T1+P;</p> </li> <li> <p>mode 2 will reschedule for T2+P.</p> </li> </ul> <p>Both mode 0 and mode 1 have the potential for causing the timer to back up if the finish time T2 is after the next schedule time. See .api.p\u201c.timer.*\u201dfor more details.</p> <p></p>"},{"location":"utilities/#asyncq","title":"async.q","text":"<p>kdb+ processes can communicate with each using either synchronous or asynchronous calls. Synchronous calls expect a response and so the server must process the request when it is received to generate the result and return it to the waiting client. Asynchronous calls do not expect a response so allow for greater flexibility. The effect of synchronous calls can be replicated with asynchronous calls in one of two ways (further details in section\u00a0gateway):</p> <ul> <li> <p>deferred synchronous: the client sends an async request, then blocks     on the handle waiting for the result. This allows the server more     flexibility as to how and when the query is processed;</p> </li> <li> <p>asynchronous postback: the client sends an async request which is       wrapped in a function to be posted back to the client when the       result is ready. This allows the server flexibility as to how and       when the query is processed, and allows the client to continue       processing while the server is generating the result.</p> </li> </ul> <p>The code for both of these can get a little tricky, largely due to the amount of error trapping required. We have provided two functions to allow these methods to be used more easily. .async.deferred takes a list of handles and a query, and will return a two item list of (success;results).</p> <pre><code>q).async.deferred[3 5;({system\"sleep 1\";system\"p\"};())]                                                                                                                                                                                     \n1    1   \n9995 9996\nq).async.deferred[3 5;({x+y};1;2)]                                                                                                                                                                                                          \n1 1\n3 3\nq).async.deferred[3 5;({x+y};1;`a)]                                                                                                                                                                                                         \n0                         0                        \n\"error: server fail:type\" \"error: server fail:type\"\nq).async.deferred[3 5 87;({system\"sleep 1\";system\"p\"};())]                                                                                                                                                                                  \n1     1     0                                       \n9995i 9996i \"error: comm fail: failed to send query\"\n</code></pre> <p>.async.postback takes a list of handles, a query, and the name or lambda of the postback function to return the result to. It will immediately return a success vector, and the results will be posted back to the client when ready.</p> <pre><code>q).async.postback[3 5;({system\"sleep 1\";system\"p\"};());`showresult]                                                                                                                                                                         \n11b\nq)                                                                                                                                                                                                                                          \nq)9995i\n9996i\n\nq).async.postback[3 5;({x+y};1;2);`showresult]                                                                                                                                                                                              \n11b\nq)3\n3\n\nq).async.postback[3 5;({x+y};1;`a);`showresult]                                                                                                                                                                                             \n11b\nq)\"error: server fail:type\"\n\"error: server fail:type\"\n\nq).async.postback[3 5;({x+y};1;`a);showresult]                                                                                                                                                                                              \n11b\nq)\"error: server fail:type\"\n\"error: server fail:type\"\n\nq).async.postback[3 5 87;({x+y};1;2);showresult]                                                                                                                                                                                            \n110b\nq)3\n3\n</code></pre> <p>For more details, see .api.p\u201c.async.*\u201d.</p> <p></p>"},{"location":"utilities/#cacheq","title":"cache.q","text":"<p>cache.q provides a mechanism for storing function results in a cache and returning them from the cache if they are available and non stale. This can greatly boost performance for frequently run queries.</p> <p>The result set cache resides in memory and as such takes up space. It is up to the programmer to determine which functions are suitable for caching. Likely candidates are those where some or all of the following conditions hold:</p> <ul> <li> <p>the function is run multiple times with the same parameters (perhaps     different clients all want the same result set);</p> </li> <li> <p>the result set changes infrequently or the clients can accept       slightly out-of-date values;</p> </li> <li> <p>the result set is not too large and/or is relatively expensive to       produce. For example, it does not make sense to cache raw data       extracts.</p> </li> </ul> <p>The cache has a maximum size and a minimum size for any individual result set, both of which are defined in the configuration file. Size checks are done with -22! which will give an approximation (but underestimate) of the result set size. In the worst case the estimate could be half the size of the actual size.</p> <p>If a new result set is to be cached, the size is checked. Assuming it does not exceed the maximum individual size then it is placed in the cache. If the new cache size would exceed the maximum allowed space, other result sets are evicted from the cache. The current eviction policy is to remove the least recently accessed result sets until the required space is freed. The cache performance is tracked in a table. Cache adds, hits, fails, reruns and evictions are monitored.</p> <p>The main function to use the cache is .cache.execute[function; staletime]. If the function has been executed within the last staletime, then the result is returned from the cache. Otherwise the function is executed and placed in the cache.</p> <p>The function is run and the result placed in the cache:</p> <pre><code>q)\\t r:.cache.execute[({system\"sleep 2\"; x+y};1;2);0D00:01]                                                                                                                                                                     \n2023\nq)r                                                                                                                                                                                                                             \n3\n</code></pre> <p>The second time round, the result set is returned immediately from the cache as we are within the staletime value:</p> <pre><code>q)\\t r1:.cache.execute[({system\"sleep 2\"; x+y};1;2);0D00:01]                                                                                                                                                                    \n0\nq)r1                                                                                                                                                                                                                            \n3\n</code></pre> <p>If the time since the last execution is greater than the required stale time, the function is re-run, the cached result is updated, and the result returned:</p> <pre><code>q)\\t r2:.cache.execute[({system\"sleep 2\"; x+y};1;2);0D00:00]                                                                                                                                                                    \n2008\nq)r2                                                                                                                                                                                                                            \n3\n</code></pre> <p>The cache performance is tracked:</p> <pre><code>q).cache.getperf[]                                                                                                                                                                                                              \ntime                          id status function                  \n------------------------------------------------------------------\n2013.11.06D12:41:53.103508000 2  add    {system\"sleep 2\"; x+y} 1 2\n2013.11.06D12:42:01.647731000 2  hit    {system\"sleep 2\"; x+y} 1 2\n2013.11.06D12:42:53.930404000 2  rerun  {system\"sleep 2\"; x+y} 1 2\n</code></pre> <p>See .api.p.cache.*for more details.</p> <p></p>"},{"location":"utilities/#emailq","title":"email.q","text":"<p>A library file is provided to allow TorQ processes to send emails using an SMTP server. This is a wrapper around the standard libcurl library. The library file is currently available for Windows (32 bit), Linux (32 and 64 bit) and OSX (32 and 64 bit). The associated q script contains two main methods for creating a connection and sending emails. The email library requires a modification to the path to find the required libs - see the top of email.q for details.</p> <p>The main connection method .email.connect takes a single dictionary parameter and returns 0i for success and -1i for failure.</p> Parameter Req Type Description url Y symbol URL of mail server e.g. smtp://mail.example.com user Y symbol Username of user to login as password Y symbol Password for user usessl N boolean Connect using SSL/TLS, defaults to false from N symbol Email from field, defaults to torq@aquaq.co.uk debug N integer Debug level. 0=no output, 1=normal output, 2=verbose output. Default is 1 <p>An example is:</p> <pre><code>q).email.connect[`url`user`password`from`usessl`debug!(`$\"smtp://mail.example.com:80\";`$\"torquser@aquaq.co.uk\";`hello;`$\"torquser@aquaq.co.uk\";0b;1i)]\n02 Jan 2015 11:45:19   emailConnect: url is set to smtp://mail.example.com:80\n02 Jan 2015 11:45:19   emailConnect: user is set to torquser@aquaq.co.uk\n02 Jan 2015 11:45:19   emailConnect: password is set\n02 Jan 2015 11:45:19   emailConnect: from is set torquser@aquaq.co.uk\n02 Jan 2015 11:45:19   emailConnect: trying to connect\n02 Jan 2015 11:45:19   emailConnect: connected, socket is 5\n0i\n</code></pre> <p>The email sending function .email.send takes a single dictionary parameter containing the details of the email to send. A connection must be established before an email can be sent. The send function returns an integer of the email length on success, or -1 on failure.</p> Parameter Req Type Description to Y symbol (list) addresses to send to subject Y char list email subject body Y list of char lists email body cc N symbol (list) cc list bodyType N symbol type of email body. Can be `text or `html. Default is `text debug N integer Debug level. 0=no output, 1=normal output,2=verbose output. Default is 1 <p>An example is:</p> <pre><code>q).email.send[`to`subject`body`debug!(`$\"test@aquaq.co.uk\";\"test email\";(\"hi\";\"this is an email from torq\");1i)]\n02 Jan 2015 12:39:29   sending email with subject: test email\n02 Jan 2015 12:39:29   email size in bytes is 16682\n02 Jan 2015 12:39:30   emailSend: email sent\n16682i\n</code></pre> <p>Note that if emails are sent infrequently the library must re-establish the connection to the mail server (this will be done automatically after the initial connection). In some circumstances it may be better to batch emails together to send, or to offload email sending to separate processes as communication with the SMTP server can take a little time.</p> <p>Two additional functions are available, .email.connectdefault and .email.senddefault. These are as above but will use the default configuration defined within the configuration files as the relevant parameters passed to the methods. In addition, .email.senddefault will automatically establish a connection.</p> <pre><code>q).email.senddefault[`to`subject`body!(`$\"test@aquaq.co.uk\";\"test email\";(\"hi\";\"this is an email from torq\"))]\n2015.01.02D12:43:34.646336000|aquaq||discovery1|INF|email|sending email\n2015.01.02D12:43:35.743887000|aquaq||discovery1|INF|email|connection to mail server successful\n2015.01.02D12:43:37.250427000|aquaq|discovery1|INF|email|email sent\n16673i\nq).email.senddefault[`to`subject`body!(`$\"test@aquaq.co.uk\";\"test email 2\";(\"hi\";\"this is an email from torq\"))]\n2015.01.02D12:43:48.115403000|aquaq|discovery1|INF|email|sending email\n2015.01.02D12:43:49.385807000|aquaq|discovery1|INF|email|email sent\n16675i\nq).email.senddefault[`to`subject`body!(`$\"test@aquaq.co.uk\";\"test email 2\";(\"hi\";\"this is an email from torq\");`\"$/home/ashortt/example.txt\")]\n2015.01.02D12:43:48.115403000|aquaq|discovery1|INF|email|sending email\n2015.01.02D12:43:49.385807000|aquaq|discovery1|INF|email|email sent\n47338i\n</code></pre> <p>.email.test will attempt to establish a connection to the default configured email server and send a test email to the specified address. debug should be set to 2i (verbose) to extract the full information.</p> <pre><code>q).email.debug:2i\nq).email.test `$\"test@aquaq.co.uk\"\n...\n</code></pre> <p>A further function .email.sendviaservice can be used to send an email using the default mail server on a separate specified process and can be used to allow latency sensitive processes to offload this piece of functionality. </p> <p>The function takes two parameters a process and a dictionary which should follow  the same format as .email.send. The function uses the .async.postback Utility to send the email by calling .email.servicesend on the specified process. The postback function immediately returns a success boolean indicating that the the async request has been sent and when the function has been run on the server the results are posted back to the client function  email.servicecallback which logs the email status.</p> <pre><code>q).email.sendviaservice[`emailservice;`to`subject`body!(`$\"test@aquaq.co.uk\";\"test email\";(\"hi\";\"this is an email from torq\"))]\n1b\nq)2019.01.04D12:02:57.641940000|gateway|gateway1|INF|email|Email sent successfully\n\n</code></pre> <p>Additionally functions are available within the email library. See .api.p.email.*for more details.</p>"},{"location":"utilities/#emails-with-ssl-certificates-from-windows","title":"Emails with SSL certificates from Windows","text":"<p>If you wish to send emails via an account which requires authentication from Windows (e.g. Hotmail, Gmail) then you have to do a few extra steps as usessl must be true and Windows does not usually find the correct certificate. The steps are:</p> <ul> <li> <p>download     this     and save it to your PC</p> </li> <li> <p>set</p> <pre><code>  CURLOPT_CAINFO=c:/path/to/cabundle_file/ca-bundle.crt\n</code></pre> </li> </ul> <p>More information is available here and here</p> <p></p>"},{"location":"utilities/#timezoneq","title":"timezone.q","text":"<p>A slightly customised version of the timezone conversion functionality from code.kx. It loads a table of timezone information from $KDBCONFIG. See .api.p.tz.*for more details.</p> <p></p>"},{"location":"utilities/#compressq","title":"compress.q","text":"<p>compress.q applies compression to any kdb+ database, handles all partition types including date, month, year, int, and can deal with top level splayed tables. It will also decompress files as required. Once the compression/decompression is complete, summary statistics are returned, with detailed statistics for each compressed or decompressed file held in a table.</p> <p>The utility is driven by the configuration specified within a csv file. Default parameters can be given, and these can be used to compress all files within the database. However, the compress.q utility also provides the flexibility to compress different tables with different compression parameters, and different columns within tables using different parameters. A function is provided which will return a table showing each file in the database to be compressed, and how, before the compression is performed.</p> <p>Compression is performed using the -19! operator, which takes 3 parameters; the compression algorithm to use (0 - none, 1 - kdb+ IPC, 2 - gzip), the compression blocksize as a power of 2 (between 12 and 19),   and the level of compression to apply (from 0 - 9, applicable only for   gzip). (For further information on -19! and the parameters used, see   code.kx.com.)</p> <p>The compressionconfig.csv file should have the following format:</p> <pre><code>table,minage,column,calgo,cblocksize,clevel\ndefault,20,default,2,17,6\ntrades,20,default,1,17,0\nquotes,20,asize,2,17,7\nquotes,20,bsize,2,17,7\n</code></pre> <p>This file can be placed in the config folder, or a path to the file given at run time.</p> <p>The compression utility compresses all tables and columns present in the HDB but not specified in the driver file according the default parameters. In effect, to compress an entire HDB using the same compression parameters, a single row with name default would suffice. To specify that a particular table should be compressed in a certain different manner, it should be listed in the table. If default is given as the column for this table, then all of the columns of that table will be compressed accordingly. To specify the compression parameters for particular columns, these should be listed individually. For example, the file above will compress trades tables 20 days old or more with an algorithm of 1, and a blocksize of 17. The asize and bsize columns of any quotes tables older than 20 days old will be compressed using algorithm 2, blocksize 17 and level 7. All other files present will be compressed according to the default, using an algorithm 2, blocksize 17 and compression level 6. To leave files uncompressed, you must specify them explicitly in the table with a calgo of 0. If the file is already compressed, note that an algorithm of 0 will decompress the file.</p> <p>This utility should be used with caution. Before running the compression it is recommended to run the function .cmp.showcomp, which takes three parameters - the path to the database, the path to the csv file, and the maximum age of the files to be compressed:</p> <pre><code>.cmp.showcomp[`:/full/path/to/HDB;.cmp.inputcsv;maxage]   \n        /- for using the csv file in the config folder\n.cmp.showcomp[`:/full/path/to/HDB;`:/full/path/to/csvfile;maxage]    \n        /- to specify a file\n</code></pre> <p>This function produces a table of the files to be compressed, the parameters with which they will be compressed, and the current size of the file. Note that the current size column is calculated using hcount; on a file which is already compressed this returns the uncompressed length, i.e. this cannot be used as a signal as to whether the file is compressed already.</p> <pre><code>fullpath                        column table  partition  age calgo cblocksize clevel compressage currentsize\n-------------------------------------------------------------------------------------\n:/home/hdb/2013.11.05/depth/asize1 asize1 depth  2013.11.05 146 0     17         8      1           787960\n:/home/hdb/2013.11.05/depth/asize2 asize2 depth  2013.11.05 146 0     17         8      1           787960\n:/home/hdb/2013.11.05/depth/asize3 asize3 depth  2013.11.05 146 0     17         8      1           787960\n:/home/hdb/2013.11.05/depth/ask1   ask1   depth  2013.11.05 146 0     17         8      1           1575904\n....\n</code></pre> <p>To then run the compression function, use .cmp.compressmaxage with the same parameters as .cmp.showcomp (hdb path, csv path, maximum age of files):</p> <pre><code>.cmp.compressmaxage[`:/full/path/to/HDB;.cmp.inputcsv;maxage]   \n        /- for using the csv file in the config folder\n.cmp.compressmaxage[`:/full/path/to/HDB;`:/full/path/to/csvfile;maxage]    \n        /- to specify a file\n</code></pre> <p>To run compression on all files in the database disregarding the maximum age of the files (i.e. from minage as specified in the configuration file to infinitely old), then use:</p> <pre><code>.cmp.docompression[`:/full/path/to/HDB;.cmp.inputcsv]   \n        /- for using the csv file in the config folder\n.cmp.docompression[`:/full/path/to/HDB;`:/full/path/to/csvfile]    \n        /- to specify a file\n</code></pre> <p>Logs are produced for each file which is compressed or decompressed. Once the utility is complete, the statistics of the compression are also logged. This includes the memory savings in MB from compression, the additional memory usage in MB for decompression, the total compression ratio, and the total decompression ratio:</p> <pre><code>|comp1|INF|compression|Memory savings from compression: 34.48MB. Total compression ratio: 2.51.\n|comp1|INF|compression|Additional memory used from de-compression: 0.00MB. Total de-compression ratio: .\n|comp1|INF|compression|Check .cmp.statstab for info on each file.\n</code></pre> <p>A table with the compressed and decompressed length for each individual file, in descending order of compression ratio, is also produced. This can be found in .cmp.statstab:</p> <pre><code>file                    algo compressedLength uncompressedLength compressionratio\n-----------------------------------------------------------------------------------\n:/hdb/2014.03.05/depth/asize1 2    89057            772600             8.675343\n:/hdb/2014.01.06/depth/asize1 2    114930           995532             8.662073\n:/hdb/2014.03.05/depth/bsize1 2    89210            772600             8.660464\n:/hdb/2014.03.12/depth/bsize1 2    84416            730928             8.658643\n:/hdb/2014.01.06/depth/bsize1 2    115067           995532             8.651759\n.....\n</code></pre> <p>A note for windows users - windows supports compression only with a compression blocksize of 16 or more.</p> <p></p>"},{"location":"utilities/#dataloaderq","title":"dataloader.q","text":"<p>This script contains some utility functions to assist in loading data from delimited files (e.g. comma separated, tab delimited). It is a more generic version of the data loader example on code.kx. The supplied functions allow data to be read in configurable size chunks and written out to the database. When all the data is written, the on-disk data is re-sorted and the attributes are applied. The main function is .loader.loadalldata which takes two parameters- a dictionary of loading parameters and a directory containing the files to read. The dictionary should/can have the following fields:</p> Parameter Req Type Description headers Y symbol list Names of the header columns in the file types Y char list Data types to read from the file separator Y char[list] Delimiting character. Enlist it if first line of file is header data tablename Y symbol Name of table to write data to dbdir Y symbol Directory to write data to symdir N symbol Directory to enumerate against partitiontype N symbol Partitioning to use. Must be one of `date`month`year`int. Default is `date partitioncol N symbol Column to use to extract partition information.Default is `time dataprocessfunc N function Diadic function to process data after it has been read in. First argument is load parameters dictionary, second argument is data which has been read in. Default is {[x;y] y} chunksize N int Data size in bytes to read in one chunk. Default is 100 MB compression N int list Compression parameters to use e.g. 17 2 6. Default is empty list for no compression gc N boolean Whether to run garbage collection at appropriate points. Default is 0b (false) filepattern N char[list] Pattern used to only load certain files e.g. \".csv\",(\".csv\",\"*.txt\") <p>Example usage:</p> <pre><code>.loader.loadallfiles[`headers`types`separator`tablename`dbdir!(`sym`time`price`volume;\"SP  FI\";\",\";`trade;`:hdb); `:TDC/toload]\n.loader.loadallfiles[`headers`types`separator`tablename`dbdir`dataprocessfunc`chunksize`partitiontype`partitioncol`compression`gc`filepattern!(`sym`time`price`volume;\"SP  FI\";enlist\",\";`tradesummary;`:hdb;{[p;t] select sum size, max price by date:time.date from t};`int$500*2 xexp 20;`month;`date;16 1 0;1b;(\"*.csv\";\"*.txt\")); `:TDC/toload]\n</code></pre> <p></p>"},{"location":"utilities/#subscriptionsq","title":"subscriptions.q","text":"<p>The subscription utilities allow multiple subscriptions to different data sources to be managed and maintained. Automatic resubscriptions in the event of failure are possible, along as specifying whether the process will get the schema and replay the log file from the remote source (e.g. in the case of tickerplant subscriptions).</p> <p>.sub.getsubscriptionhandles is used to get a table of processes to subscribe to. It takes a process type and process name, where <code>()</code> or a null symbol can be used for all:</p> <pre><code>.sub.getsubscriptionhandles[`tickerplant;();()!()]      / all processes of type tickerplant\n.sub.getsubscriptionhandles[`;`rdb1;()!()]              / all processes called 'rdb1'\n.sub.getsubscriptionhandles[`;`;()!()]                  / all processes\n.sub.getsubscriptionhandles[();();()!()]                / nothing\n</code></pre> <p>.sub.subscribe is used to subscribe to a process for the supplied list of tables and instruments. For example, to subscribe to instruments A, B and C for the quote table from all tickerplants:</p> <pre><code>.sub.subscribe[`trthquote;`A`B;0b;0b] each .sub.getsubscriptionhandles[`tickerplant;();()!()]\n</code></pre> <p>The subscription method uses backtick for \u201call\u201d (which is the same as kdb+tick). To subscribe to all tables, all instruments, from all tickerplants:</p> <pre><code>.sub.subscribe[`;`;0b;0b] each .sub.getsubscriptionhandles[`tickerplant;();()!()]\n</code></pre> <p>See .api.p\u201c.sub.*\u201d for more details.</p> <p></p>"},{"location":"utilities/#pubsubq","title":"pubsub.q","text":"<p>This file defines the <code>.ps</code> namespace, which contains various functions for subscribing and publishing to processes. These functions have traditionally been wrappers for some of the functions found in <code>u.q</code>, but the advent of the Segmented Tickerplant has brought about a more fully-featured pub/sub library, which is now leveraged by the <code>.ps</code> functions. This library is part of the 'common' code, so to load it in by default <code>.proc.loadcommoncode</code> must be set to true.</p> <p>The following three functions are primarily associated with the pub/sub library:</p> <ul> <li><code>.ps.initialise</code> - this is a wrapper for <code>.stpps.init</code> and it sets up several data structures in the <code>.stpps</code> namespace using the tables loaded into memory. This is automatically called on process start up.</li> <li><code>.ps.subscribe</code> - this wraps <code>.u.sub</code> and it receives subscription requests from other processes and populates subscription tables in memory</li> <li><code>.ps.publish</code> - this is a wrapper for <code>.stpps.pub</code> and it publishes data to subscribers using the information given on subscription</li> </ul> <p>For example:</p> <pre><code>// Subscribe to all tables and symbols\nhandletosubscriber(`.ps.subscribe;`;`)\n\n// Subscribe to all tables and subset of symbols\nhandletosubscriber(`.ps.subscribe;`;`AAPL`GOOG)\n\n// Subscribe to Microsoft quotes only\nhandletosubscriber(`.ps.subscribe;`quote;enlist `MSFT)\n</code></pre> <p>There are two new functions which have been added that wrap <code>.u.sub</code> with the goal of making it easier for non-kdb+ processes to subscribe using strings:</p> <ul> <li><code>.ps.subtable</code> - accepts two strings, a table and a comma-separated list of instruments respectively</li> <li><code>.ps.subtablefiltered</code> - accepts 3 strings representing a table, where clause and a list of columns</li> </ul> <p>For example:</p> <pre><code>// Subscribe to Google and Apple trades\nhandletoSTP(`.ps.subtable;\"trade\";\"GOOG\",\"AAPL\")\n\n// Subscribe to time, sym and bid price data for quotes where bid &gt; 50\n.ps.subtablefiltered[\"quote\";\"bid&gt;50.0\";\"time,sym,bid\"]\n</code></pre> <p>Subscribing to the STP works in a very similar fashion to the original tickerplant. From the subscriber's perspective the subscription logic is backwardly compatible: it opens a handle to the STP and calls <code>.u.sub</code> with a list of tables to subscribe to as its first argument and either a null symbol or a list of symbols as a sym filter.  The STP also supports a keyed table of conditions (in q parse format) and a list of columns that should be published.</p> <p>Whilst complex bespoke subscription is possible in the STP it is generally not recommended. Complex subscription filtering should be off loaded to a chained STP.</p> <pre><code>// Subscribe to everything\nhandletoSTP(`.u.sub;`;`)\n\n// Subscribe GOOG and AAPL symbols in the trade table\nhandletoSTP(`.u.sub;`trade;`GOOG`AAPL)\n\n// Subscribe to all tables but with custom conditions\nhandletoSTP(`.u.sub;`;conditions)\n...\nq) show conditions\ntabname| filts             columns         \n-------| ----------------------------------\ntrade  | \"\"                \"time,sym,price\"\nquote  | \"bid&gt;100,bid&lt;200\" \"\"                        \n</code></pre> <p>Here subscribing subject to the conditions table results in the subscriber only receiving quotes where the bid is between 100 and 200. Also only the time, sym and price columns of the trade table are published to the subscriber. Note that it is also possible to use the conditions table to subscribe to just one of the trade or quote tables. A conditions table may also be used to perform calculations on columns and define new ones as well:</p> <pre><code>q) show conditions\ntabname| filts             columns                           \n-------| ----------------------------------------------------\nquote  | \"bid&gt;100,bid&lt;200\" \"time,sym,bid,ask,mid:0.5*bid+ask\"\n\nq)quote\ntime                          sym  bid   ask   mid    \n------------------------------------------------------\n2020.12.09D15:29:23.183738000 INTC 58.6  59.4  59     \n2020.12.09D15:29:23.183738000 DOW  21.39 22.53 21.96  \n...\n</code></pre> <p>For more information on subscriptions, see the documentation on the segmented tickerplant process.</p>"},{"location":"utilities/#data-striping","title":"Data striping","text":"<p>Data striping is the technique of logically segmenting data between processes so that they are stored on different processes.</p> <p>The advantages of striping include performance and throughput improvements. Segmenting data on separate processes reduces latency when processing data. Total data throughput is increased as multiple processes can be accessed concurrently. In addition, the memory footprint per process is lower and processes can be split across multiple hosts. It is useful for load balancing across processes.</p> <p>The reduction in data access in each process cumulatively multiplies the data throughput by the number of processes. It also allows the process to complete its task faster and without interruption, thereby reducing latency.</p> <p>Example of data striping in TorQ</p> <p>A simple but effective way of data striping is to do it divide the data randomly across all processes. This will ensure an even distribution of data. However, querying (locating and retrieving) data can become complicated.</p> <p>A common method for data striping between processes is to use an instrument (sym) filter. For example, to stripe data across 2 RDB processes, data with symbols starting with A-M and N-L will be striped to RDB1 and RDB2 respectively. However, a major problem with this method is the uneven distribution of data (a lot of symbols tend to start with A for example).</p> <p>Data hash striping</p> <p>A way to get around this problem is to stripe the data using a hash value which allows for better distribution. The hash function will store the mappings for the symbols that it has already computed and for subsequent requests for those symbols, it looks them up. It is loaded into the segmented tickerplant to use as subscription requests. The hash function has to be highly performant as it will potentially be invoked ~100-1000times/s in a core (potential bottleneck) component. For this purpose, a fast, simple and non-cryptographic hash function is created to segment the data since the performance of the segmented tickerplant is of paramount importance. The hash map is created by summing the ASCII codes of each input string then dividing by the number of segements.</p> <p>A hash map based on the <code>sym</code> column is created like so:</p> <pre><code>q)show sym:`$-100000?(thrl cross .Q.A),thrl:(.Q.A cross .Q.A cross .Q.A)\n`AWNM`MFLD`XWTL`OVIH`HAMI`OFDX`MWNC`BLJT`MVOR`TVAG`RGUU`MZCY`HLTW`RJVZ`MAYS`O..\nq)sym!(sum each string sym)mod 4\nAWNM| 3\nMFLD| 3\nXWTL| 3\nOVIH| 2\nHAMI| 3\nOFDX| 1\nMWNC| 1\nBLJT| 0\nMVOR| 0\n..\n</code></pre> <p>Using a hash function ensures better distribution of symbols across databases:</p> <pre><code>q)count each group sym!(sum each string sym)mod 4\n3| 25077\n2| 24920\n1| 24877\n0| 25126\n</code></pre> <p>An advantage of using data hash striping is such that a specific symbol will always be striped to the exact location based on the number of segments.</p>"},{"location":"utilities/#setting-up-data-striping-in-torq","title":"Setting up data striping in TorQ","text":"<p>1) Example setup for data striping across ALL (4) RDB instances</p> <p>$KDBCONFIG/process.csv</p> <p>The process file should contain the RDB instances by specifying a different <code>port</code> and <code>procname</code> column. Set the <code>load</code> column to <code>${KDBCODE}/processes/rdb.q</code>.</p> <p>NOTE</p> <ul> <li>The <code>procname</code> convention should always start with <code>rdb1</code></li> <li>Increment by 1 for each RDB instance</li> <li>In the following format: <code>rdb{i}</code></li> <li>There is no need to create separate <code>rdb{i}.q</code> files</li> </ul> <p><code>$KDBCONFIG/process.csv</code> should look something like this:</p> <pre><code>host,port,proctype,procname,U,localtime,g,T,w,load,startwithall,extras,qcmd\nlocalhost,{KDBBASEPORT}+1,discovery,discovery1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/discovery.q,1,,q\nlocalhost,{KDBBASEPORT}+2,segmentedtickerplant,stp1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/segmentedtickerplant.q,1,-schemafile ${TORQAPPHOME}/database.q -tplogdir ${KDBTPLOG},q\nlocalhost,{KDBBASEPORT}+3,rdb,rdb1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\nlocalhost,{KDBBASEPORT}+4,rdb,rdb2,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\nlocalhost,{KDBBASEPORT}+5,rdb,rdb3,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\nlocalhost,{KDBBASEPORT}+6,rdb,rdb4,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\n</code></pre> <p>$KDBCONFIG/rdbsub/rdbsub{i}.csv The <code>rdbsub{i}.csv</code> should be modified like this:</p> <pre><code>tabname,filters,columns\ntrade,.ds.stripe[sym;{i-1}],\nquote,.ds.stripe[sym;{i-1}],\n</code></pre> <p>$KDBAPPCONFIG/settings/rdb.q</p> <p>Set <code>.rdb.subfiltered: 1b</code> (default is 0b)</p> <p>$KDBAPPCONFIG/settings/default.q</p> <p>Add <code>.ds.numseg: {4}i</code></p> <p>2) Example setup for data striping across SOME RDB instances</p> <ul> <li>2 RDB instances unfiltered</li> <li>2 RDB instances striped</li> </ul> <p>$KDBCONFIG/process.csv</p> <p>Add in <code>-.rdb.subfiltered 1</code> (to enable striping) in the <code>extras</code> column for the striped RDB instances.</p> <p>NOTE</p> <ul> <li>It is <code>-.rdb.subfiltered 1</code> and not <code>-.rdb.subfiltered 1b</code></li> <li>The RDB instances must be grouped according to those being striped first</li> <li>i.e. <code>rdb1</code>, <code>rdb2</code> are striped and <code>rdb3</code>, <code>rdb4</code> are unfiltered</li> </ul> <p><code>$KDBCONFIG/process.csv</code> should look something like this:</p> <pre><code>host,port,proctype,procname,U,localtime,g,T,w,load,startwithall,extras,qcmd\nlocalhost,{KDBBASEPORT}+1,discovery,discovery1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/discovery.q,1,,q\nlocalhost,{KDBBASEPORT}+2,segmentedtickerplant,stp1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,0,,,${KDBCODE}/processes/segmentedtickerplant.q,1,-schemafile ${TORQAPPHOME}/database.q -tplogdir ${KDBTPLOG},q\nlocalhost,{KDBBASEPORT}+3,rdb,rdb1,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,-.rdb.subfiltered 1,q\nlocalhost,{KDBBASEPORT}+4,rdb,rdb2,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,-.rdb.subfiltered 1,q\nlocalhost,{KDBBASEPORT}+5,rdb,rdb3,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\nlocalhost,{KDBBASEPORT}+6,rdb,rdb4,${TORQAPPHOME}/appconfig/passwords/accesslist.txt,1,1,180,,${KDBCODE}/processes/rdb.q,1,,q\n</code></pre> <p>$KDBAPPCONFIG/settings/rdb.q</p> <p>Ensure <code>.rdb.subfiltered: 0b</code></p> <p>$KDBAPPCONFIG/settings/default.q</p> <p>Add <code>.ds.numseg: {2}i</code></p> <p>3) Data striping for general subscribers</p> <p>{subscriber}.q</p> <p>Add the conditions required (using the data hash striping function).</p> <pre><code>...\n// Subscribe to all tables but with custom conditions\nconditions:1!flip`tabname`filters`columns!(`trade`quote;(\".ds.stripe[sym;0]\";\".ds.stripe[sym;1]\");(\"\";\"\"))\nhandletoSTP(`.u.sub;`;conditions)\n...\n</code></pre> <pre><code>q)conditions\ntabname| filters                    columns\n-------| ----------------------------------\ntrade  | \".ds.stripe[sym;0]\" \"\"\nquote  | \".ds.stripe[sym;1]\" \"\"\n\nq)handletoSTP\".stpps.subrequestfiltered\"\ntbl       handle filts                            columns\n---------------------------------------------------------\nlogmsg    21     ()                                      \npackets   21     ()                                      \nquote     21     (`.ds.stripe;`sym;1)        \nquote_iex 21     ()                                      \ntrade     21     (`.ds.stripe;`sym;0)        \ntrade_iex 21     ()                                      \n</code></pre> <p></p>"},{"location":"utilities/#kafkaq","title":"kafka.q","text":"<p>kafka.q provides q language bindings for Apache Kafka, a 'distributed streaming platform', a real time messaging system with persistent storage in message logs.</p> <p>The core functionality of Kafka \u2013 pub/sub messaging with persisted logs, will be familiar to most readers as the functionality offered by the kdb+ tick tickerplant. The tickerplant log allows the real time database and other consumers to replay a day\u2019s events to recover state. An application architecture built around Kafka could dispense with a tickerplant component, and have RDBs and other real time clients query Kafka on startup for offsets, and play back the data they need. While not suitable for very low latency access to streaming data, it would carry some advantages for very high throughput applications, particularly those in the cloud:</p> <ul> <li>Kafka\u2019s distributed nature should allow it to scale more transparently than splitting tickerplants by instrument universe or message type</li> <li>Replaying from offsets is the same interface as live pub/sub and doesn\u2019t require filesystem access to the tickerplant log, so RDB\u2019s and other consumer could be on a different server</li> </ul> <p>By default, the Kafka bindings will be loaded into all TorQ processes running on l64 systems (the only platform currently supported). An example of usage is shown here (this assumes a local running instance of kafka - instructions for this are available on the kafkaq github  repo):</p> <pre><code>q).kafka.initconsumer[`localhost:9092;()]\nq).kafka.initproducer[`localhost:9092;()]\nq)kupd / print default definition for incoming data - ignore key, print message\nas ascii\n{[k;x] -1 `char$x;}\nq).kafka.subscribe[`test;0] / subscribe to topic test, partition 0\nq)pub:{.kafka.publish[`test;0;`;`byte$x]} / define pub to publish text input to topic\ntest on partition 0 with no key defined\nq)pub\"hello world\"\nq)hello world\n\n</code></pre> <p>Limitations of the current implementation:</p> <ul> <li>Only l64 supported</li> <li>Single consumer thread subscribed to one topic at a time</li> </ul> <p></p>"},{"location":"utilities/#tplogutilsq","title":"tplogutils.q","text":"<p>tplogutils.q contains functions for recovering tickerplant log files. Under certain circumstances the tickerplant log file can become corrupt by having an invalid sequence of bytes written to it. A log file can be recovered using a simple recovery method. However, this will only recover messages up to the first invalid message. The recovery functions defined in tplogutils.q allow all valid messages to be recovered from the tickerplant log file.</p> <p></p>"},{"location":"utilities/#monitoringchecksq","title":"monitoringchecks.q","text":"<p>monitoringchecks.q implements a set of standard, basic monitoring checks. They include checks to ensure:</p> <ul> <li> <p>table sizes are increasing during live capture</p> </li> <li> <p>the HDB data saves down correctly</p> </li> <li> <p>the allocated memory of a process does not increase past a certain       size</p> </li> <li> <p>the size of the symbol list in memory doesn\u2019t grow to big</p> </li> <li> <p>the process does not have too much on its pending subscriber queue</p> </li> </ul> <p>These checks are intended to be run by the reporter process on a schedule, and any alerts emailed to an appropriate recipient list.</p> <p></p>"},{"location":"utilities/#heartbeatq","title":"heartbeat.q","text":"<p>heartbeat.q implements heartbeating, and relies on both timer.q and pubsub.q. A table called heartbeat will be published periodically, allowing downstream processes to detect the availability of upstream components. The heartbeat table contains a heartbeat time and counter. The heartbeat script contains functions to handle and process heartbeats and manage upstream process failures. See .api.p.hb.*for details.</p>"},{"location":"utilities/#rmvrq","title":"rmvr.q","text":"<p>This file contains a function which can be used to convert environment variable paths into a full path from the root directory.</p>"},{"location":"utilities/#osq","title":"os.q","text":"<p>A file with various q functions to perform system operations. This will detect your operating system and will perform the correct commands depending on what you are using.</p> <p>This is a modification of a script developed by Simon Garland.</p> <p></p>"},{"location":"utilities/#dbwriteutilsq","title":"dbwriteutils.q","text":"<p>This contains a set of utility functions for writing data to historic databases.</p>"},{"location":"utilities/#sorting-and-attributes","title":"Sorting and Attributes","text":"<p>The sort utilities allow the sort order and attributes of tables to be globally defined. This helps to manage the code base when the data can potentially be written from multiple locations (e.g. written from the RDB, loaded from flat file, replayed from the tickerplant log). The configuration is defined in a csv which defaults to $KDBCONFG/sort.csv. The default setup is that every table is sorted by sym and time, with a p attribute on sym (this is the standard kdb+ tick configuration).</p> <pre><code>aquaq$ tail config/sort.csv \ntabname,att,column,sort\ndefault,p,sym,1\ndefault,,time,1\n</code></pre> <p>As an example, assume we have an optiontrade table which we want to be different from the standard set up. We would like the table to be sorted by optionticker and then time, with a p attribute on optionticker. We also have a column called underlyingticker which we can put an attribute on as it is derived from optionticker (so there is an element of de-normalisation present in the table). We also have an exchange field which we would like to put a g attribute on. All other tables we want to be sorted and parted in the standard way. The configuration file would look like this (sort order is derived from the order within the file combined with the sort flag being set to true):</p> <pre><code>aquaq$ tail config/sort.csv                \ntabname,att,column,sort\ndefault,p,sym,1\ndefault,,time,1\noptiontrade,p,optionticker,1\noptiontrade,,exchtime,1\noptiontrade,p,underlyingticker,0\noptiontrade,g,exchange,0\n</code></pre> <p>To invoke the sort utilities, supply a list of (tablename; partitions) e.g.</p> <pre><code>q).sort.sorttab(`trthtrade;`:hdb/2014.11.20/trthtrade`:hdb/2014.11.20/trthtrade)\n2014.12.03D09:56:19.214006000|aquaq|test|INF|sort|sorting the trthtrade table\n2014.12.03D09:56:19.214045000|aquaq|test|INF|sorttab|No sort parameters have been specified for : trthtrade. Using default parameters\n2014.12.03D09:56:19.214057000|aquaq|test|INF|sortfunction|sorting :hdb/2014.11.19/trthtrade/ by these columns : sym, time\n2014.12.03D09:56:19.219716000|aquaq|test|INF|applyattr|applying p attr to the sym column in :hdb/2014.11.19/trthtrade/\n2014.12.03D09:56:19.220846000|aquaq|test|INF|sortfunction|sorting :hdb/2014.11.20/trthtrade/ by these columns : sym, time\n2014.12.03D09:56:19.226008000|aquaq|test|INF|applyattr|applying p attr to the sym column in :hdb/2014.11.20/trthtrade/\n2014.12.03D09:56:19.226636000|aquaq|test|INF|sort|finished sorting the trthtrade table\n</code></pre> <p>A different sort configuration file can be loaded with</p> <pre><code>.sort.getsortcsv[`:file]\n</code></pre>"},{"location":"utilities/#garbage-collection","title":"Garbage Collection","text":"<p>The garbage collection utility prints some debug information before and after the garbage collection.</p> <pre><code>q).gc.run[]                                                                                                                                                      \n2014.12.03D10:22:51.688435000|aquaq|test|INF|garbagecollect|Starting garbage collect. mem stats: used=2 MB; heap=1984 MB; peak=1984 MB; wmax=0 MB; mmap=0 MB; mphy=16384 MB; syms=0 MB; symw=0 MB\n2014.12.03D10:22:53.920656000|aquaq|test|INF|garbagecollect|Garbage collection returned 1472MB. mem stats: used=2 MB; heap=512 MB; peak=1984 MB; wmax=0 MB; mmap=0 MB; mphy=16384 MB; syms=0 MB; symw=0 MB\n</code></pre>"},{"location":"utilities/#table-manipulation","title":"Table Manipulation","text":"<p>The table manipulation utilities allow table manipulation routines to be defined in a single place. This is useful when data can be written from mutliple different processes e.g. RDB, WDB, or tickerplant log replay. Instead of having to create a separate definition of customised manipulation in each process, it can be done in a single location and invokved in each process.</p> <p></p>"},{"location":"utilities/#helpq","title":"help.q","text":"<p>The standard help.q from code.kx provides help utilities in the console. This should be kept up to date with [code.kx].</p> <pre><code>q)help`                                                                                                                                                                                                                         \nadverb    | adverbs/operators\nattributes| data attributes\ncmdline   | command line parameters\ndata      | data types\ndefine    | assign, define, control and debug\ndotz      | .z locale contents\nerrors    | error messages\nsave      | save/load tables\nsyscmd    | system commands\ntemporal  | temporal - date &amp; time casts\nverbs     | verbs/functions\n</code></pre> <p></p>"},{"location":"utilities/#htmlq","title":"html.q","text":"<p>An HTML utility has been added to accompany the HTML5 front end for the Monitoring process. It includes functions to format dates, tables to csv to configure the HTML file to work on the correct process. It is accessible from the <code>.html</code> namespace.</p> <p></p>"},{"location":"utilities/#eodtimeq","title":"eodtime.q","text":"<p>This script provides functionality for managing timezones. TorQ can be  configured to timestamp data in a specific timezone, while also being configured to perform the end of day rollover in another timezone, at a configurable time.</p> <p>These options are handled by three settings:</p> Setting Req Type Description .eodtime.rolltimeoffset Y timespan Offset from default midnight roll time .eodtime.rolltimezone Y symbol Time zone in which to rollover .eodtime.datatimezone Y symbol Time zone in which to timestamp data in TP <p>The default configuration sets both timezones to GMT and has the rollover performed at midnight.</p> <p>A table containing the valid timezones is loaded into TorQ processes as .tz.t</p> <p>An example configuration where data is stamped in GMT, but the rollover occurs at 5PM New York time would be:</p> <pre><code>.eodtime.rolltimeoffset:-0D07:00:00.000000000; // 5 PM i.e. 7 hours before midnight\n.eodtime.rolltimezone:`$\"America/New_YorK\";    // roll in NYC time\n.eodtime.datatimezone:`$\"GMT\";                 // timestamp in GMT\n</code></pre> <p>Note that the rolltimeoffset can be negative - this will cause the rollover to happen  \"yesterday\", meaning that at the rolltime, the trading date will become the day after the calendar date. Where this is positive, the rollover occurs \"today\" and so the trading date will become the current calendar date.</p>"},{"location":"utilities/#subscribercutoffq","title":"subscribercutoff.q","text":"<p>This script is used to provide functionality for cutting off any slow subscribers on any TorQ processes. The script will periodically check (time between checks set in .subcut.checkfreq. Default is 1 minute) the byte size of the queue for all the handles on the process to see if they have exceeded a set cut-off point (set in the variable .subcut.maxsize) and will only cut-off the handle if it exceeds this limit a set number of times in a row (default is 3 and set in the .subcut.breachlimit variable). This gives clients a chance to tidy up their behavior and will avoid cutting off clients if they happened to have a spike just before the check was performed. The .subcut.state variable is used to keep track of the handles and the  number of times they have exceeded the size limit in a row. </p> <p>To enable this functionality the .subcut.enabled flag must be set to true and  the timer.q script must be loaded on the desired processes. By default the chained  tickerplant is the only processes with the functionality enabled. </p>"},{"location":"utilities/#datareplayq","title":"datareplay.q","text":"<p>The datareplay utility provides functionality for generating tickerplant function calls from historcial data which can be executed by subscriber functions. This can be used to test a known data-set against a  subscriber for testing or debugging purposes.</p> <p>It can load this data from the current TorQ session, or from a remote hdb if given its connection handle.</p> <p>It can also chunk the data by time increments (as if the tickerplant was in batch mode), and can also generate calls to a custom timer function for the same time increments (defaults to .z.ts).</p> <p>The functions provided by this utility are made available in the .datareplay namespace.</p> <p>The utility is mainly used via the tabesToDataStreamFunction, which accepts a dictionary parameter with the following fields:</p> Key Example Value Description Required Default tabs <code>`trade`quote or `trade</code> List of tables to include Yes N/A sts 2014.04.04D07:00:00.000 Start timestamp for data Yes N/A ets 2014.04.04D16:30:00.000 End of timestamp for data Yes N/A syms <code>`AAPL`IBM</code> List of symbols to include No All syms where <code>,(=;`src;,`L)</code> Custom where clause in functional form No none timer 1b Generate timer function flag No 0b h 5i Handle to hdb process No 0i (self) interval 0D00:00:01.00 Time interval used to chunk data, bucketed by timestamp if no time interval set No None tc <code>`data_time</code> Name of time column to cut on No <code>`time</code> timerfunc .z.ts Timer function to use if `timer parameter is set No .z.ts <p>When the timer flag is set, the utility will interleave timer function calls in the message column at intervals based on the interval parameter, or every 10 seconds if interval is not set. This is useful if testing requires a call to a function at a set time, to generate a VWAP every 10 minutes for example. The function the timer messages call is based on the timerfunc parameter, or .z.ts if this parameter is not set.</p> <p>If the interval is set the messages will be aggregated into chunks based on the interval value, if no interval is specified, the data will be bucketed by timestamp (one message chunk per distinct timestamp per table).</p> <p>If no connection handle is specified (h parameter), the utility will retrieve the data from the process the utility is running on, using handle 0.</p> <p>The where parameter allows for the use of a custom where clause when extracting data, which can be useful when the dataset is large and only certain data is required, for example if only data where <code>src=`L</code> is required. The where clause(s) are required to be in functional form, for example <code>enlist (=;`src;,`L)</code> or <code>((=;`src;enlist `L);(&gt;;`size;100))</code> (note, that if only one custom where clause is included it is required to be enlisted).</p> <p>It is possible to get the functional form of a where clause by running parse on a mock select string like below:</p> <pre><code>q)parse \"select from t where src=`L,size&gt;100\"\n?\n`t\n,((=;`src;,`L);(&gt;;`size;100))\n0b\n()\n</code></pre> <p>The where clause is then the 3rd item returned in the parse tree.</p>"},{"location":"utilities/#examples","title":"Examples:","text":"<p>Extract all data between sts and ets from the trades table in the current process.</p> <pre><code>q)input\ntabs| `trades\nsts | 2014.04.21D07:00:00.000000000\nets | 2014.05.02D17:00:00.000000000\nq).datareplay.tablesToDataStream input\ntime                          msg                                            ..\n-----------------------------------------------------------------------------..\n2014.04.21D08:00:23.478000000 `upd `trades `sym`time`src`price`size!(`YHOO;20..\n2014.04.21D08:00:49.511000000 `upd `trades `sym`time`src`price`size!(`YHOO;20..\n2014.04.21D08:01:45.623000000 `upd `trades `sym`time`src`price`size!(`YHOO;20..\n2014.04.21D08:02:41.346000000 `upd `trades `sym`time`src`price`size!(`YHOO;20..\n..\nq)first .datareplay.tablesToDataStream input\ntime| 2014.04.21D08:00:23.478000000\nmsg | (`upd;`trades;`sym`time`src`price`size!(`YHOO;2014.04.21D08:00:23.47800..\n</code></pre> <p>Extract all data between sts and ets from the trades table from a remote hdb handle=3i.</p> <pre><code>q)input\ntabs| `trades\nsts | 2014.04.21D07:00:00.000000000\nets | 2014.05.02D17:00:00.000000000\nh   | 3i\nq).datareplay.tablesToDataStream input\ntime                          msg                                            ..\n-----------------------------------------------------------------------------..\n2014.04.21D08:00:07.769000000 `upd `trades `sym`time`src`price`size!(`IBM;201..\n2014.04.21D08:00:13.250000000 `upd `trades `sym`time`src`price`size!(`NOK;201..\n2014.04.21D08:00:19.070000000 `upd `trades `sym`time`src`price`size!(`MSFT;20..\n2014.04.21D08:00:23.678000000 `upd `trades `sym`time`src`price`size!(`YHOO;20..\n..\nq)first .datareplay.tablesToDataStream input\ntime| 2014.04.21D08:00:07.769000000\nmsg | (`upd;`trades;`sym`time`src`price`size!(`IBM;2014.04.21D08:00:07.769000..\n</code></pre> <p>Same as above but including quote table and with interval of 10 minutes:</p> <pre><code>q)input\ntabs    | `quotes`trades\nsts     | 2014.04.21D07:00:00.000000000\nets     | 2014.05.02D17:00:00.000000000\nh       | 3i\ninterval| 0D00:10:00.000000000\nq).datareplay.tablesToDataStream input\ntime                          msg                                            ..\n-----------------------------------------------------------------------------..\n2014.04.21D08:09:47.600000000 `upd `trades +`sym`time`src`price`size!(`YHOO`A..\n2014.04.21D08:09:55.210000000 `upd `quotes +`sym`time`src`bid`ask`bsize`asize..\n2014.04.21D08:19:39.467000000 `upd `trades +`sym`time`src`price`size!(`CSCO`N..\n2014.04.21D08:19:49.068000000 `upd `quotes +`sym`time`src`bid`ask`bsize`asize..\n..\nq)first .datareplay.tablesToDataStream input\ntime| 2014.04.21D08:09:47.600000000\nmsg | (`upd;`trades;+`sym`time`src`price`size!(`YHOO`AAPL`MSFT`NOK`DELL`YHOO`..\n</code></pre> <p>\u200b   All messages from trades where <code>src=`L</code> bucketed in 10 minute intervals interleaved with calls to the function <code>`vwap</code>.</p> <pre><code>q)input\ntabs     | `trades\nh        | 3i\nsts      | 2014.04.21D08:00:00.000000000\nets      | 2014.05.02D17:00:00.000000000\nwhere    | ,(=;`src;,`L)\ntimer    | 1b\ntimerfunc| `vwap\ninterval | 0D00:10:00.000000000\nq).datareplay.tablesToDataStream input\ntime                          msg                                            ..\n-----------------------------------------------------------------------------..\n2014.04.21D08:00:00.000000000 (`vwap;2014.04.21D08:00:00.000000000)          ..\n2014.04.21D08:09:46.258000000 (`upd;`trades;+`sym`time`src`price`size!(`AAPL`..\n2014.04.21D08:10:00.000000000 (`vwap;2014.04.21D08:10:00.000000000)          ..\n2014.04.21D08:18:17.188000000 (`upd;`trades;+`sym`time`src`price`size!(`AAPL`..\n..\n</code></pre>"},{"location":"utilities/#modified-uq","title":"Modified u.q","text":"<p>Starting in kdb+ v3.4, the new broadcast feature has some performance benefits. It works by serialising a message once before sending it asynchronously to a list of subscribers whereas the previous method would serialise it separately for each subscriber. To take advantage of this, we\u2019ve modified u.q. This can be turned off by setting .u.broadcast to false. It is enabled by default, but will only override default publishing if the kdb+ version being used is 3.4 or after.</p>"},{"location":"utilities/#bglaunchutilsq","title":"bglaunchutils.q","text":"<p>The background launch utilities allow other processes to be programmatically launched, or terminated, from inside a TorQ process. The two main functions here are .sys.bglaunch and .sys.bgkill.</p> <p>.sys.bglaunch is the q function which takes a dictionary of input parameters which are then passed to a bash script. This bash script functions like torq.sh in how it starts processes. It is important to note that the background launch utilities are only supported on Linux as a result.</p> <pre><code>\nq)input:`procname`proctype`localtime`p!(\"hdb1\";\"hdb\";\"0\";\"1234\");\n\n</code></pre> <p>The input parameter dictionary, as shown above, should contain symbols as keys and strings as values. Any standard or custom TorQ process can be launched using .sys.bglaunch, and as such the function can accept any desired command line parameters in the input dictionary. The minimum required are <code>`procname</code> and <code>`proctype</code>. In the case that only these two are used the other arguments will be given default values.</p> Parameter Default Value U The password file used for the parent launching process, if none exists ${KDBAPPCONFIG}/passwords/accesslist.txt is used localtime The .proc.localtime value of the parent launching process p 0W - a random port will be chosen qcmd q <p>The .sys.bgkill function is passed a single argument: the <code>`procname</code> of the process to be terminated, as a string.</p> <p>If the default value of \"0W\" is used for the port, a random port will be chosen on which to launch the process. In this case the process will neeed to register itself with discovery in order for other processes to be able to connect to it. This is a standard behaviour for TorQ processes on startup (for more information see Connection Management).</p> <p></p>"},{"location":"utilities/#full-api","title":"Full API","text":"<p>The full public api can be found by running</p> <pre><code>q).api.u`                                                                                                                                                                                                                       \nname             | vartype  namespace public descrip                 ..\n-----------------| --------------------------------------------------..\n.proc.createlog  | function .proc     1      \"Create the standard out..\n.proc.rolllogauto| function .proc     1      \"Roll the standard out/e..\n.proc.loadf      | function .proc     1      \"Load the specified file..\n.proc.loaddir    | function .proc     1      \"Load all the .q and .k ..\n.lg.o            | function .lg       1      \"Log to standard out\"   ..\n..\n</code></pre> <p>Combined with the commented configuration file, this should give a good overview of the functionality available. A description of the individual namespaces is below- run .api.u namespace*to list the functions.</p> Namespace Description .proc Process API .lg Standard out/error logging API .err Error throwing API .usage Usage logging API .access Permissions API .clients Client tracking API .servers Server tracking API .async Async communication API .timer Timer API .cache Caching API .tz Timezone conversions API .checks Monitoring API .cmp Compression API .ps Publish and Subscribe API .hb Heartbeating API .loader Data Loader API .sort Data sorting and attribute setting API .sub Subscription API .gc Garbage Collection API .tplog Tickerplant Log Replay API .api API management API"},{"location":"utilities/#api-table","title":"API Table","text":"name vartype namespace descrip params return .proc.createlog function .proc Create the standard out and standard err log files. Redirect to them [string: log directory; string: name of the log file;mixed: timestamp suffix for the file (can be null); boolean: suppress the generation of an alias link] null .proc.rolllogauto function .proc Roll the standard out/err log files [] null .proc.loadf function .proc Load the specified file [string: filename] null .proc.loaddir function .proc Load all the .q and .k files in the specified directory. If order.txt is found in the directory, use the ordering found in that file [string: name of directory] null .proc.getattributes function .proc Called by external processes to retrieve the attributes (advertised functionality) of this process [] dictionary of attributes .proc.override function .proc Override configuration varibles with command line parameters.  For example, if you set -.servers.HOPENTIMEOUT 5000 on the command line and call this function, then the command line value will be used [] null .proc.overrideconfig function .proc Override configuration varibles with values in supplied parameter dictionary. Generic version of .proc.override [dictionary: command line parameters.  .proc.params should be used] null .lg.o function .lg Log to standard out [symbol: id of log message; string: message] null .lg.e function .lg Log to standard err [symbol: id of log message; string: message] null .lg.l function .lg Log to either standard error or standard out, depending on the log level [symbol: log level; symbol: name of process; symbol: id of log message; string: message; dict: extra parameters, used in the logging extension function] null .lg.err function .lg Log to standard err [symbol: log level; symbol: name of process; symbol: id of log message; string: message; dict: extra parameters, used in the logging extension function] null .lg.ext function .lg Extra function invoked in standard logging function .lg.l.  Can be used to do more with the log message, e.g. publish externally [symbol: log level; symbol: name of process; symbol: id of log message; string: message; dict: extra parameters] null .err.ex function .err Log to standard err, exit [symbol: id of log message; string: message; int: exit code] null .err.usage function .err Throw a usage error and exit [] null .err.param function .err Check a dictionary for a set of required parameters. Print an error and exit if not all required are supplied [dict: parameters; symbol list: the required param values] null .err.env function .err Check if a list of required environment variables are set.  If not, print an error and exit [symbol list: list of required environment variables] null .usage.rolllogauto function .usage Roll the .usage txt files [] null .usage.readlog function .usage Read and return a usage log file as a table [string: name of log file] null .usage.logtodisk variable .usage whether to log to disk .usage.logtomemory variable .usage whether to log to .usage.usage .usage.ignore variable .usage whether to check the ignore list for functions to ignore .usage.ignorelist variable .usage the list of functions to ignore .usage.logroll variable .usage whether to automatically roll the log file .usage.usage table .usage log of messages through the message handlers .clients.clients table .clients table containing client handles and session values .sub.getsubscriptionhandles function .sub Connect to a list of processes of a specified type [symbol: process type to match; symbol: process name to match; dictionary:attributes of process] table of process names, types and the handle connected on .sub.subscribe function .sub Subscribe to a table or list of tables and specified instruments [symbol (list):table names; symbol (list): instruments; boolean: whether to set the schema from the server; boolean: wether to replay the logfile; dictionary: procname,proctype,handle .pm.adduser function .pm Adds a user to be permissioned as well as setting their password and the method used to hash it. [symbol: the username; symbol: method used to authenticate; symbol: method used to hash the password; string: password, hashed using the proper method] null .pm.addgroup function .pm Add a group which will have access to certain tables and variables [symbol: the name of the group; string: a description of the group] null .pm.addrole function .pm Add a role which will have access to certain functions [symbol: the name of the role; string: a description of the role] null .pm.addtogroup function .pm Add a user to a group, giving them access to all of its variables [symbol: the name of the user to add; symbol: group the user is to be added to] null .pm.assignrole function .pm Assign a user a role, giving them access to all of its functions [symbol: the name of the user to add; symbol: role the user is to be assigned to] null .pm.grantaccess function .pm Give a group access to a variable [symbol: the name of the variable the group should get access to; symbol: group that is to be given this access; symbol: the type of access that should be given, eg. read, write] null .pm.grantfunction function .pm Give a role access to a function symbol: name of the function to be added; symbol: role that is to be given this access; TO CLARIFY null .pm.createvirtualtable function .pm Create a virtual table that a group might be able to access instead of the full table [symbol: new name of the table; symbol: name of the actual table t add; TO CLARIFY] null .pm.cloneuser function .pm Add a new user that is identical to another user [symbol: name of the new user; symbol: name of the user to be cloned; string: password of the new user] null .access.addsuperuser function .access Add a super user [symbol: user] null .access.addpoweruser function .access Add a power user [symbol: user] null .access.adddefaultuser function .access Add a default user [symbol: user] null .access.readpermissions function .access Read the permissions from a directory [string: directory containing the permissions files] null .access.USERS table .access Table of users and their types .servers.opencon function .servers open a connection to a process using the default timeout. If no user:pass supplied, the default one will be added if set [symbol: the host:port[:user:pass]] int: the process handle, null if the connection failed .servers.addh function .servers open a connection to a server, store the connection details [symbol: the host:port:user:pass connection symbol] int: the server handle .servers.addw function .servers add the connection details of a process behind the handle [int: server handle] null .servers.addnthawc function .servers add the details of a connection to the table [symbol: process name; symbol: process type; hpup: host:port:user:pass connection symbol; dict: attributes of the process; int: handle to the process;boolean: whether to check the handle is valid on insert int: the handle of the process .servers.getservers function .servers get a table of servers which match the given criteria [symbol: pick the server based on the name value or the type value.  Can be either `procname`proctype; symbol(list): lookup values. ` for any; dict: requirements dictionary; boolean: whether to automatically open dead connections for the specified lookup values; boolean: if only one of each of the specified lookup values is required (means dead connections aren't opened if there is one available)] table: processes details and requirements matches .servers.gethandlebytype function .servers get a server handle for the supplied type [symbol: process type; symbol: selection criteria. One of `roundrobin`any`last] int: handle of server .servers.gethpbytype function .servers get a server hpup connection symbol for the supplied type [symbol: process type; symbol: selection criteria. One of `roundrobin`any`last] symbol: h:p:u:p connection symbol of server .servers.startup function .servers initialise all the connections.  Must processes should call this during initialisation [] null .servers.refreshattributes function .servers refresh the attributes registered with the discovery service.  Should be called whenever they change e.g. end of day for an HDB [] null .servers.SERVERS table .servers table containing server handles and session values .timer.repeat function .timer Add a repeating timer with default next schedule [timestamp: start time; timestamp: end time; timespan: period; mixedlist: (function and argument list); string: description string] null .timer.once function .timer Add a one-off timer to fire at a specific time [timestamp: execute time; mixedlist: (function and argument list); string: description string] null .timer.remove function .timer Delete a row from the timer schedule [int: timer id to delete] null .timer.removefunc function .timer Delete a specific function from the timer schedule [mixedlist: (function and argument list)] null .timer.rep function .timer Add a repeating timer - more flexibility than .timer.repeat [timestamp: execute time; mixedlist: (function and argument list); short: scheduling algorithm for next timer; string: description string; boolean: whether to check if this new function is already present on the schedule] null .timer.one function .timer Add a one-off timer to fire at a specific time - more flexibility than .timer.once [timestamp: execute time; mixedlist: (function and argument list); string: description string; boolean: whether to check if this new function is already present on the schedule] null .timer.timer table .timer The table containing the timer information .cache.execute function .cache Check the cache for a valid result set, return the results if found, execute the function, cache it and return if not [mixed: function or string to execute;timespan: maximum allowable age of cache item if found in cache] mixed: result of function .cache.getperf function .cache Return the performance statistics of the cache [] table: cache performance .cache.maxsize variable .cache The maximum size in MB of the cache. This is evaluated using -22!, so may be incorrect due to power of 2 memory allocation.  To be conservative and ensure it isn't exceeded, set max size to half of the actual max size that you want .cache.maxindividual variable .cache The maximum size in MB of an individual item in the cache. This is evaluated using -22!, so may be incorrect due to power of 2 memory allocation.  To be conservative and ensure it isn't exceeded, set max size to half of the actual max size that you want .tz.dg function .tz default from GMT. Convert a timestamp from GMT to the default timezone [timestamp (list): timestamps to convert] timestamp atom or list .tz.lg function .tz local from GMT. Convert a timestamp from GMT to the specified local timezone [symbol (list): timezone ids;timestamp (list): timestamps to convert] timestamp atom or list .tz.gd function .tz GMT from default. Convert a timestamp from the default timezone to GMT [timestamp (list): timestamps to convert] timestamp atom or list .tz.gl function .tz GMT from local. Convert a timestamp from the specified local timezone to GMT [symbol (list): timezone ids; timestamp (list): timestamps to convert] timestamp atom or list .tz.ttz function .tz Convert a timestamp from a specified timezone to a specified destination timezone [symbol (list): destination timezone ids; symbol (list): source timezone ids; timestamp (list): timestamps to convert] timestamp atom or list .tz.default variable .tz Default timezone .tz.t table .tz Table of timestamp information .email.connectdefault function .email connect to the default mail server specified in configuration [] .email.senddefault function .email connect to email server if not connected. Send email using default settings [dictionary of email parameters. Required dictionary keys are to (symbol (list) of email address to send to), subject (character list), body (list of character arrays).  Optional parameters are cc (symbol(list) of addresses to cc), bodyType (can be `html, default is `text), attachment (symbol (list) of files to attach), image (symbol of image to append to bottom of email. `none is no image), debug (int flag for debug level of connection library. 0i=no info, 1i=normal. 2i=verbose)] size in bytes of sent email. -1 if failure .email.test function .email send a test email [symbol(list):email address to send test email to] size in bytes of sent email. -1 if failure .hb.addprocs function .hb Add a set of process types and names to the heartbeat table to actively monitor for heartbeats.  Processes will be automatically added and monitored when the heartbeats are subscribed to, but this is to allow for the case where a process might already be dead and so can't be subscribed to [symbol(list): process types; symbol(list): process names] .hb.processwarning function .hb Callback invoked if any process goes into a warning state.  Default implementation is to do nothing - modify as required [table: processes currently in warning state] .hb.processerror function .hb Callback invoked if any process goes into an error state. Default implementation is to do nothing - modify as required [table: processes currently in error state] .hb.storeheartbeat function .hb Store a heartbeat update.  This function should be added to you update callback when a heartbeat is received [table: the heartbeat table data to store] .hb.warningperiod function .hb Return the warning period for a particular process type.  Default is to return warningtolerance * publishinterval. Can be overridden as required [symbollist: the process types to return the warning period for] timespan list of warning period .hb.errorperiod function .hb Return the error period for a particular process type.  Default is to return errortolerance * publishinterval. Can be overridden as required [symbollist: the process types to return the error period for] timespan list of error period .rdb.moveandclear function .rdb Move a variable (table) from one namespace to another, deleting its contents.  Useful during the end-of-day roll down for tables you do not want to save to the HDB [symbol: the namespace to move the table from; symbol:the namespace to move the variable to; symbol: the name of the variable] null .api.f function .api Find a function/variable/table/view in the current process [string:search string] table of matching elements .api.p function .api Find a public function/variable/table/view in the current process [string:search string] table of matching public elements .api.u function .api Find a non-standard q public function/variable/table/view in the current process.  This excludes the .q, .Q, .h, .o namespaces [string:search string] table of matching public elements .api.s function .api Search all function definitions for a specific string [string: search string] table of matching functions and definitions .api.find function .api Generic method for finding functions/variables/tables/views. f,p and u are based on this [string: search string; boolean (list): public flags to include; boolean: whether the search is context senstive table of matching elements .api.search function .api Generic method for searching all function definitions for a specific string. s is based on this [string: search string; boolean: whether the search is context senstive table of matching functions and definitions .api.add function .api Add a function to the api description table [symbol:the name of the function; boolean:whether it should be called externally; string:the description; dict or string:the parameters for the function;string: what the function returns] null .api.fullapi function .api Return the full function api table [] api table .api.m function .api Return the ordered approximate memory usage of each variable and view in the process. Views will be re-evaluated if required [] memory usage table .api.mem function .api Return the ordered approximate memory usage of each variable and view in the process. Views are only returned if view flag is set to true. Views will be re-evaluated if required [boolean:return views] memory usage table .api.whereami function .api Get the name of a supplied function definition. Can be used in the debugger e.g. .api.whereami[.z.s] function definition symbol: the name of the current function .ps.publish function .ps Publish a table of data [symbol: name of table; table: table of data] .ps.subscribe function .ps Subscribe to a table and list of instruments [symbol(list): table name. ` for all; symbol(list): symbols to subscribe to. ` for all] mixed type list of table names and schemas .ps.initialise function .ps Initialise the pubsub routines.  Any tables that exist in the top level can be published [] .async.deferred function .async Use async messaging to simulate sync communication [int(list): handles to query; query] (boolean list:success status; result list) .async.postback function .async Send an async message to a process and the results will be posted back within the postback function call [int(list): handles to query; query; postback function] boolean list: successful send status .cmp.showcomp function .cmp Show which files will be compressed and how; driven from csv file [`:/path/to/database; `:/path/to/configcsv; maxagefilestocompress] table of files to be compressed .cmp.compressmaxage function .cmp Run compression on files using parameters specified in configuration csv file, and specifying the maximum age of files to compress [`:/path/to/database; `:/path/to/configcsv; maxagefilestocompress] .cmp.docompression function .cmp Run compression on files using parameters specified in configuration csv file [`:/path/to/database; `:/path/to/configcsv] .loader.loadallfiles function .loader Generic loader function to read a directory of files in chunks and write them out to disk [dictionary of load parameters. Should have keys of headers (symbol list), types (character list), separator (character), tablename (symbol), dbdir (symbol).  Optional params of dataprocessfunc (diadic function), datecol (name of column to extract date from: symbol), chunksize (amount of data to read at once:int), compression (compression parameters to use e.g. 16 1 0:int list), gc (boolean flag of whether to run garbage collection:boolean); directory containing files to load (symbol)] .sort.sorttab function .sort Sort and set the attributes for a table and set of partitions based on a configuration file (default is $KDBCONFIG/sort.csv) [2 item list of (tablename e.g. `trade; partitions to sort and apply attributes to e.g. `:/hdb/2000.01.01/trade`:hdb/2000.01.02/trade)] .sort.getsortcsv function .sort Read in the sort csv from the specified location [symbol: the location of the file e.g. `:config/sort.csv] .gc.run function .gc Run garbage collection, print debug info before and after .mem.objsize function .mem Returns the calculated memory size in bytes used by an object.  It may take a little bit of time for objects with lots of nested structures (e.g. lots of nested columns) [q object] size of the object in bytes .tplog.check function .tplog Checks if tickerplant log can be replayed.  If it can or can replay the first X messages, then returns the log handle, else it will read log as byte stream and create a good log and then return the good log handle [logfile (symbol), handle to the log file to check; lastmsgtoreplay (long), the index of the last message to be replayed from log ] handle to log file, will be either the input log handle or handle to repaired log, depends on whether the log was corrupt"},{"location":"utilities/#grafanaq","title":"grafana.q","text":"<p>Grafana is an open source analytics platform, used to display time-series data from a web application. Currently it supports a variety of data sources including Graphite, InfluxDb &amp; Prometheus with users including the likes of  Paypal, Ebay, Intel and Booking.com.  However, there is no in-built support for direct analysis of data from kdb+. Thus, using the  SimpleJSON data source, we have engineered an adaptor to allow visualisation of kdb+ data.</p>"},{"location":"utilities/#requirements","title":"Requirements","text":"<p>Grafana v5.2.2+ (Tested on Kdb v3.5+)</p>"},{"location":"utilities/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Download and set up Grafana. This is well explained on the  Grafana website, where you have the option to either download the software locally or let Grafana host it for you. For the purpose  of this document, we host the software locally.</p> </li> <li> <p>Pull down this repository with the adaptor already installed in code/common.</p> </li> <li> <p>In your newly installed Grafana folder (eg.grafana-5.2.2/) run the command:     <code>./bin/grafana-server web</code>. This will start your Grafana server. If you would like to alter the port which  this is run on, this can be changed in:     <code>/grafana-5.2.2/conf/custom.ini</code>, Where custom.ini should be a copy of defaults.ini.</p> </li> <li> <p>You can now open the Grafana server in your web browser where you will be  greeted with a login page to fill in appropriately.</p> </li> <li> <p>Once logged in, navigate to the configurations-&gt;plugin section where you  will find the simple JSON adaptor, install this.</p> </li> <li> <p>Upon installation of the JSON you can now set-up your datasource. </p> </li> <li> <p>Host your data on a port accesible to Grafana, eg. the RDB.</p> </li> <li> <p>In the \"add new datasource\" panel, enter the details for the port in which  your data is hosted, making the type SimpleJSON.</p> </li> <li> <p>Run the test button on the bottom of your page, this should succeed and you  are ready to go!</p> </li> </ol>"},{"location":"utilities/#using-the-adaptor","title":"Using the adaptor","text":"<p>As the adaptor is part of the TorQ framework it will automatically be loaded  into TorQ sessions. From this point onwards you can proceed to use Grafana as  it is intended, with the only difference coming in the form of the queries. Use  cases and further examples of the queries can be seen in our blogpost: The Grafana-KDB Adaptor. For information and examples of how to execute server side functions in queries, please read our followup blogpost on the subject: Grafana kdb+ Adaptor Update.  Here you can see examples of graphs, tables, heatmaps and single statistics.  The best explanation of the inputs allowed in the query section can be seen pictorially here:</p> <p></p> <p>Upon opening the query box, in the metrics tab, the user will be provided with  a populated drop down of all possible options. Server functions are not included in the dropdown, but can be called by entering the letter f followed by the value of <code>.grafana.del</code> (see below) before their function call. Due to the limitations of the JSON messages, it is not possible for our adaptor to distinguish between panels.  Consequently, every possible option is returned for each panel, the user can reduce these choices by simply entering the first letter of their panel type,  g for graph, t for table and o for other (heatmap or single stat). From here,  you can follow the above diagram to specify your type of query.</p>"},{"location":"utilities/#limitations-assumptions","title":"Limitations &amp; Assumptions","text":"<p>This adaptor has been built to allow visualisation of real-time and historical  data. It is capable of handling static and timeseries data.  In addition, the  drop-down options have been formed such that only one query is possible per  panel. If more than one query on a specfic panel is made it will throw an error.  To get around this, we added the options of including all \"syms\" in queries so  the options can be filtered out in the legend. </p> <p>Table queries should work for any table format supplied to the adaptor. However,  time series data is limited by the requriment of a time column, in our adaptor  we assume this column to be called time. This assumption can be modified to fit  your data in the settings (config/settings/defualt.q) file which dictates the  following lines at the start of the script:</p> <pre><code>// user defined column name of time column\ntimecol:@[value;`.grafana.timecol;`time];\n// user defined column name of sym column\nsym:@[value;`.grafana.sym;`sym];\n// user defined date range to find syms from\ntimebackdate:@[value;`.grafana.timebackdate;2D];\n// user defined number of ticks to return\nticks:@[value;`.grafana.ticks;1000];\n// user defined query argument deliminator\ndel:@[value;`.grafana.del;\".\"];\n\n</code></pre> <p><code>.grafana.timecol</code> represents the name of the time column and thus can be  reassigned if your time column has a different name, eg. date. One more common  modification could be changing the variable <code>.grafana.sym</code> which defines  the name of the the sym column, which is normally referenced in financial data.  However if the data is non-financial this could be tailored to represent another  identifier such as name or postcode. This column is used to populate the drop  down options in the query selector. </p> <p><code>.grafana.timebackdate</code> is a user definable variable which dictates how  far back into a hdb the adaptor will look to gather options for distinct syms to  populate the dropdowns. It is important to note that this should be increased if  all your required syms are not in the last 2 days. Optionally a user could hard code this list or implement their own search function to limit interrogation of  the database. <code>.grafana.ticks</code> can be defined so that only n rows from the end of the table will be queried. This can be left as large as the user likes, but is included for managing large  partitioned tables. </p> <p>One final important variable is <code>.grafana.del</code>, this dictates the delimeter  between options in the drop down menus. This has significant repercussions if  one of your columns includes full stops, eg. email adresses. As a result we have  left this as definable so that the user can alter this to a non-disruptive value  for their data eg./.</p>"},{"location":"visualisation/","title":"Visualisation","text":"<p>kdb+ supports websockets and so HTML5 GUIs can be built. We have incorporated a set of server side and client side utilities to ease HTML GUI development.</p> <p></p>"},{"location":"visualisation/#kdb-utilities","title":"kdb+ Utilities","text":"<p>The server side utilities are contained in html.q. These utilise some community code, specifically json.k and a modified version of u.q, both from Kx Systems. The supplied functionality includes:</p> <ul> <li> <p>json.k provides two way conversion between kdb+ data structures and     JSON;</p> </li> <li> <p>u.q is the standard pub/sub functionality provided with kdb+tick,     and a modified version is incorporated to publish data structures     which can be easily interpreted in JavaScript;</p> </li> <li> <p>functions for reformatting temporal types to be JSON compliant;</p> </li> <li> <p>page serving to utilise the inbuilt kdb+ webserver to serve custom     web pages. An example would be instead of having to serve a page     with a hardcoded websocket connection host and port, the kdb+     process can serve a page connecting back to itself no matter which     host or port it is running on.</p> </li> </ul> <p></p>"},{"location":"visualisation/#javascript-utilities","title":"JavaScript Utilities","text":"<p>The JavaScript utilities are contained in kdbconnect.js. The library allows you to:</p> <ul> <li> <p>create a connection to the kdb+ process;</p> </li> <li> <p>display the socket status;</p> </li> <li> <p>sending queries;</p> </li> <li> <p>binding results returned from kdb+ to updates in the webpage.</p> </li> </ul> <p></p>"},{"location":"visualisation/#outline","title":"Outline","text":"<p>All communication between websockets and kdb+ is asynchronous. The approach we have adopted is to ensure that all data sent to the web browser is encoded as a JSON object containing a tag to enable the web page to decipher what the data relates to. The format we have chosen is for kdb+ to send dictionaries of the form:</p> <pre><code>`name`data!(\"dataID\";dataObject)\n</code></pre> <p>All the packing can be done by .html.dataformat. Please note that the temporal types are converted to longs which can easily be converted to JavaScript Date types. This formatting can be modified in the formating dictionary .html.typemap.</p> <pre><code>q)a:flip `minute`time`date`month`timestamp`timespan`datetime`float`sym!enlist each (09:00; 09:00:00.0;.z.d; `month$.z.d; .z.p; .z.n;.z.z;20f;`a)\nq).html.dataformat[\"start\";(enlist `tradegraph)!enlist a]\nname| \"start\"\ndata| (,`tradegraph)!,+`minute`time`date`month`timestamp`timespan`datetime`float`sym!(,32400000;,32400000;,1396828800000;,1396310400000;,\"2014-04-07T13:23:01Z\";,48181023;,\"2014-04-07T13:23:01Z\";,20f;,`a)\nq)first (.html.dataformat[\"start\";(enlist `tradegraph)!enlist a])[`data;`tradegraph]                                                                                     \nminute   | 32400000\ntime     | 32400000\ndate     | 1396828800000\nmonth    | 1396310400000\ntimestamp| \"2014-04-07T13:23:01Z\"\ntimespan | 48181023\ndatetime | \"2014-04-07T13:23:01Z\"\nfloat    | 20f\nsym      | `a\n</code></pre> <p>We have also extended this structure to allow web pages to receive data in a way similar to the standard kdb+tick pub/sub format. In this case, the data object looks like:</p> <pre><code>`name`data!(\"upd\";`tablename`tabledata!(`trade;([]time:09:00 09:05 09:10; price:12 13 14)))\n</code></pre> <p>This can be packed with .html.updformat:</p> <pre><code>q).html.updformat[\"upd\";`tablename`tabledata!(`trade;a)]                                                                                                                 \nname| \"upd\"\ndata| `tablename`tabledata!(`trade;+`minute`time`date`month`timestamp`timespan`datetime`float`sym!(,32400000;,32400000;,1396828800000;,1396310400000;,\"2014-04-07T13:23:01Z\";,48181023;,\"2014-04-07T13:23:01Z\";,20f;,`a))\nq)first(.html.updformat[\"upd\";`tablename`tabledata!(`trade;a)])[`data;`tabledata]                                                                                        \nminute   | 32400000\ntime     | 32400000\ndate     | 1396828800000\nmonth    | 1396310400000\ntimestamp| \"2014-04-07T13:23:01Z\"\ntimespan | 48181023\ndatetime | \"2014-04-07T13:23:01Z\"\nfloat    | 20f\nsym      | `a\n</code></pre> <p>To utilise the pub/sub functionality, the web page must connect to the kdb+ process and subscribe for updates. Subscriptions are done using</p> <pre><code>.html.wssub[`tablename]\n</code></pre> <p>Publications from the kdb+ side are done with</p> <pre><code>.html.pub[`tablename;tabledata]\n</code></pre> <p>On the JavaScript side the incoming messages (data events) must be bound to page updates. For example, there might be an initialisation event called \u201cstart\u201d which allows the web page to retrieve all the initial data from the process. The code below redraws the areas of the page with the received data.</p> <pre><code>/* Bind data - Data type \"start\" will execute the callback function */\nKDBCONNECT.bind(\"data\",\"start\",function(data){\n  // Check that data is not empty\n  if(data.hbtable.length !== 0)\n   // Write HTML table to div element with id heartbeat-table\n   { $(\"#heartbeat-table\").html(MONITOR.jsonTable(data.hbtable));}\n  if(data.lmtable.length !== 0)\n   // Write HTML table to div element with id logmsg-table\n   { $(\"#logmsg-table\").html(MONITOR.jsonTable(data.lmtable));}  \n  if(data.lmchart.length !== 0)\n   // Log message error chart\n   { MONITOR.barChart(data.lmchart,\"logmsg-chart\",\"Error Count\",\"myTab\"); }\n  });\n</code></pre> <p>Similarly the upd messages must be bound to page updates. In this case, the structure is slightly different:</p> <pre><code>KDBCONNECT.bind(\"data\",\"upd\",function(data){\n  if(data.tabledata.length===0) return;\n  if(data.tablename === \"heartbeat\")\n    { $(\"#heartbeat-table\").html(MONITOR.jsonTable(data.tabledata));}\n  if(data.tablename === \"logmsg\")\n    { $(\"#logmsg-table\").html(MONITOR.jsonTable(data.tabledata));}\n  if(data.tablename === \"lmchart\")\n    { MONITOR.barChart(data.tabledata,\"logmsg-chart\",\"Error Count\",\"myTab\"); }\n });\n</code></pre> <p>To display the WebSocket connection status the event \u201cws_event\u201d must be bound and it will output one of these default messages: \u201cConnecting...\u201d, \u201cConnected\u201d and \u201cDisconnected\u201d depending on the connection state of the WebSocket. Alternatively the value of the readyState attribute will determine the WebSocket status.</p> <pre><code>// Select html element using jQuery\nvar $statusMsg = $(\"#status-msg\");  \nKDBCONNECT.bind(\"ws_event\",function(data){\n  // Data is the default message string\n  $statusMsg.html(data);\n});\nKDBCONNECT.core.websocket.readyState // Returns 1 if connected.\n</code></pre> <p>Errors can be displayed by binding the event called \u201cerror\u201d.</p> <pre><code>KDBCONNECT.bind(\"error\",function(data){\n  $statusMsg.html(\"Error - \" + data);\n});\n</code></pre> <p></p>"},{"location":"visualisation/#example","title":"Example","text":"<p>A basic example is provided with the Monitor process. To get this to work, u.q from kdb+tick should be placed in the code/common directory to allow all processes to publish updates. It should be noted that this is not intended as a production monitoring visualisation screen, moreso a demonstration of functionality. See section\u00a0monitorgui for more details.</p> <p></p>"},{"location":"visualisation/#further-work","title":"Further Work","text":"<p>Further work planned includes:</p> <ul> <li> <p>allow subscriptions on a key basis- currently all subscribers     receive all updates;</p> </li> <li> <p>add JavaScript controls to allow in-place updates based on key     pairs, and scrolling window updates e.g. add N new rows to     top/bottom of the specified table;</p> </li> <li> <p>allow multiple websocket connections to be maintained at the same     time.</p> </li> </ul>"}]}